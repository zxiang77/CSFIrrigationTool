// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var R_EARTH = 6378000;

/**
 * Calculate density grid from an array of points
 * @param {array} points
 * @param {number} cellSize - cell size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid data, cell dimension and count range
 */
export function pointToDensityGridData(points, cellSize, getPosition) {
  var _pointsToGridHashing2 = _pointsToGridHashing(points, cellSize, getPosition),
      gridHash = _pointsToGridHashing2.gridHash,
      gridOffset = _pointsToGridHashing2.gridOffset;

  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);
  var countRange = _getCellCountExtent(layerData);

  return {
    gridOffset: gridOffset,
    layerData: layerData,
    countRange: countRange
  };
}

/**
 * Project points into each cell, return a hash table of cells
 * @param {array} points
 * @param {number} cellSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid hash and cell dimension
 */
function _pointsToGridHashing(points, cellSize, getPosition) {

  // find the geometric center of sample points
  var allLat = points.map(function (p) {
    return getPosition(p)[1];
  });
  var latMin = Math.min.apply(null, allLat);
  var latMax = Math.max.apply(null, allLat);

  var centerLat = (latMin + latMax) / 2;

  var gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);

  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset: gridOffset };
  }
  // calculate count per cell
  var gridHash = points.reduce(function (accu, pt) {
    var latIdx = Math.floor((getPosition(pt)[1] + 90) / gridOffset.yOffset);
    var lonIdx = Math.floor((getPosition(pt)[0] + 180) / gridOffset.xOffset);
    var key = latIdx + '-' + lonIdx;

    accu[key] = accu[key] || { count: 0, points: [] };
    accu[key].count += 1;
    accu[key].points.push(pt);

    return accu;
  }, {});

  return { gridHash: gridHash, gridOffset: gridOffset };
}

function _getGridLayerDataFromGridHash(gridHash, gridOffset) {
  return Object.keys(gridHash).reduce(function (accu, key, i) {
    var idxs = key.split('-');
    var latIdx = parseInt(idxs[0], 10);
    var lonIdx = parseInt(idxs[1], 10);

    accu.push(Object.assign({
      index: i,
      position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]
    }, gridHash[key]));

    return accu;
  }, []);
}

function _getCellCountExtent(data) {
  return data.length ? [Math.min.apply(null, data.map(function (d) {
    return d.count;
  })), Math.max.apply(null, data.map(function (d) {
    return d.count;
  }))] : [0, 1];
}

/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} cellSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */
function _calculateGridLatLonOffset(cellSize, latitude) {
  var yOffset = _calculateLatOffset(cellSize);
  var xOffset = _calculateLonOffset(latitude, cellSize);
  return { yOffset: yOffset, xOffset: xOffset };
}

/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */
function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}

/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */
function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtYWdncmVnYXRvci5qcyJdLCJuYW1lcyI6WyJSX0VBUlRIIiwicG9pbnRUb0RlbnNpdHlHcmlkRGF0YSIsInBvaW50cyIsImNlbGxTaXplIiwiZ2V0UG9zaXRpb24iLCJfcG9pbnRzVG9HcmlkSGFzaGluZyIsImdyaWRIYXNoIiwiZ3JpZE9mZnNldCIsImxheWVyRGF0YSIsIl9nZXRHcmlkTGF5ZXJEYXRhRnJvbUdyaWRIYXNoIiwiY291bnRSYW5nZSIsIl9nZXRDZWxsQ291bnRFeHRlbnQiLCJhbGxMYXQiLCJtYXAiLCJwIiwibGF0TWluIiwiTWF0aCIsIm1pbiIsImFwcGx5IiwibGF0TWF4IiwibWF4IiwiY2VudGVyTGF0IiwiX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQiLCJ4T2Zmc2V0IiwieU9mZnNldCIsInJlZHVjZSIsImFjY3UiLCJwdCIsImxhdElkeCIsImZsb29yIiwibG9uSWR4Iiwia2V5IiwiY291bnQiLCJwdXNoIiwiT2JqZWN0Iiwia2V5cyIsImkiLCJpZHhzIiwic3BsaXQiLCJwYXJzZUludCIsImFzc2lnbiIsImluZGV4IiwicG9zaXRpb24iLCJkYXRhIiwibGVuZ3RoIiwiZCIsImxhdGl0dWRlIiwiX2NhbGN1bGF0ZUxhdE9mZnNldCIsIl9jYWxjdWxhdGVMb25PZmZzZXQiLCJkeSIsIlBJIiwibGF0IiwiZHgiLCJjb3MiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsVUFBVSxPQUFoQjs7QUFFQTs7Ozs7OztBQU9BLE9BQU8sU0FBU0Msc0JBQVQsQ0FBZ0NDLE1BQWhDLEVBQXdDQyxRQUF4QyxFQUFrREMsV0FBbEQsRUFBK0Q7QUFBQSw4QkFFckNDLHFCQUFxQkgsTUFBckIsRUFBNkJD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aWxlIjoiZ3JpZC1hZ2dyZWdhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5jb25zdCBSX0VBUlRIID0gNjM3ODAwMDtcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGVuc2l0eSBncmlkIGZyb20gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSAtIGNlbGwgc2l6ZSBpbiBtZXRlcnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gZ3JpZCBkYXRhLCBjZWxsIGRpbWVuc2lvbiBhbmQgY291bnQgcmFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9EZW5zaXR5R3JpZERhdGEocG9pbnRzLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb24pIHtcblxuICBjb25zdCB7Z3JpZEhhc2gsIGdyaWRPZmZzZXR9ID0gX3BvaW50c1RvR3JpZEhhc2hpbmcocG9pbnRzLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb24pO1xuICBjb25zdCBsYXllckRhdGEgPSBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCk7XG4gIGNvbnN0IGNvdW50UmFuZ2UgPSBfZ2V0Q2VsbENvdW50RXh0ZW50KGxheWVyRGF0YSk7XG5cbiAgcmV0dXJuIHtcbiAgICBncmlkT2Zmc2V0LFxuICAgIGxheWVyRGF0YSxcbiAgICBjb3VudFJhbmdlXG4gIH07XG59XG5cbi8qKlxuICogUHJvamVjdCBwb2ludHMgaW50byBlYWNoIGNlbGwsIHJldHVybiBhIGhhc2ggdGFibGUgb2YgY2VsbHNcbiAqIEBwYXJhbSB7YXJyYXl9IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplIC0gdW5pdCBzaXplIGluIG1ldGVyc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvclxuICogQHJldHVybnMge29iamVjdH0gLSBncmlkIGhhc2ggYW5kIGNlbGwgZGltZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIF9wb2ludHNUb0dyaWRIYXNoaW5nKHBvaW50cywgY2VsbFNpemUsIGdldFBvc2l0aW9uKSB7XG5cbiAgLy8gZmluZCB0aGUgZ2VvbWV0cmljIGNlbnRlciBvZiBzYW1wbGUgcG9pbnRzXG4gIGNvbnN0IGFsbExhdCA9IHBvaW50cy5tYXAocCA9PiBnZXRQb3NpdGlvbihwKVsxXSk7XG4gIGNvbnN0IGxhdE1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIGFsbExhdCk7XG4gIGNvbnN0IGxhdE1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGFsbExhdCk7XG5cbiAgY29uc3QgY2VudGVyTGF0ID0gKGxhdE1pbiArIGxhdE1heCkgLyAyO1xuXG4gIGNvbnN0IGdyaWRPZmZzZXQgPSBfY2FsY3VsYXRlR3JpZExhdExvbk9mZnNldChjZWxsU2l6ZSwgY2VudGVyTGF0KTtcblxuICBpZiAoZ3JpZE9mZnNldC54T2Zmc2V0IDw9IDAgfHwgZ3JpZE9mZnNldC55T2Zmc2V0IDw9IDApIHtcbiAgICByZXR1cm4ge2dyaWRIYXNoOiB7fSwgZ3JpZE9mZnNldH07XG4gIH1cbiAgLy8gY2FsY3VsYXRlIGNvdW50IHBlciBjZWxsXG4gIGNvbnN0IGdyaWRIYXNoID0gcG9pbnRzLnJlZHVjZSgoYWNjdSwgcHQpID0+IHtcbiAgICBjb25zdCBsYXRJZHggPSBNYXRoLmZsb29yKChnZXRQb3NpdGlvbihwdClbMV0gKyA5MCkgLyBncmlkT2Zmc2V0LnlPZmZzZXQpO1xuICAgIGNvbnN0IGxvbklkeCA9IE1hdGguZmxvb3IoKGdldFBvc2l0aW9uKHB0KVswXSArIDE4MCkgLyBncmlkT2Zmc2V0LnhPZmZzZXQpO1xuICAgIGNvbnN0IGtleSA9IGAke2xhdElkeH0tJHtsb25JZHh9YDtcblxuICAgIGFjY3Vba2V5XSA9IGFjY3Vba2V5XSB8fCB7Y291bnQ6IDAsIHBvaW50czogW119O1xuICAgIGFjY3Vba2V5XS5jb3VudCArPSAxO1xuICAgIGFjY3Vba2V5XS5wb2ludHMucHVzaChwdCk7XG5cbiAgICByZXR1cm4gYWNjdTtcbiAgfSwge30pO1xuXG4gIHJldHVybiB7Z3JpZEhhc2gsIGdyaWRPZmZzZXR9O1xufVxuXG5mdW5jdGlvbiBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZ3JpZEhhc2gpLnJlZHVjZSgoYWNjdSwga2V5LCBpKSA9PiB7XG4gICAgY29uc3QgaWR4cyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxhdElkeCA9IHBhcnNlSW50KGlkeHNbMF0sIDEwKTtcbiAgICBjb25zdCBsb25JZHggPSBwYXJzZUludChpZHhzWzFdLCAxMCk7XG5cbiAgICBhY2N1LnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICBpbmRleDogaSxcbiAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgIC0xODAgKyBncmlkT2Zmc2V0LnhPZmZzZXQgKiBsb25JZHgsXG4gICAgICAgIC05MCArIGdyaWRPZmZzZXQueU9mZnNldCAqIGxhdElkeFxuICAgICAgXVxuICAgIH0sIGdyaWRIYXNoW2tleV0pKTtcblxuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDZWxsQ291bnRFeHRlbnQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5sZW5ndGggPyBbXG4gICAgTWF0aC5taW4uYXBwbHkobnVsbCwgZGF0YS5tYXAoZCA9PiBkLmNvdW50KSksXG4gICAgTWF0aC5tYXguYXBwbHkobnVsbCwgZGF0YS5tYXAoZCA9PiBkLmNvdW50KSlcbiAgXSA6IFswLCAxXTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgZ3JpZCBsYXllciBjZWxsIHNpemUgaW4gbGF0IGxvbiBiYXNlZCBvbiB3b3JsZCB1bml0IHNpemVcbiAqIGFuZCBjdXJyZW50IGxhdGl0dWRlXG4gKiBAcGFyYW0ge251bWJlcn0gY2VsbFNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXRpdHVkZVxuICogQHJldHVybnMge29iamVjdH0gLSBsYXQgZGVsdGEgYW5kIGxvbiBkZWx0YVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlR3JpZExhdExvbk9mZnNldChjZWxsU2l6ZSwgbGF0aXR1ZGUpIHtcbiAgY29uc3QgeU9mZnNldCA9IF9jYWxjdWxhdGVMYXRPZmZzZXQoY2VsbFNpemUpO1xuICBjb25zdCB4T2Zmc2V0ID0gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXRpdHVkZSwgY2VsbFNpemUpO1xuICByZXR1cm4ge3lPZmZzZXQsIHhPZmZzZXR9O1xufVxuXG4vKipcbiAqIHdpdGggYSBnaXZlbiB4LWttIGNoYW5nZSwgY2FsY3VsYXRlIHRoZSBpbmNyZW1lbnQgb2YgbGF0aXR1ZGVcbiAqIGJhc2VkIG9uIHN0YWNrb3ZlcmZsb3cgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDc3MDAzXG4gKiBAcGFyYW0ge251bWJlcn0gZHkgLSBjaGFuZ2UgaW4ga21cbiAqIEByZXR1cm4ge251bWJlcn0gLSBpbmNyZW1lbnQgaW4gbGF0aXR1ZGVcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUxhdE9mZnNldChkeSkge1xuICByZXR1cm4gKGR5IC8gUl9FQVJUSCkgKiAoMTgwIC8gTWF0aC5QSSk7XG59XG5cbi8qKlxuICogd2l0aCBhIGdpdmVuIHgta20gY2hhbmdlLCBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogY2FsY3VsYXRlIHRoZSBpbmNyZW1lbnQgb2YgbG9uZ2l0dWRlXG4gKiBiYXNlZCBvbiBzdGFja292ZXJmbG93IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ3NzAwM1xuICogQHBhcmFtIHtudW1iZXJ9IGxhdCAtIGxhdGl0dWRlIG9mIGN1cnJlbnQgbG9jYXRpb24gKGJhc2VkIG9uIGNpdHkpXG4gKiBAcGFyYW0ge251bWJlcn0gZHggLSBjaGFuZ2UgaW4ga21cbiAqIEByZXR1cm4ge251bWJlcn0gLSBpbmNyZW1lbnQgaW4gbG9uZ2l0dWRlXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVMb25PZmZzZXQobGF0LCBkeCkge1xuICByZXR1cm4gKGR4IC8gUl9FQVJUSCkgKiAoMTgwIC8gTWF0aC5QSSkgLyBNYXRoLmNvcyhsYXQgKiBNYXRoLlBJIC8gMTgwKTtcbn1cbiJdfQ==