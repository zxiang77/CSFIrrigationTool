// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { GL, glContextWithState } from 'luma.gl';
import { getUniformsFromViewport } from './viewport-uniforms';
import { log, getBlendMode, setBlendMode } from './utils';

var EMPTY_PIXEL = new Uint8Array(4);
var renderCount = 0;

export function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  log.log(3, 'DRAWING ' + layers.length + ' layers');

  // render layers in normal colors
  var visibleCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });

  log.log(3, 'RENDER PASS ' + pass + ': ' + renderCount++ + '\n    ' + visibleCount + ' visible, ' + layers.length + ' total');
}

/* eslint-disable max-depth, max-statements */
export function pickLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      _ref2$uniforms = _ref2.uniforms,
      uniforms = _ref2$uniforms === undefined ? {} : _ref2$uniforms,
      x = _ref2.x,
      y = _ref2.y,
      viewport = _ref2.viewport,
      mode = _ref2.mode,
      lastPickedInfo = _ref2.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * pixelRatio;
  var deviceY = gl.canvas.height - y * pixelRatio;

  // TODO - just return glContextWithState once luma updates
  var unhandledPickInfos = [];

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  glContextWithState(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {

    // Picking process start
    // Clear the frame buffer
    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    // Save current blend settings
    var oldBlendMode = getBlendMode(gl);
    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);

        layer.drawLayer({
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColor = new Uint8Array(4);
    gl.readPixels(deviceX, deviceY, 1, 1, GL.RGBA, GL.UNSIGNED_BYTE, pickedColor);

    // restore blend mode
    setBlendMode(gl, oldBlendMode);
    // Picking process end

    // Process picked info start
    // Decode picked color
    var pickedLayerIndex = pickedColor[3] - 1;
    var pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;
    var pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;
    var affectedLayers = pickedLayer ? [pickedLayer] : [];

    if (mode === 'hover') {
      // only invoke onHover events if picked object has changed
      var lastPickedObjectIndex = lastPickedInfo.index;
      var lastPickedLayerId = lastPickedInfo.layerId;

      if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {
        // picked object did not change, no need to proceed
        return;
      }

      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (l) {
          return l.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }

    var baseInfo = createInfo([x, y], viewport);
    baseInfo.devicePixel = [deviceX, deviceY];
    baseInfo.pixelRatio = pixelRatio;

    // Use a Map to store all picking infos.
    // The following two forEach loops are the result of
    // https://github.com/uber/deck.gl/issues/443
    // Please be very careful when changing this pattern
    var infos = new Map();

    affectedLayers.forEach(function (layer) {
      var info = Object.assign({}, baseInfo);

      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }

      // Walk up the composite chain and find the owner of the event
      // sublayers are never directly exposed to the user
      while (layer && info) {
        // For a composite layer, sourceLayer will point to the sublayer
        // where the event originates from.
        // It provides additional context for the composite layer's
        // getPickingInfo() method to populate the info object
        var sourceLayer = info.layer || layer;
        info.layer = layer;
        // layer.pickLayer() function requires a non-null ```layer.state```
        // object to funtion properly. So the layer refereced here
        // must be the "current" layer, not an "out-dated" / "invalidated" layer
        info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
        layer = layer.parentLayer;
      }

      // This guarantees that there will be only one copy of info for
      // one composite layer
      if (info) {
        infos.set(info.layer.id, info);
      }
    });

    infos.forEach(function (info) {
      var handled = false;
      // The onClick and onHover functions are provided by the user
      // and out of control by deck.gl. It's very much possible that
      // the user calls React lifecycle methods in these function, such as
      // ReactComponent.setState(). React lifecycle methods sometimes induce
      // a re-render and re-generation of props of deck.gl and its layers,
      // which invalidates all layers currently passed to this very function.

      // Therefore, calls to functions like onClick and onHover need to be done
      // at the end of the function. NO operation relies on the states of current
      // layers should be called after this two lines of code.
      switch (mode) {
        case 'click':
          handled = info.layer.props.onClick(info);break;
        case 'hover':
          handled = info.layer.props.onHover(info);break;
        default:
          throw new Error('unknown pick type');
      }

      if (!handled) {
        unhandledPickInfos.push(info);
      }
    });
  });

  return unhandledPickInfos;
}
/* eslint-enable max-depth, max-statements */

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJHTCIsImdsQ29udGV4dFdpdGhTdGF0ZSIsImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0IiwibG9nIiwiZ2V0QmxlbmRNb2RlIiwic2V0QmxlbmRNb2RlIiwiRU1QVFlfUElYRUwiLCJVaW50OEFycmF5IiwicmVuZGVyQ291bnQiLCJkcmF3TGF5ZXJzIiwibGF5ZXJzIiwicGFzcyIsImxlbmd0aCIsInZpc2libGVDb3VudCIsImZvckVhY2giLCJsYXllciIsImxheWVySW5kZXgiLCJwcm9wcyIsInZpc2libGUiLCJkcmF3TGF5ZXIiLCJ1bmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJwaWNraW5nRW5hYmxlZCIsImNvbnRleHQiLCJ2aWV3cG9ydCIsInBpY2tMYXllcnMiLCJnbCIsInBpY2tpbmdGQk8iLCJ4IiwieSIsIm1vZGUiLCJsYXN0UGlja2VkSW5mbyIsInBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiZGV2aWNlWCIsImRldmljZVkiLCJjYW52YXMiLCJoZWlnaHQiLCJ1bmhhbmRsZWRQaWNrSW5mb3MiLCJmcmFtZUJ1ZmZlciIsImZyYW1lYnVmZmVyIiwic2Npc3NvclRlc3QiLCJ3IiwiaCIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJvbGRCbGVuZE1vZGUiLCJlbmFibGUiLCJCTEVORCIsImJsZW5kRnVuY1NlcGFyYXRlIiwiT05FIiwiWkVSTyIsIkNPTlNUQU5UX0FMUEhBIiwiYmxlbmRFcXVhdGlvbiIsIkZVTkNfQUREIiwicGlja2FibGUiLCJibGVuZENvbG9yIiwicGlja2VkQ29sb3IiLCJyZWFkUGl4ZWxzIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJwaWNrZWRMYXllckluZGV4IiwicGlja2VkTGF5ZXIiLCJwaWNrZWRPYmplY3RJbmRleCIsImRlY29kZVBpY2tpbmdDb2xvciIsInBpY2tlZExheWVySWQiLCJpZCIsImFmZmVjdGVkTGF5ZXJzIiwibGFzdFBpY2tlZE9iamVjdEluZGV4IiwiaW5kZXgiLCJsYXN0UGlja2VkTGF5ZXJJZCIsImxheWVySWQiLCJsYXN0UGlja2VkTGF5ZXIiLCJmaW5kIiwibCIsInVuc2hpZnQiLCJiYXNlSW5mbyIsImNyZWF0ZUluZm8iLCJkZXZpY2VQaXhlbCIsImluZm9zIiwiTWFwIiwiaW5mbyIsImNvbG9yIiwicGlja2VkIiwic291cmNlTGF5ZXIiLCJwaWNrTGF5ZXIiLCJwYXJlbnRMYXllciIsInNldCIsImhhbmRsZWQiLCJvbkNsaWNrIiwib25Ib3ZlciIsIkVycm9yIiwicHVzaCIsInBpeGVsIiwibG5nTGF0IiwidW5wcm9qZWN0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFBLEVBQVIsRUFBWUMsa0JBQVosUUFBcUMsU0FBckM7QUFDQSxTQUFRQyx1QkFBUixRQUFzQyxxQkFBdEM7QUFDQSxTQUFRQyxHQUFSLEVBQWFDLFlBQWIsRUFBMkJDLFlBQTNCLFFBQThDLFNBQTlDOztBQUVBLElBQU1DLGNBQWMsSUFBSUMsVUFBSixDQUFlLENBQWYsQ0FBcEI7QUFDQSxJQUFJQyxjQUFjLENBQWxCOztBQUVBLE9BQU8sU0FBU0MsVUFBVCxPQUFvQztBQUFBLE1BQWZDLE1BQWUsUUFBZkEsTUFBZTtBQUFBLE1BQVBDLElBQU8sUUFBUEEsSUFBTzs7QUFDekNSLE1BQUlBLEdBQUosQ0FBUSxDQUFSLGVBQXNCTyxPQUFPRSxNQUE3Qjs7QUFFQTtBQUNBLE1BQUlDLGVBQWUsQ0FBbkI7QUFDQTtBQUNBSCxTQUFPSSxPQUFQLENBQWUsVUFBQ0MsS0FBRCxFQUFRQyxVQUFSLEVBQXVCO0FBQ3BDLFFBQUlELE1BQU1FLEtBQU4sQ0FBWUMsT0FBaEIsRUFBeUI7QUFDdkJILFlBQU1JLFNBQU4sQ0FBZ0I7QUFDZEMsa0JBQVVDLE9BQU9DLE1BQVAsQ0FDUixFQUFDQyxxQkFBcUIsQ0FBdEIsRUFBeUJDLGdCQUFnQixDQUF6QyxFQURRLEVBRVJULE1BQU1VLE9BQU4sQ0FBY0wsUUFGTixFQUdSbEIsd0JBQXdCYSxNQUFNVSxPQUFOLENBQWNDLFFBQXRDLEVBQWdEWCxNQUFNRSxLQUF0RCxDQUhRLEVBSVIsRUFBQ0Qsc0JBQUQsRUFKUTtBQURJLE9BQWhCO0FBUUFIO0FBQ0Q7QUFDRixHQVpEOztBQWNBVixNQUFJQSxHQUFKLENBQVEsQ0FBUixtQkFBMEJRLElBQTFCLFVBQW1DSCxhQUFuQyxjQUNJSyxZQURKLGtCQUM2QkgsT0FBT0UsTUFEcEM7QUFFRDs7QUFFRDtBQUNBLE9BQU8sU0FBU2UsVUFBVCxDQUFvQkMsRUFBcEIsU0FTSjtBQUFBLE1BUkRsQixNQVFDLFNBUkRBLE1BUUM7QUFBQSxNQVBEbUIsVUFPQyxTQVBEQSxVQU9DO0FBQUEsNkJBTkRULFFBTUM7QUFBQSxNQU5EQSxRQU1DLGtDQU5VLEVBTVY7QUFBQSxNQUxEVSxDQUtDLFNBTERBLENBS0M7QUFBQSxNQUpEQyxDQUlDLFNBSkRBLENBSUM7QUFBQSxNQUhETCxRQUdDLFNBSERBLFFBR0M7QUFBQSxNQUZETSxJQUVDLFNBRkRBLElBRUM7QUFBQSxNQUREQyxjQUNDLFNBRERBLGNBQ0M7OztBQUVEO0FBQ0E7QUFDQSxNQUFNQyxhQUFhLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsR0FDakJBLE9BQU9DLGdCQURVLEdBQ1MsQ0FENUI7QUFFQSxNQUFNQyxVQUFVUCxJQUFJSSxVQUFwQjtBQUNBLE1BQU1JLFVBQVVWLEdBQUdXLE1BQUgsQ0FBVUMsTUFBVixHQUFtQlQsSUFBSUcsVUFBdkM7O0FBRUE7QUFDQSxNQUFNTyxxQkFBcUIsRUFBM0I7O0FBRUE7QUFDQTtBQUNBeEMscUJBQW1CMkIsRUFBbkIsRUFBdUI7QUFDckJjLGlCQUFhYixVQURRO0FBRXJCYyxpQkFBYWQsVUFGUTtBQUdyQmUsaUJBQWEsRUFBQ2QsR0FBR08sT0FBSixFQUFhTixHQUFHTyxPQUFoQixFQUF5Qk8sR0FBRyxDQUE1QixFQUErQkMsR0FBRyxDQUFsQztBQUhRLEdBQXZCLEVBSUcsWUFBTTs7QUFFUDtBQUNBO0FBQ0FsQixPQUFHbUIsS0FBSCxDQUFTL0MsR0FBR2dELGdCQUFILEdBQXNCaEQsR0FBR2lELGdCQUFsQztBQUNBO0FBQ0EsUUFBTUMsZUFBZTlDLGFBQWF3QixFQUFiLENBQXJCO0FBQ0E7QUFDQTtBQUNBQSxPQUFHdUIsTUFBSCxDQUFVdkIsR0FBR3dCLEtBQWI7QUFDQXhCLE9BQUd5QixpQkFBSCxDQUFxQnpCLEdBQUcwQixHQUF4QixFQUE2QjFCLEdBQUcyQixJQUFoQyxFQUFzQzNCLEdBQUc0QixjQUF6QyxFQUF5RDVCLEdBQUcyQixJQUE1RDtBQUNBM0IsT0FBRzZCLGFBQUgsQ0FBaUI3QixHQUFHOEIsUUFBcEI7O0FBRUE7QUFDQWhELFdBQU9JLE9BQVAsQ0FBZSxVQUFDQyxLQUFELEVBQVFDLFVBQVIsRUFBdUI7QUFDcEMsVUFBSUQsTUFBTUUsS0FBTixDQUFZQyxPQUFaLElBQXVCSCxNQUFNRSxLQUFOLENBQVkwQyxRQUF2QyxFQUFpRDs7QUFFL0M7QUFDQS9CLFdBQUdnQyxVQUFILENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUFDNUMsYUFBYSxDQUFkLElBQW1CLEdBQTFDOztBQUVBRCxjQUFNSSxTQUFOLENBQWdCO0FBQ2RDLG9CQUFVQyxPQUFPQyxNQUFQLENBQ1IsRUFBQ0MscUJBQXFCLENBQXRCLEVBQXlCQyxnQkFBZ0IsQ0FBekMsRUFEUSxFQUVSVCxNQUFNVSxPQUFOLENBQWNMLFFBRk4sRUFHUmxCLHdCQUF3QmEsTUFBTVUsT0FBTixDQUFjQyxRQUF0QyxFQUFnRFgsTUFBTUUsS0FBdEQsQ0FIUSxFQUlSLEVBQUNELHNCQUFELEVBSlE7QUFESSxTQUFoQjtBQVFEO0FBQ0YsS0FmRDs7QUFpQkE7QUFDQSxRQUFNNkMsY0FBYyxJQUFJdEQsVUFBSixDQUFlLENBQWYsQ0FBcEI7QUFDQXFCLE9BQUdrQyxVQUFILENBQWN6QixPQUFkLEVBQXVCQyxPQUF2QixFQUFnQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQ3RDLEdBQUcrRCxJQUF6QyxFQUErQy9ELEdBQUdnRSxhQUFsRCxFQUFpRUgsV0FBakU7O0FBRUE7QUFDQXhELGlCQUFhdUIsRUFBYixFQUFpQnNCLFlBQWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU1lLG1CQUFtQkosWUFBWSxDQUFaLElBQWlCLENBQTFDO0FBQ0EsUUFBTUssY0FBY0Qsb0JBQW9CLENBQXBCLEdBQXdCdkQsT0FBT3VELGdCQUFQLENBQXhCLEdBQW1ELElBQXZFO0FBQ0EsUUFBTUUsb0JBQW9CRCxjQUFjQSxZQUFZRSxrQkFBWixDQUErQlAsV0FBL0IsQ0FBZCxHQUE0RCxDQUFDLENBQXZGO0FBQ0EsUUFBTVEsZ0JBQWdCSCxlQUFlQSxZQUFZakQsS0FBWixDQUFrQnFELEVBQXZEO0FBQ0EsUUFBTUMsaUJBQWlCTCxjQUFjLENBQUNBLFdBQUQsQ0FBZCxHQUE4QixFQUFyRDs7QUFFQSxRQUFJbEMsU0FBUyxPQUFiLEVBQXNCO0FBQ3BCO0FBQ0EsVUFBTXdDLHdCQUF3QnZDLGVBQWV3QyxLQUE3QztBQUNBLFVBQU1DLG9CQUFvQnpDLGVBQWUwQyxPQUF6Qzs7QUFFQSxVQUFJTixrQkFBa0JLLGlCQUFsQixJQUF1Q1Asc0JBQXNCSyxxQkFBakUsRUFBd0Y7QUFDdEY7QUFDQTtBQUNEOztBQUVELFVBQUlILGtCQUFrQkssaUJBQXRCLEVBQXlDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFlBQU1FLGtCQUFrQmxFLE9BQU9tRSxJQUFQLENBQVk7QUFBQSxpQkFBS0MsRUFBRTdELEtBQUYsQ0FBUXFELEVBQVIsS0FBZUksaUJBQXBCO0FBQUEsU0FBWixDQUF4QjtBQUNBLFlBQUlFLGVBQUosRUFBcUI7QUFDbkI7QUFDQUwseUJBQWVRLE9BQWYsQ0FBdUJILGVBQXZCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBM0MscUJBQWUwQyxPQUFmLEdBQXlCTixhQUF6QjtBQUNBcEMscUJBQWV3QyxLQUFmLEdBQXVCTixpQkFBdkI7QUFDRDs7QUFFRCxRQUFNYSxXQUFXQyxXQUFXLENBQUNuRCxDQUFELEVBQUlDLENBQUosQ0FBWCxFQUFtQkwsUUFBbkIsQ0FBakI7QUFDQXNELGFBQVNFLFdBQVQsR0FBdUIsQ0FBQzdDLE9BQUQsRUFBVUMsT0FBVixDQUF2QjtBQUNBMEMsYUFBUzlDLFVBQVQsR0FBc0JBLFVBQXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTWlELFFBQVEsSUFBSUMsR0FBSixFQUFkOztBQUVBYixtQkFBZXpELE9BQWYsQ0FBdUIsaUJBQVM7QUFDOUIsVUFBSXVFLE9BQU9oRSxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQjBELFFBQWxCLENBQVg7O0FBRUEsVUFBSWpFLFVBQVVtRCxXQUFkLEVBQTJCO0FBQ3pCbUIsYUFBS0MsS0FBTCxHQUFhekIsV0FBYjtBQUNBd0IsYUFBS1osS0FBTCxHQUFhTixpQkFBYjtBQUNBa0IsYUFBS0UsTUFBTCxHQUFjLElBQWQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsYUFBT3hFLFNBQVNzRSxJQUFoQixFQUFzQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQU1HLGNBQWNILEtBQUt0RSxLQUFMLElBQWNBLEtBQWxDO0FBQ0FzRSxhQUFLdEUsS0FBTCxHQUFhQSxLQUFiO0FBQ0E7QUFDQTtBQUNBO0FBQ0FzRSxlQUFPdEUsTUFBTTBFLFNBQU4sQ0FBZ0IsRUFBQ0osVUFBRCxFQUFPckQsVUFBUCxFQUFhd0Qsd0JBQWIsRUFBaEIsQ0FBUDtBQUNBekUsZ0JBQVFBLE1BQU0yRSxXQUFkO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQUlMLElBQUosRUFBVTtBQUNSRixjQUFNUSxHQUFOLENBQVVOLEtBQUt0RSxLQUFMLENBQVd1RCxFQUFyQixFQUF5QmUsSUFBekI7QUFDRDtBQUNGLEtBOUJEOztBQWdDQUYsVUFBTXJFLE9BQU4sQ0FBYyxnQkFBUTtBQUNwQixVQUFJOEUsVUFBVSxLQUFkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQVE1RCxJQUFSO0FBQ0EsYUFBSyxPQUFMO0FBQWM0RCxvQkFBVVAsS0FBS3RFLEtBQUwsQ0FBV0UsS0FBWCxDQUFpQjRFLE9BQWpCLENBQXlCUixJQUF6QixDQUFWLENBQTBDO0FBQ3hELGFBQUssT0FBTDtBQUFjTyxvQkFBVVAsS0FBS3RFLEtBQUwsQ0FBV0UsS0FBWCxDQUFpQjZFLE9BQWpCLENBQXlCVCxJQUF6QixDQUFWLENBQTBDO0FBQ3hEO0FBQVMsZ0JBQU0sSUFBSVUsS0FBSixDQUFVLG1CQUFWLENBQU47QUFIVDs7QUFNQSxVQUFJLENBQUNILE9BQUwsRUFBYztBQUNabkQsMkJBQW1CdUQsSUFBbkIsQ0FBd0JYLElBQXhCO0FBQ0Q7QUFDRixLQXJCRDtBQXNCRCxHQTdJRDs7QUErSUEsU0FBTzVDLGtCQUFQO0FBQ0Q7QUFDRDs7QUFFQSxTQUFTd0MsVUFBVCxDQUFvQmdCLEtBQXBCLEVBQTJCdkUsUUFBM0IsRUFBcUM7QUFDbkM7QUFDQSxTQUFPO0FBQ0w0RCxXQUFPaEYsV0FERjtBQUVMbUUsV0FBTyxDQUFDLENBRkg7QUFHTGMsWUFBUSxLQUhIO0FBSUx6RCxPQUFHbUUsTUFBTSxDQUFOLENBSkU7QUFLTGxFLE9BQUdrRSxNQUFNLENBQU4sQ0FMRTtBQU1MQSxnQkFOSztBQU9MQyxZQUFReEUsU0FBU3lFLFNBQVQsQ0FBbUJGLEtBQW5CO0FBUEgsR0FBUDtBQVNEIiwiZmlsZSI6ImRyYXctYW5kLXBpY2suanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtHTCwgZ2xDb250ZXh0V2l0aFN0YXRlfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7Z2V0VW5pZm9ybXNGcm9tVmlld3BvcnR9IGZyb20gJy4vdmlld3BvcnQtdW5pZm9ybXMnO1xuaW1wb3J0IHtsb2csIGdldEJsZW5kTW9kZSwgc2V0QmxlbmRNb2RlfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgRU1QVFlfUElYRUwgPSBuZXcgVWludDhBcnJheSg0KTtcbmxldCByZW5kZXJDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TGF5ZXJzKHtsYXllcnMsIHBhc3N9KSB7XG4gIGxvZy5sb2coMywgYERSQVdJTkcgJHtsYXllcnMubGVuZ3RofSBsYXllcnNgKTtcblxuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGV0IHZpc2libGVDb3VudCA9IDA7XG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsYXllcnMuZm9yRWFjaCgobGF5ZXIsIGxheWVySW5kZXgpID0+IHtcbiAgICBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSkge1xuICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDAsIHBpY2tpbmdFbmFibGVkOiAwfSxcbiAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICB7bGF5ZXJJbmRleH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICB2aXNpYmxlQ291bnQrKztcbiAgICB9XG4gIH0pO1xuXG4gIGxvZy5sb2coMywgYFJFTkRFUiBQQVNTICR7cGFzc306ICR7cmVuZGVyQ291bnQrK31cbiAgICAke3Zpc2libGVDb3VudH0gdmlzaWJsZSwgJHtsYXllcnMubGVuZ3RofSB0b3RhbGApO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5leHBvcnQgZnVuY3Rpb24gcGlja0xheWVycyhnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIHVuaWZvcm1zID0ge30sXG4gIHgsXG4gIHksXG4gIHZpZXdwb3J0LFxuICBtb2RlLFxuICBsYXN0UGlja2VkSW5mb1xufSkge1xuXG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIGNvbnN0IGRldmljZVggPSB4ICogcGl4ZWxSYXRpbztcbiAgY29uc3QgZGV2aWNlWSA9IGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbztcblxuICAvLyBUT0RPIC0ganVzdCByZXR1cm4gZ2xDb250ZXh0V2l0aFN0YXRlIG9uY2UgbHVtYSB1cGRhdGVzXG4gIGNvbnN0IHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciBzY2lzc29yIHRlc3QgYW5kIGZibyBiaW5kaW5ncyBpbiBjYXNlIG9mIGV4Y2VwdGlvbnNcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvbmUgcGl4ZWwsIG5vIG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nIGVsc2VcbiAgZ2xDb250ZXh0V2l0aFN0YXRlKGdsLCB7XG4gICAgZnJhbWVCdWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgZnJhbWVidWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgc2Npc3NvclRlc3Q6IHt4OiBkZXZpY2VYLCB5OiBkZXZpY2VZLCB3OiAxLCBoOiAxfVxuICB9LCAoKSA9PiB7XG5cbiAgICAvLyBQaWNraW5nIHByb2Nlc3Mgc3RhcnRcbiAgICAvLyBDbGVhciB0aGUgZnJhbWUgYnVmZmVyXG4gICAgZ2wuY2xlYXIoR0wuQ09MT1JfQlVGRkVSX0JJVCB8IEdMLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIC8vIFNhdmUgY3VycmVudCBibGVuZCBzZXR0aW5nc1xuICAgIGNvbnN0IG9sZEJsZW5kTW9kZSA9IGdldEJsZW5kTW9kZShnbCk7XG4gICAgLy8gU2V0IGJsZW5kIG1vZGUgZm9yIHBpY2tpbmdcbiAgICAvLyBhbHdheXMgb3ZlcndyaXRlIGV4aXN0aW5nIHBpeGVsIHdpdGggW3IsZyxiLGxheWVySW5kZXhdXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPKTtcbiAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcGlja2FibGUgbGF5ZXJzIGluIHBpY2tpbmcgY29sb3JzXG4gICAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgICBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSAmJiBsYXllci5wcm9wcy5waWNrYWJsZSkge1xuXG4gICAgICAgIC8vIEVuY29kZSBsYXllckluZGV4IHdpdGggYWxwaGFcbiAgICAgICAgZ2wuYmxlbmRDb2xvcigwLCAwLCAwLCAobGF5ZXJJbmRleCArIDEpIC8gMjU1KTtcblxuICAgICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDEsIHBpY2tpbmdFbmFibGVkOiAxfSxcbiAgICAgICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgICAgICBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksXG4gICAgICAgICAgICB7bGF5ZXJJbmRleH1cbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVhZCBjb2xvciBpbiB0aGUgY2VudHJhbCBwaXhlbCwgdG8gYmUgbWFwcGVkIHdpdGggcGlja2luZyBjb2xvcnNcbiAgICBjb25zdCBwaWNrZWRDb2xvciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoZGV2aWNlWCwgZGV2aWNlWSwgMSwgMSwgR0wuUkdCQSwgR0wuVU5TSUdORURfQllURSwgcGlja2VkQ29sb3IpO1xuXG4gICAgLy8gcmVzdG9yZSBibGVuZCBtb2RlXG4gICAgc2V0QmxlbmRNb2RlKGdsLCBvbGRCbGVuZE1vZGUpO1xuICAgIC8vIFBpY2tpbmcgcHJvY2VzcyBlbmRcblxuICAgIC8vIFByb2Nlc3MgcGlja2VkIGluZm8gc3RhcnRcbiAgICAvLyBEZWNvZGUgcGlja2VkIGNvbG9yXG4gICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yWzNdIC0gMTtcbiAgICBjb25zdCBwaWNrZWRMYXllciA9IHBpY2tlZExheWVySW5kZXggPj0gMCA/IGxheWVyc1twaWNrZWRMYXllckluZGV4XSA6IG51bGw7XG4gICAgY29uc3QgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllciA/IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcikgOiAtMTtcbiAgICBjb25zdCBwaWNrZWRMYXllcklkID0gcGlja2VkTGF5ZXIgJiYgcGlja2VkTGF5ZXIucHJvcHMuaWQ7XG4gICAgY29uc3QgYWZmZWN0ZWRMYXllcnMgPSBwaWNrZWRMYXllciA/IFtwaWNrZWRMYXllcl0gOiBbXTtcblxuICAgIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgICAvLyBvbmx5IGludm9rZSBvbkhvdmVyIGV2ZW50cyBpZiBwaWNrZWQgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAgICBjb25zdCBsYXN0UGlja2VkT2JqZWN0SW5kZXggPSBsYXN0UGlja2VkSW5mby5pbmRleDtcbiAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllcklkID0gbGFzdFBpY2tlZEluZm8ubGF5ZXJJZDtcblxuICAgICAgaWYgKHBpY2tlZExheWVySWQgPT09IGxhc3RQaWNrZWRMYXllcklkICYmIHBpY2tlZE9iamVjdEluZGV4ID09PSBsYXN0UGlja2VkT2JqZWN0SW5kZXgpIHtcbiAgICAgICAgLy8gcGlja2VkIG9iamVjdCBkaWQgbm90IGNoYW5nZSwgbm8gbmVlZCB0byBwcm9jZWVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBzdG9yZSBhIHJlZiB0byBsYXN0UGlja2VkTGF5ZXIgaW4gdGhlIGNvbnRleHQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgc3RhdGUgb2YgYW4gb3V0ZGF0ZWQgbGF5ZXIgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgIC8vIGFuZCB0aGUgcHJvcHMgbWF5IGhhdmUgY2hhbmdlZFxuICAgICAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXIgPSBsYXllcnMuZmluZChsID0+IGwucHJvcHMuaWQgPT09IGxhc3RQaWNrZWRMYXllcklkKTtcbiAgICAgICAgaWYgKGxhc3RQaWNrZWRMYXllcikge1xuICAgICAgICAgIC8vIExldCBsZWF2ZSBldmVudCBmaXJlIGJlZm9yZSBlbnRlciBldmVudFxuICAgICAgICAgIGFmZmVjdGVkTGF5ZXJzLnVuc2hpZnQobGFzdFBpY2tlZExheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbGF5ZXIgbWFuYWdlciBjb250ZXh0XG4gICAgICBsYXN0UGlja2VkSW5mby5sYXllcklkID0gcGlja2VkTGF5ZXJJZDtcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZUluZm8gPSBjcmVhdGVJbmZvKFt4LCB5XSwgdmlld3BvcnQpO1xuICAgIGJhc2VJbmZvLmRldmljZVBpeGVsID0gW2RldmljZVgsIGRldmljZVldO1xuICAgIGJhc2VJbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG4gICAgLy8gVXNlIGEgTWFwIHRvIHN0b3JlIGFsbCBwaWNraW5nIGluZm9zLlxuICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZvckVhY2ggbG9vcHMgYXJlIHRoZSByZXN1bHQgb2ZcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL2lzc3Vlcy80NDNcbiAgICAvLyBQbGVhc2UgYmUgdmVyeSBjYXJlZnVsIHdoZW4gY2hhbmdpbmcgdGhpcyBwYXR0ZXJuXG4gICAgY29uc3QgaW5mb3MgPSBuZXcgTWFwKCk7XG5cbiAgICBhZmZlY3RlZExheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGxldCBpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUluZm8pO1xuXG4gICAgICBpZiAobGF5ZXIgPT09IHBpY2tlZExheWVyKSB7XG4gICAgICAgIGluZm8uY29sb3IgPSBwaWNrZWRDb2xvcjtcbiAgICAgICAgaW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgICAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhbGsgdXAgdGhlIGNvbXBvc2l0ZSBjaGFpbiBhbmQgZmluZCB0aGUgb3duZXIgb2YgdGhlIGV2ZW50XG4gICAgICAvLyBzdWJsYXllcnMgYXJlIG5ldmVyIGRpcmVjdGx5IGV4cG9zZWQgdG8gdGhlIHVzZXJcbiAgICAgIHdoaWxlIChsYXllciAmJiBpbmZvKSB7XG4gICAgICAgIC8vIEZvciBhIGNvbXBvc2l0ZSBsYXllciwgc291cmNlTGF5ZXIgd2lsbCBwb2ludCB0byB0aGUgc3VibGF5ZXJcbiAgICAgICAgLy8gd2hlcmUgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbS5cbiAgICAgICAgLy8gSXQgcHJvdmlkZXMgYWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRlIGxheWVyJ3NcbiAgICAgICAgLy8gZ2V0UGlja2luZ0luZm8oKSBtZXRob2QgdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0XG4gICAgICAgIGNvbnN0IHNvdXJjZUxheWVyID0gaW5mby5sYXllciB8fCBsYXllcjtcbiAgICAgICAgaW5mby5sYXllciA9IGxheWVyO1xuICAgICAgICAvLyBsYXllci5waWNrTGF5ZXIoKSBmdW5jdGlvbiByZXF1aXJlcyBhIG5vbi1udWxsIGBgYGxheWVyLnN0YXRlYGBgXG4gICAgICAgIC8vIG9iamVjdCB0byBmdW50aW9uIHByb3Blcmx5LiBTbyB0aGUgbGF5ZXIgcmVmZXJlY2VkIGhlcmVcbiAgICAgICAgLy8gbXVzdCBiZSB0aGUgXCJjdXJyZW50XCIgbGF5ZXIsIG5vdCBhbiBcIm91dC1kYXRlZFwiIC8gXCJpbnZhbGlkYXRlZFwiIGxheWVyXG4gICAgICAgIGluZm8gPSBsYXllci5waWNrTGF5ZXIoe2luZm8sIG1vZGUsIHNvdXJjZUxheWVyfSk7XG4gICAgICAgIGxheWVyID0gbGF5ZXIucGFyZW50TGF5ZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZXJlIHdpbGwgYmUgb25seSBvbmUgY29weSBvZiBpbmZvIGZvclxuICAgICAgLy8gb25lIGNvbXBvc2l0ZSBsYXllclxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaW5mb3Muc2V0KGluZm8ubGF5ZXIuaWQsIGluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5mb3MuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAvLyBUaGUgb25DbGljayBhbmQgb25Ib3ZlciBmdW5jdGlvbnMgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAvLyBhbmQgb3V0IG9mIGNvbnRyb2wgYnkgZGVjay5nbC4gSXQncyB2ZXJ5IG11Y2ggcG9zc2libGUgdGhhdFxuICAgICAgLy8gdGhlIHVzZXIgY2FsbHMgUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgaW4gdGhlc2UgZnVuY3Rpb24sIHN1Y2ggYXNcbiAgICAgIC8vIFJlYWN0Q29tcG9uZW50LnNldFN0YXRlKCkuIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIHNvbWV0aW1lcyBpbmR1Y2VcbiAgICAgIC8vIGEgcmUtcmVuZGVyIGFuZCByZS1nZW5lcmF0aW9uIG9mIHByb3BzIG9mIGRlY2suZ2wgYW5kIGl0cyBsYXllcnMsXG4gICAgICAvLyB3aGljaCBpbnZhbGlkYXRlcyBhbGwgbGF5ZXJzIGN1cnJlbnRseSBwYXNzZWQgdG8gdGhpcyB2ZXJ5IGZ1bmN0aW9uLlxuXG4gICAgICAvLyBUaGVyZWZvcmUsIGNhbGxzIHRvIGZ1bmN0aW9ucyBsaWtlIG9uQ2xpY2sgYW5kIG9uSG92ZXIgbmVlZCB0byBiZSBkb25lXG4gICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbi4gTk8gb3BlcmF0aW9uIHJlbGllcyBvbiB0aGUgc3RhdGVzIG9mIGN1cnJlbnRcbiAgICAgIC8vIGxheWVycyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMgdHdvIGxpbmVzIG9mIGNvZGUuXG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgJ2NsaWNrJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25DbGljayhpbmZvKTsgYnJlYWs7XG4gICAgICBjYXNlICdob3Zlcic6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uSG92ZXIoaW5mbyk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBpY2sgdHlwZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgICAgdW5oYW5kbGVkUGlja0luZm9zLnB1c2goaW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB1bmhhbmRsZWRQaWNrSW5mb3M7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cblxuZnVuY3Rpb24gY3JlYXRlSW5mbyhwaXhlbCwgdmlld3BvcnQpIHtcbiAgLy8gQXNzaWduIGEgbnVtYmVyIG9mIHBvdGVudGlhbGx5IHVzZWZ1bCBwcm9wcyB0byB0aGUgXCJpbmZvXCIgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgY29sb3I6IEVNUFRZX1BJWEVMLFxuICAgIGluZGV4OiAtMSxcbiAgICBwaWNrZWQ6IGZhbHNlLFxuICAgIHg6IHBpeGVsWzBdLFxuICAgIHk6IHBpeGVsWzFdLFxuICAgIHBpeGVsLFxuICAgIGxuZ0xhdDogdmlld3BvcnQudW5wcm9qZWN0KHBpeGVsKVxuICB9O1xufVxuIl19