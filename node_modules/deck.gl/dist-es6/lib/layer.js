var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { COORDINATE_SYSTEM } from './constants';
import AttributeManager from './attribute-manager';
import { log, compareProps, count } from './utils';
import { GL } from 'luma.gl';
import assert from 'assert';

var LOG_PRIORITY_UPDATE = 2;

/*
 * @param {string} props.id - layer name
 * @param {array}  props.data - array of data instances
 * @param {bool} props.opacity - opacity of the layer
 */
var defaultProps = {
  dataComparator: null,
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: 0.8,
  onHover: function onHover() {},
  onClick: function onClick() {},
  // Update triggers: a key change detection mechanism in deck.gl
  // See layer documentation
  updateTriggers: {},
  projectionMode: COORDINATE_SYSTEM.LNGLAT
};

var counter = 0;

var Layer = function () {
  /**
   * @class
   * @param {object} props - See docs and defaults above
   */
  function Layer(props) {
    _classCallCheck(this, Layer);

    // If sublayer has static defaultProps member, getDefaultProps will return it
    var mergedDefaultProps = getDefaultProps(this);
    // Merge supplied props with pre-merged default props
    props = Object.assign({}, mergedDefaultProps, props);
    // Accept null as data - otherwise apps and layers need to add ugly checks
    props.data = props.data || [];
    // Props are immutable
    Object.freeze(props);

    // Define all members and freeze layer
    this.id = props.id;
    this.props = props;
    this.oldProps = null;
    this.state = null;
    this.context = null;
    this.parentLayer = null;
    this.count = counter++;
    this.lifecycle = 'Awaiting state';
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className !== this.props.id ? '<' + className + ':\'' + this.props.id + '\'>' : '<' + className + '>';
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          oldContext = _ref.oldContext,
          context = _ref.context,
          changeFlags = _ref.changeFlags;

      return changeFlags.somethingChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          oldContext = _ref2.oldContext,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;

      if (changeFlags.dataChanged) {
        this.invalidateAttribute('all');
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // Implement to generate sublayers

  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      return null;
    }

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var _ref3$uniforms = _ref3.uniforms,
          uniforms = _ref3$uniforms === undefined ? {} : _ref3$uniforms;

      if (this.state.model) {
        this.state.model.render(uniforms);
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref4) {
      var info = _ref4.info,
          mode = _ref4.mode;
      var color = info.color,
          index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      // TODO - move to the JS part of a shader picking shader package
      if (mode === 'hover') {
        var selectedPickingColor = new Float32Array(3);
        selectedPickingColor[0] = color[0];
        selectedPickingColor[1] = color[1];
        selectedPickingColor[2] = color[2];
        this.setUniforms({ selectedPickingColor: selectedPickingColor });
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Default implementation of attribute invalidation, can be redefine

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';

      if (name === 'all') {
        this.state.attributeManager.invalidateAll();
      } else {
        this.state.attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          model = _state.model;

      if (!attributeManager) {
        return;
      }

      var numInstances = this.getNumInstances(props);
      // Figure out data length
      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });
      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      return [(i + 1) % 256, Math.floor((i + 1) / 256) % 256, Math.floor((i + 1) / 256 / 256) % 256];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      assert(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref5) {
      var numInstances = _ref5.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return count(data);
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: 'initializeLayer',
    value: function initializeLayer(updateParams) {
      assert(this.context.gl, 'Layer context missing gl');
      assert(!this.state, 'Layer missing state');

      this.state = {};

      // Initialize state only once
      this.setState({
        attributeManager: new AttributeManager({ id: this.props.id }),
        model: null,
        needsRedraw: true,
        dataChanged: true
      });

      var attributeManager = this.state.attributeManager;
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slows down non instanced layers

      attributeManager.addInstanced({
        instancePickingColors: {
          type: GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      // Call subclass lifecycle methods
      this.initializeState();
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();

      var model = this.state.model;

      if (model) {
        model.setInstanceCount(this.getNumInstances());
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }
    }

    // Called by layer manager when existing layer is getting new props

  }, {
    key: 'updateLayer',
    value: function updateLayer(updateParams) {
      // Check for deprecated method
      if (this.shouldUpdate) {
        log.once(0, 'deck.gl v3 ' + this + ': "shouldUpdate" deprecated, renamed to "shouldUpdateState"');
      }

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.shouldUpdateState(updateParams);
      // End lifecycle method

      if (stateNeedsUpdate) {
        // Call subclass lifecycle method
        this.updateState(updateParams);
        // End lifecycle method

        // Run the attribute updaters
        this.updateAttributes(updateParams.props);
        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    }
    /* eslint-enable max-statements */

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: 'finalizeLayer',
    value: function finalizeLayer() {
      // Call subclass lifecycle method
      this.finalizeState();
      // End lifecycle method
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref6) {
      var _ref6$uniforms = _ref6.uniforms,
          uniforms = _ref6$uniforms === undefined ? {} : _ref6$uniforms;

      // Call subclass lifecycle method
      this.draw({ uniforms: uniforms });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }
  }, {
    key: 'diffProps',
    value: function diffProps(oldProps, newProps, context) {
      // First check if any props have changed (ignore props that will be examined separately)
      var propsChangedReason = compareProps({
        newProps: newProps,
        oldProps: oldProps,
        ignoreProps: { data: null, updateTriggers: null }
      });

      // Now check if any data related props have changed
      var dataChangedReason = this._diffDataProps(oldProps, newProps);

      var propsChanged = Boolean(propsChangedReason);
      var dataChanged = Boolean(dataChangedReason);
      var viewportChanged = context.viewportChanged;
      var somethingChanged = propsChanged || dataChanged || viewportChanged;

      // Check update triggers to determine if any attributes need regeneration
      // Note - if data has changed, all attributes will need regeneration, so skip this step
      if (!dataChanged) {
        this._diffUpdateTriggers(oldProps, newProps);
      } else {
        log.log(2, 'dataChanged: ' + dataChanged);
      }

      return {
        propsChanged: propsChanged,
        dataChanged: dataChanged,
        viewportChanged: viewportChanged,
        somethingChanged: somethingChanged,
        reason: dataChangedReason || propsChangedReason
      };
    }

    // Checks state of attributes and model
    // TODO - is attribute manager needed? - Model should be enough.

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,
          clearRedrawFlags = _ref7$clearRedrawFlag === undefined ? false : _ref7$clearRedrawFlag;

      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      var _state2 = this.state,
          attributeManager = _state2.attributeManager,
          model = _state2.model;

      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });

      return redraw;
    }

    // PRIVATE METHODS

    // The comparison of the data prop requires special handling
    // the dataComparator should be used if supplied

  }, {
    key: '_diffDataProps',
    value: function _diffDataProps(oldProps, newProps) {
      // Support optional app defined comparison of data
      var dataComparator = newProps.dataComparator;

      if (dataComparator) {
        if (!dataComparator(newProps.data, oldProps.data)) {
          return 'Data comparator detected a change';
        }
        // Otherwise, do a shallow equal on props
      } else if (newProps.data !== oldProps.data) {
        return 'A new data container was supplied';
      }

      return null;
    }

    // Checks if any update triggers have changed, and invalidate
    // attributes accordingly.
    /* eslint-disable max-statements */

  }, {
    key: '_diffUpdateTriggers',
    value: function _diffUpdateTriggers(oldProps, newProps) {
      // const {attributeManager} = this.state;
      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();

      var change = false;

      for (var propName in newProps.updateTriggers) {
        var oldTriggers = oldProps.updateTriggers[propName] || {};
        var newTriggers = newProps.updateTriggers[propName] || {};
        var diffReason = compareProps({
          oldProps: oldTriggers,
          newProps: newTriggers
        });
        if (diffReason) {
          if (propName === 'all') {
            log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
            this.invalidateAttribute('all');
            change = true;
          } else {
            log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);
            this.invalidateAttribute(propName);
            change = true;
          }
        }
      }

      return change;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }

    // Emits a warning if an old prop is used, optionally suggesting a replacement

  }, {
    key: '_checkRemovedProp',
    value: function _checkRemovedProp(oldProp) {
      var newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.props[oldProp] !== undefined) {
        var layerName = this.constructor;
        var message = layerName + ' no longer accepts props.' + oldProp + ' in this version of deck.gl.';
        if (newProp) {
          message += '\nPlease use props.' + newProp + ' instead.';
        }
        log.once(0, message);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      this.setUniforms({
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      });
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      if (this.state.model) {
        this.state.model.setUniforms(uniformMap);
      }
      // TODO - set needsRedraw on the model?
      this.state.needsRedraw = true;
      log(3, 'layer.setUniforms', uniformMap);
    }
  }]);

  return Layer;
}();

export default Layer;


Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;

// HELPERS

// Constructors have their super class constructors as prototypes
function getOwnProperty(object, prop) {
  return object.hasOwnProperty(prop) && object[prop];
}
/*
 * Return merged default props stored on layers constructor, create them if needed
 */
function getDefaultProps(layer) {
  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');
  if (mergedDefaultProps) {
    return mergedDefaultProps;
  }
  return mergeDefaultProps(layer);
}

/*
 * Walk the prototype chain and merge all default props
 */
function mergeDefaultProps(layer) {
  var subClassConstructor = layer.constructor;
  var layerName = getOwnProperty(subClassConstructor, 'layerName');
  if (!layerName) {
    log.once(0, 'layer ' + layer.constructor.name + ' does not specify a "layerName"');
  }
  var mergedDefaultProps = {
    id: layerName || layer.constructor.name
  };

  while (layer) {
    var layerDefaultProps = getOwnProperty(layer.constructor, 'defaultProps');
    Object.freeze(layerDefaultProps);
    if (layerDefaultProps) {
      mergedDefaultProps = Object.assign({}, layerDefaultProps, mergedDefaultProps);
    }
    layer = Object.getPrototypeOf(layer);
  }
  // Store for quick lookup
  subClassConstructor.mergedDefaultProps = mergedDefaultProps;
  return mergedDefaultProps;
}

export var TEST_EXPORTS = {
  mergeDefaultProps: mergeDefaultProps
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXIuanMiXSwibmFtZXMiOlsiQ09PUkRJTkFURV9TWVNURU0iLCJBdHRyaWJ1dGVNYW5hZ2VyIiwibG9nIiwiY29tcGFyZVByb3BzIiwiY291bnQiLCJHTCIsImFzc2VydCIsIkxPR19QUklPUklUWV9VUERBVEUiLCJkZWZhdWx0UHJvcHMiLCJkYXRhQ29tcGFyYXRvciIsIm51bUluc3RhbmNlcyIsInVuZGVmaW5lZCIsInZpc2libGUiLCJwaWNrYWJsZSIsIm9wYWNpdHkiLCJvbkhvdmVyIiwib25DbGljayIsInVwZGF0ZVRyaWdnZXJzIiwicHJvamVjdGlvbk1vZGUiLCJMTkdMQVQiLCJjb3VudGVyIiwiTGF5ZXIiLCJwcm9wcyIsIm1lcmdlZERlZmF1bHRQcm9wcyIsImdldERlZmF1bHRQcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsImRhdGEiLCJmcmVlemUiLCJpZCIsIm9sZFByb3BzIiwic3RhdGUiLCJjb250ZXh0IiwicGFyZW50TGF5ZXIiLCJsaWZlY3ljbGUiLCJzZWFsIiwiY2xhc3NOYW1lIiwiY29uc3RydWN0b3IiLCJsYXllck5hbWUiLCJuYW1lIiwiRXJyb3IiLCJvbGRDb250ZXh0IiwiY2hhbmdlRmxhZ3MiLCJzb21ldGhpbmdDaGFuZ2VkIiwiZGF0YUNoYW5nZWQiLCJpbnZhbGlkYXRlQXR0cmlidXRlIiwidW5pZm9ybXMiLCJtb2RlbCIsInJlbmRlciIsImluZm8iLCJtb2RlIiwiY29sb3IiLCJpbmRleCIsIkFycmF5IiwiaXNBcnJheSIsIm9iamVjdCIsInNlbGVjdGVkUGlja2luZ0NvbG9yIiwiRmxvYXQzMkFycmF5Iiwic2V0VW5pZm9ybXMiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiaW52YWxpZGF0ZUFsbCIsImludmFsaWRhdGUiLCJnZXROdW1JbnN0YW5jZXMiLCJ1cGRhdGUiLCJidWZmZXJzIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImdldENoYW5nZWRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJzZXRBdHRyaWJ1dGVzIiwidXBkYXRlT2JqZWN0IiwibmVlZHNSZWRyYXciLCJyZWRyYXciLCJsbmdMYXQiLCJ2aWV3cG9ydCIsInByb2plY3QiLCJ4eSIsInVucHJvamVjdCIsInByb2plY3RGbGF0IiwidW5wcm9qZWN0RmxhdCIsInNjcmVlblBpeGVscyIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJpIiwiTWF0aCIsImZsb29yIiwiVWludDhBcnJheSIsImkxIiwiaTIiLCJpMyIsImF0dHJpYnV0ZSIsInZhbHVlIiwic2l6ZSIsInBpY2tpbmdDb2xvciIsImVuY29kZVBpY2tpbmdDb2xvciIsInVwZGF0ZVBhcmFtcyIsImdsIiwic2V0U3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyIsImluaXRpYWxpemVTdGF0ZSIsInVwZGF0ZVN0YXRlIiwidXBkYXRlQXR0cmlidXRlcyIsIl91cGRhdGVCYXNlVW5pZm9ybXMiLCJzZXRJbnN0YW5jZUNvdW50IiwicHJvZ3JhbSIsImdlb21ldHJ5IiwiZ2V0QXR0cmlidXRlcyIsInNob3VsZFVwZGF0ZSIsIm9uY2UiLCJzdGF0ZU5lZWRzVXBkYXRlIiwic2hvdWxkVXBkYXRlU3RhdGUiLCJmaW5hbGl6ZVN0YXRlIiwiZHJhdyIsIm9wdHMiLCJnZXRQaWNraW5nSW5mbyIsIm5ld1Byb3BzIiwicHJvcHNDaGFuZ2VkUmVhc29uIiwiaWdub3JlUHJvcHMiLCJkYXRhQ2hhbmdlZFJlYXNvbiIsIl9kaWZmRGF0YVByb3BzIiwicHJvcHNDaGFuZ2VkIiwiQm9vbGVhbiIsInZpZXdwb3J0Q2hhbmdlZCIsIl9kaWZmVXBkYXRlVHJpZ2dlcnMiLCJyZWFzb24iLCJjbGVhclJlZHJhd0ZsYWdzIiwiZ2V0TmVlZHNSZWRyYXciLCJjaGFuZ2UiLCJwcm9wTmFtZSIsIm9sZFRyaWdnZXJzIiwibmV3VHJpZ2dlcnMiLCJkaWZmUmVhc29uIiwicHJvcGVydHlOYW1lIiwiY29uZGl0aW9uIiwib2xkUHJvcCIsIm5ld1Byb3AiLCJtZXNzYWdlIiwicG93IiwiT05FIiwidW5pZm9ybU1hcCIsImdldE93blByb3BlcnR5IiwicHJvcCIsImhhc093blByb3BlcnR5IiwibGF5ZXIiLCJtZXJnZURlZmF1bHRQcm9wcyIsInN1YkNsYXNzQ29uc3RydWN0b3IiLCJsYXllckRlZmF1bHRQcm9wcyIsImdldFByb3RvdHlwZU9mIiwiVEVTVF9FWFBPUlRTIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFBLGlCQUFSLFFBQWdDLGFBQWhDO0FBQ0EsT0FBT0MsZ0JBQVAsTUFBNkIscUJBQTdCO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxZQUFiLEVBQTJCQyxLQUEzQixRQUF1QyxTQUF2QztBQUNBLFNBQVFDLEVBQVIsUUFBaUIsU0FBakI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLHNCQUFzQixDQUE1Qjs7QUFFQTs7Ozs7QUFLQSxJQUFNQyxlQUFlO0FBQ25CQyxrQkFBZ0IsSUFERztBQUVuQkMsZ0JBQWNDLFNBRks7QUFHbkJDLFdBQVMsSUFIVTtBQUluQkMsWUFBVSxLQUpTO0FBS25CQyxXQUFTLEdBTFU7QUFNbkJDLFdBQVMsbUJBQU0sQ0FBRSxDQU5FO0FBT25CQyxXQUFTLG1CQUFNLENBQUUsQ0FQRTtBQVFuQjtBQUNBO0FBQ0FDLGtCQUFnQixFQVZHO0FBV25CQyxrQkFBZ0JsQixrQkFBa0JtQjtBQVhmLENBQXJCOztBQWNBLElBQUlDLFVBQVUsQ0FBZDs7SUFFcUJDLEs7QUFDbkI7Ozs7QUFJQSxpQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUNqQjtBQUNBLFFBQU1DLHFCQUFxQkMsZ0JB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Q3JCL0gsMkJBQXFCRSxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQjRILGlCQUFsQixFQUFxQy9ILGtCQUFyQyxDQUFyQjtBQUNEO0FBQ0Q0SCxZQUFRMUgsT0FBTzhILGNBQVAsQ0FBc0JKLEtBQXRCLENBQVI7QUFDRDtBQUNEO0FBQ0FFLHNCQUFvQjlILGtCQUFwQixHQUF5Q0Esa0JBQXpDO0FBQ0EsU0FBT0Esa0JBQVA7QUFDRDs7QUFFRCxPQUFPLElBQU1pSSxlQUFlO0FBQzFCSjtBQUQwQixDQUFyQiIsImZpbGUiOiJsYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgQXR0cmlidXRlTWFuYWdlciBmcm9tICcuL2F0dHJpYnV0ZS1tYW5hZ2VyJztcbmltcG9ydCB7bG9nLCBjb21wYXJlUHJvcHMsIGNvdW50fSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7R0x9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBMT0dfUFJJT1JJVFlfVVBEQVRFID0gMjtcblxuLypcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5pZCAtIGxheWVyIG5hbWVcbiAqIEBwYXJhbSB7YXJyYXl9ICBwcm9wcy5kYXRhIC0gYXJyYXkgb2YgZGF0YSBpbnN0YW5jZXNcbiAqIEBwYXJhbSB7Ym9vbH0gcHJvcHMub3BhY2l0eSAtIG9wYWNpdHkgb2YgdGhlIGxheWVyXG4gKi9cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZGF0YUNvbXBhcmF0b3I6IG51bGwsXG4gIG51bUluc3RhbmNlczogdW5kZWZpbmVkLFxuICB2aXNpYmxlOiB0cnVlLFxuICBwaWNrYWJsZTogZmFsc2UsXG4gIG9wYWNpdHk6IDAuOCxcbiAgb25Ib3ZlcjogKCkgPT4ge30sXG4gIG9uQ2xpY2s6ICgpID0+IHt9LFxuICAvLyBVcGRhdGUgdHJpZ2dlcnM6IGEga2V5IGNoYW5nZSBkZXRlY3Rpb24gbWVjaGFuaXNtIGluIGRlY2suZ2xcbiAgLy8gU2VlIGxheWVyIGRvY3VtZW50YXRpb25cbiAgdXBkYXRlVHJpZ2dlcnM6IHt9LFxuICBwcm9qZWN0aW9uTW9kZTogQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUXG59O1xuXG5sZXQgY291bnRlciA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBTZWUgZG9jcyBhbmQgZGVmYXVsdHMgYWJvdmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgLy8gSWYgc3VibGF5ZXIgaGFzIHN0YXRpYyBkZWZhdWx0UHJvcHMgbWVtYmVyLCBnZXREZWZhdWx0UHJvcHMgd2lsbCByZXR1cm4gaXRcbiAgICBjb25zdCBtZXJnZWREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHModGhpcyk7XG4gICAgLy8gTWVyZ2Ugc3VwcGxpZWQgcHJvcHMgd2l0aCBwcmUtbWVyZ2VkIGRlZmF1bHQgcHJvcHNcbiAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1lcmdlZERlZmF1bHRQcm9wcywgcHJvcHMpO1xuICAgIC8vIEFjY2VwdCBudWxsIGFzIGRhdGEgLSBvdGhlcndpc2UgYXBwcyBhbmQgbGF5ZXJzIG5lZWQgdG8gYWRkIHVnbHkgY2hlY2tzXG4gICAgcHJvcHMuZGF0YSA9IHByb3BzLmRhdGEgfHwgW107XG4gICAgLy8gUHJvcHMgYXJlIGltbXV0YWJsZVxuICAgIE9iamVjdC5mcmVlemUocHJvcHMpO1xuXG4gICAgLy8gRGVmaW5lIGFsbCBtZW1iZXJzIGFuZCBmcmVlemUgbGF5ZXJcbiAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMub2xkUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnRMYXllciA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKztcbiAgICB0aGlzLmxpZmVjeWNsZSA9ICdBd2FpdGluZyBzdGF0ZSc7XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmxheWVyTmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIGNsYXNzTmFtZSAhPT0gdGhpcy5wcm9wcy5pZCA/IGA8JHtjbGFzc05hbWV9Oicke3RoaXMucHJvcHMuaWR9Jz5gIDogYDwke2NsYXNzTmFtZX0+YDtcbiAgfVxuXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIExJRkVDWUNMRSBNRVRIT0RTLCBvdmVycmlkZGVuIGJ5IHRoZSBsYXllciBzdWJjbGFzc2VzXG5cbiAgLy8gQ2FsbGVkIG9uY2UgdG8gc2V0IHVwIHRoZSBpbml0aWFsIHN0YXRlXG4gIC8vIEFwcCBjYW4gY3JlYXRlIFdlYkdMIHJlc291cmNlc1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciAke3RoaXN9IGhhcyBub3QgZGVmaW5lZCBpbml0aWFsaXplU3RhdGVgKTtcbiAgfVxuXG4gIC8vIExldCdzIGxheWVyIGNvbnRyb2wgaWYgdXBkYXRlU3RhdGUgc2hvdWxkIGJlIGNhbGxlZFxuICBzaG91bGRVcGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBvbGRDb250ZXh0LCBjb250ZXh0LCBjaGFuZ2VGbGFnc30pIHtcbiAgICByZXR1cm4gY2hhbmdlRmxhZ3Muc29tZXRoaW5nQ2hhbmdlZDtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24sIGFsbCBhdHRyaWJ1dGVzIHdpbGwgYmUgaW52YWxpZGF0ZWQgYW5kIHVwZGF0ZWRcbiAgLy8gd2hlbiBkYXRhIGNoYW5nZXNcbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVBdHRyaWJ1dGUoJ2FsbCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBvbmNlIHdoZW4gbGF5ZXIgaXMgbm8gbG9uZ2VyIG1hdGNoZWQgYW5kIHN0YXRlIHdpbGwgYmUgZGlzY2FyZGVkXG4gIC8vIEFwcCBjYW4gZGVzdHJveSBXZWJHTCByZXNvdXJjZXMgaGVyZVxuICBmaW5hbGl6ZVN0YXRlKCkge1xuICB9XG5cbiAgLy8gSW1wbGVtZW50IHRvIGdlbmVyYXRlIHN1YmxheWVyc1xuICByZW5kZXJMYXllcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiBzdGF0ZSBoYXMgYSBtb2RlbCwgZHJhdyBpdCB3aXRoIHN1cHBsaWVkIHVuaWZvcm1zXG4gIGRyYXcoe3VuaWZvcm1zID0ge319KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxsZWQgdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0IHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBldmVudCBoYW5kbGVyXG4gIC8vIEByZXR1cm4gbnVsbCB0byBjYW5jZWwgZXZlbnRcbiAgZ2V0UGlja2luZ0luZm8oe2luZm8sIG1vZGV9KSB7XG4gICAgY29uc3Qge2NvbG9yLCBpbmRleH0gPSBpbmZvO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIC8vIElmIHByb3BzLmRhdGEgaXMgYW4gaW5kZXhhYmxlIGFycmF5LCBnZXQgdGhlIG9iamVjdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5kYXRhKSkge1xuICAgICAgICBpbmZvLm9iamVjdCA9IHRoaXMucHJvcHMuZGF0YVtpbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIG1vdmUgdG8gdGhlIEpTIHBhcnQgb2YgYSBzaGFkZXIgcGlja2luZyBzaGFkZXIgcGFja2FnZVxuICAgIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFBpY2tpbmdDb2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclswXSA9IGNvbG9yWzBdO1xuICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMV0gPSBjb2xvclsxXTtcbiAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzJdID0gY29sb3JbMl07XG4gICAgICB0aGlzLnNldFVuaWZvcm1zKHtzZWxlY3RlZFBpY2tpbmdDb2xvcn0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgLy8gRU5EIExJRkVDWUNMRSBNRVRIT0RTXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBhdHRyaWJ1dGUgaW52YWxpZGF0aW9uLCBjYW4gYmUgcmVkZWZpbmVcbiAgaW52YWxpZGF0ZUF0dHJpYnV0ZShuYW1lID0gJ2FsbCcpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxzIGF0dHJpYnV0ZSBtYW5hZ2VyIHRvIHVwZGF0ZSBhbnkgV2ViR0wgYXR0cmlidXRlcywgY2FuIGJlIHJlZGVmaW5lZFxuICB1cGRhdGVBdHRyaWJ1dGVzKHByb3BzKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbnVtSW5zdGFuY2VzID0gdGhpcy5nZXROdW1JbnN0YW5jZXMocHJvcHMpO1xuICAgIC8vIEZpZ3VyZSBvdXQgZGF0YSBsZW5ndGhcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSh7XG4gICAgICBkYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgcHJvcHMsXG4gICAgICBidWZmZXJzOiBwcm9wcyxcbiAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAvLyBEb24ndCB3b3JyeSBhYm91dCBub24tYXR0cmlidXRlIHByb3BzXG4gICAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVNYW5hZ2VyLmdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFnczogdHJ1ZX0pO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVibGljIEFQSVxuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFN0YXRlKHVwZGF0ZU9iamVjdCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgdXBkYXRlT2JqZWN0KTtcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxuXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSkge1xuICAgICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHJlZHJhdztcbiAgICB9XG4gIH1cblxuICAvLyBQUk9KRUNUSU9OIE1FVEhPRFNcblxuICAvKipcbiAgICogUHJvamVjdHMgYSBwb2ludCB3aXRoIGN1cnJlbnQgbWFwIHN0YXRlIChsYXQsIGxvbiwgem9vbSwgcGl0Y2gsIGJlYXJpbmcpXG4gICAqXG4gICAqIE5vdGU6IFBvc2l0aW9uIGNvbnZlcnNpb24gaXMgZG9uZSBpbiBzaGFkZXIsIHNvIGluIG1hbnkgY2FzZXMgdGhlcmUgaXMgbm8gbmVlZFxuICAgKiBmb3IgdGhpcyBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGxuZ0xhdCAtIGxvbmcgYW5kIGxhdCB2YWx1ZXNcbiAgICogQHJldHVybiB7QXJyYXl8VHlwZWRBcnJheX0gLSB4LCB5IGNvb3JkaW5hdGVzXG4gICAqL1xuICBwcm9qZWN0KGxuZ0xhdCkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkobG5nTGF0KSwgJ0xheWVyLnByb2plY3QgbmVlZHMgW2xuZyxsYXRdJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3QobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdCh4eSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnVucHJvamVjdCh4eSk7XG4gIH1cblxuICBwcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0RmxhdChsbmdMYXQpO1xuICB9XG5cbiAgdW5wcm9qZWN0RmxhdCh4eSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnVucHJvamVjdEZsYXQoeHkpO1xuICB9XG5cbiAgc2NyZWVuVG9EZXZpY2VQaXhlbHMoc2NyZWVuUGl4ZWxzKSB7XG4gICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICByZXR1cm4gc2NyZWVuUGl4ZWxzICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIGEgYmxhY2sgY29sb3JcbiAgICovXG4gIG51bGxQaWNraW5nQ29sb3IoKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEBwYXJhbSB7aW50fSBpIC0gaW5kZXggdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBjb2xvclxuICAgKi9cbiAgZW5jb2RlUGlja2luZ0NvbG9yKGkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgKGkgKyAxKSAlIDI1NixcbiAgICAgIE1hdGguZmxvb3IoKGkgKyAxKSAvIDI1NikgJSAyNTYsXG4gICAgICBNYXRoLmZsb29yKChpICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gY29sb3IgLSBjb2xvciBhcnJheSB0byBiZSBkZWNvZGVkXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIHRoZSBkZWNvZGVkIHBpY2tpbmcgY29sb3JcbiAgICovXG4gIGRlY29kZVBpY2tpbmdDb2xvcihjb2xvcikge1xuICAgIGFzc2VydChjb2xvciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgIGNvbnN0IFtpMSwgaTIsIGkzXSA9IGNvbG9yO1xuICAgIC8vIDEgd2FzIGFkZGVkIHRvIHNlcGVyYXRlIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgY29uc3QgaW5kZXggPSBpMSArIGkyICogMjU2ICsgaTMgKiA2NTUzNiAtIDE7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSwge251bUluc3RhbmNlc30pIHtcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIC8vIGFkZCAxIHRvIGluZGV4IHRvIHNlcGVyYXRlIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbnN0YW5jZXM7IGkrKykge1xuICAgICAgY29uc3QgcGlja2luZ0NvbG9yID0gdGhpcy5lbmNvZGVQaWNraW5nQ29sb3IoaSk7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDBdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAxXSA9IHBpY2tpbmdDb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMl0gPSBwaWNraW5nQ29sb3JbMl07XG4gICAgfVxuICB9XG5cbiAgLy8gREFUQSBBQ0NFU1MgQVBJXG4gIC8vIERhdGEgY2FuIHVzZSBpdGVyYXRvcnMgYW5kIG1heSBub3QgYmUgcmFuZG9tIGFjY2Vzc1xuXG4gIC8vIFVzZSBpdGVyYXRpb24gKHRoZSBvbmx5IHJlcXVpcmVkIGNhcGFiaWxpdHkgb24gZGF0YSkgdG8gZ2V0IGZpcnN0IGVsZW1lbnRcbiAgZ2V0Rmlyc3RPYmplY3QoKSB7XG4gICAgY29uc3Qge2RhdGF9ID0gdGhpcy5wcm9wcztcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICAvLyBEZWR1Y2VzIG51bWVyIG9mIGluc3RhbmNlcy4gSW50ZW50aW9uIGlzIHRvIHN1cHBvcnQ6XG4gIC8vIC0gRXhwbGljaXQgc2V0dGluZyBvZiBudW1JbnN0YW5jZXNcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgRVM2IGNvbnRhaW5lcnMgdGhhdCBkZWZpbmUgYSBzaXplIG1lbWJlclxuICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBDbGFzc2ljIEFycmF5cyB2aWEgdGhlIGJ1aWx0LWluIGxlbmd0aCBhdHRyaWJ1dGVcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiB2aWEgYXJyYXlzXG4gIGdldE51bUluc3RhbmNlcyhwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwgdGhpcy5wcm9wcztcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBsYXllciBoYXMgc2V0IGl0cyBvd24gdmFsdWVcbiAgICBpZiAodGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYXBwIGhhcyBwcm92aWRlZCBhbiBleHBsaWNpdCB2YWx1ZVxuICAgIGlmIChwcm9wcy5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb3BzLm51bUluc3RhbmNlcztcbiAgICB9XG5cbiAgICAvLyBVc2UgY29udGFpbmVyIGxpYnJhcnkgdG8gZ2V0IGEgY291bnQgZm9yIGFueSBFUzYgY29udGFpbmVyIG9yIG9iamVjdFxuICAgIGNvbnN0IHtkYXRhfSA9IHByb3BzO1xuICAgIHJldHVybiBjb3VudChkYXRhKTtcbiAgfVxuXG4gIC8vIExBWUVSIE1BTkFHRVIgQVBJXG4gIC8vIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSB0aGUgZGVjay5nbCBMYXllck1hbmFnZXIgY2xhc3NcblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGEgbmV3IGxheWVyIGlzIGZvdW5kXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIGluaXRpYWxpemVMYXllcih1cGRhdGVQYXJhbXMpIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LmdsLCAnTGF5ZXIgY29udGV4dCBtaXNzaW5nIGdsJyk7XG4gICAgYXNzZXJ0KCF0aGlzLnN0YXRlLCAnTGF5ZXIgbWlzc2luZyBzdGF0ZScpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzdGF0ZSBvbmx5IG9uY2VcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXI6IG5ldyBBdHRyaWJ1dGVNYW5hZ2VyKHtpZDogdGhpcy5wcm9wcy5pZH0pLFxuICAgICAgbW9kZWw6IG51bGwsXG4gICAgICBuZWVkc1JlZHJhdzogdHJ1ZSxcbiAgICAgIGRhdGFDaGFuZ2VkOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIEFsbCBpbnN0YW5jZWQgbGF5ZXJzIGdldCBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgYXR0cmlidXRlIGJ5IGRlZmF1bHRcbiAgICAvLyBUaGVpciBzaGFkZXJzIGNhbiB1c2UgaXQgdG8gcmVuZGVyIGEgcGlja2luZyBzY2VuZVxuICAgIC8vIFRPRE8gLSB0aGlzIHNsb3dzIGRvd24gbm9uIGluc3RhbmNlZCBsYXllcnNcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIC8vIEVuZCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuXG4gICAgLy8gQWRkIGFueSBzdWJjbGFzcyBhdHRyaWJ1dGVzXG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVzKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuXG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgbW9kZWwuaWQgPSB0aGlzLnByb3BzLmlkO1xuICAgICAgbW9kZWwucHJvZ3JhbS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LXByb2dyYW1gO1xuICAgICAgbW9kZWwuZ2VvbWV0cnkuaWQgPSBgJHt0aGlzLnByb3BzLmlkfS1nZW9tZXRyeWA7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZU1hbmFnZXIuZ2V0QXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGV4aXN0aW5nIGxheWVyIGlzIGdldHRpbmcgbmV3IHByb3BzXG4gIHVwZGF0ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIC8vIENoZWNrIGZvciBkZXByZWNhdGVkIG1ldGhvZFxuICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgdjMgJHt0aGlzfTogXCJzaG91bGRVcGRhdGVcIiBkZXByZWNhdGVkLCByZW5hbWVkIHRvIFwic2hvdWxkVXBkYXRlU3RhdGVcImApO1xuICAgIH1cblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIGNvbnN0IHN0YXRlTmVlZHNVcGRhdGUgPSB0aGlzLnNob3VsZFVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgIGlmIChzdGF0ZU5lZWRzVXBkYXRlKSB7XG4gICAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICAgIC8vIFJ1biB0aGUgYXR0cmlidXRlIHVwZGF0ZXJzXG4gICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModXBkYXRlUGFyYW1zLnByb3BzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvLyBDYWxsZWQgYnkgbWFuYWdlciB3aGVuIGxheWVyIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkXG4gIC8vIE5vdGU6IG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBvbiBhcHBsaWNhdGlvbiBzaHV0ZG93blxuICBmaW5hbGl6ZUxheWVyKCkge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHRoaXMuZmluYWxpemVTdGF0ZSgpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHVuaWZvcm1zXG4gIGRyYXdMYXllcih7dW5pZm9ybXMgPSB7fX0pIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmRyYXcoe3VuaWZvcm1zfSk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIHt1bmlmb3JtcyA9IHt9LCAuLi5vcHRzfVxuICBwaWNrTGF5ZXIob3B0cykge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJldHVybiB0aGlzLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICBkaWZmUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgYW55IHByb3BzIGhhdmUgY2hhbmdlZCAoaWdub3JlIHByb3BzIHRoYXQgd2lsbCBiZSBleGFtaW5lZCBzZXBhcmF0ZWx5KVxuICAgIGNvbnN0IHByb3BzQ2hhbmdlZFJlYXNvbiA9IGNvbXBhcmVQcm9wcyh7XG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFByb3BzLFxuICAgICAgaWdub3JlUHJvcHM6IHtkYXRhOiBudWxsLCB1cGRhdGVUcmlnZ2VyczogbnVsbH1cbiAgICB9KTtcblxuICAgIC8vIE5vdyBjaGVjayBpZiBhbnkgZGF0YSByZWxhdGVkIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgIGNvbnN0IGRhdGFDaGFuZ2VkUmVhc29uID0gdGhpcy5fZGlmZkRhdGFQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMpO1xuXG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gQm9vbGVhbihwcm9wc0NoYW5nZWRSZWFzb24pO1xuICAgIGNvbnN0IGRhdGFDaGFuZ2VkID0gQm9vbGVhbihkYXRhQ2hhbmdlZFJlYXNvbik7XG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gY29udGV4dC52aWV3cG9ydENoYW5nZWQ7XG4gICAgY29uc3Qgc29tZXRoaW5nQ2hhbmdlZCA9IHByb3BzQ2hhbmdlZCB8fCBkYXRhQ2hhbmdlZCB8fCB2aWV3cG9ydENoYW5nZWQ7XG5cbiAgICAvLyBDaGVjayB1cGRhdGUgdHJpZ2dlcnMgdG8gZGV0ZXJtaW5lIGlmIGFueSBhdHRyaWJ1dGVzIG5lZWQgcmVnZW5lcmF0aW9uXG4gICAgLy8gTm90ZSAtIGlmIGRhdGEgaGFzIGNoYW5nZWQsIGFsbCBhdHRyaWJ1dGVzIHdpbGwgbmVlZCByZWdlbmVyYXRpb24sIHNvIHNraXAgdGhpcyBzdGVwXG4gICAgaWYgKCFkYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5sb2coMiwgYGRhdGFDaGFuZ2VkOiAke2RhdGFDaGFuZ2VkfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwcm9wc0NoYW5nZWQsXG4gICAgICBkYXRhQ2hhbmdlZCxcbiAgICAgIHZpZXdwb3J0Q2hhbmdlZCxcbiAgICAgIHNvbWV0aGluZ0NoYW5nZWQsXG4gICAgICByZWFzb246IGRhdGFDaGFuZ2VkUmVhc29uIHx8IHByb3BzQ2hhbmdlZFJlYXNvblxuICAgIH07XG4gIH1cblxuICAvLyBDaGVja3Mgc3RhdGUgb2YgYXR0cmlidXRlcyBhbmQgbW9kZWxcbiAgLy8gVE9ETyAtIGlzIGF0dHJpYnV0ZSBtYW5hZ2VyIG5lZWRlZD8gLSBNb2RlbCBzaG91bGQgYmUgZW5vdWdoLlxuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgLy8gdGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBieSB0aGUgcmVuZGVyIGxvb3AgYXMgc29vbiBhIHRoZSBsYXllclxuICAgIC8vIGhhcyBiZWVuIGNyZWF0ZWQsIHNvIGd1YXJkIGFnYWluc3QgdW5pbml0aWFsaXplZCBzdGF0ZVxuICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdztcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCAoYXR0cmlidXRlTWFuYWdlciAmJiBhdHRyaWJ1dGVNYW5hZ2VyLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSkpO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCAobW9kZWwgJiYgbW9kZWwuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KSk7XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gVGhlIGNvbXBhcmlzb24gb2YgdGhlIGRhdGEgcHJvcCByZXF1aXJlcyBzcGVjaWFsIGhhbmRsaW5nXG4gIC8vIHRoZSBkYXRhQ29tcGFyYXRvciBzaG91bGQgYmUgdXNlZCBpZiBzdXBwbGllZFxuICBfZGlmZkRhdGFQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBTdXBwb3J0IG9wdGlvbmFsIGFwcCBkZWZpbmVkIGNvbXBhcmlzb24gb2YgZGF0YVxuICAgIGNvbnN0IHtkYXRhQ29tcGFyYXRvcn0gPSBuZXdQcm9wcztcbiAgICBpZiAoZGF0YUNvbXBhcmF0b3IpIHtcbiAgICAgIGlmICghZGF0YUNvbXBhcmF0b3IobmV3UHJvcHMuZGF0YSwgb2xkUHJvcHMuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdEYXRhIGNvbXBhcmF0b3IgZGV0ZWN0ZWQgYSBjaGFuZ2UnO1xuICAgICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZG8gYSBzaGFsbG93IGVxdWFsIG9uIHByb3BzXG4gICAgfSBlbHNlIGlmIChuZXdQcm9wcy5kYXRhICE9PSBvbGRQcm9wcy5kYXRhKSB7XG4gICAgICByZXR1cm4gJ0EgbmV3IGRhdGEgY29udGFpbmVyIHdhcyBzdXBwbGllZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDaGVja3MgaWYgYW55IHVwZGF0ZSB0cmlnZ2VycyBoYXZlIGNoYW5nZWQsIGFuZCBpbnZhbGlkYXRlXG4gIC8vIGF0dHJpYnV0ZXMgYWNjb3JkaW5nbHkuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9kaWZmVXBkYXRlVHJpZ2dlcnMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgLy8gY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBjb25zdCB1cGRhdGVUcmlnZ2VyTWFwID0gYXR0cmlidXRlTWFuYWdlci5nZXRVcGRhdGVUcmlnZ2VyTWFwKCk7XG5cbiAgICBsZXQgY2hhbmdlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzKSB7XG4gICAgICBjb25zdCBvbGRUcmlnZ2VycyA9IG9sZFByb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgIGNvbnN0IG5ld1RyaWdnZXJzID0gbmV3UHJvcHMudXBkYXRlVHJpZ2dlcnNbcHJvcE5hbWVdIHx8IHt9O1xuICAgICAgY29uc3QgZGlmZlJlYXNvbiA9IGNvbXBhcmVQcm9wcyh7XG4gICAgICAgIG9sZFByb3BzOiBvbGRUcmlnZ2VycyxcbiAgICAgICAgbmV3UHJvcHM6IG5ld1RyaWdnZXJzXG4gICAgICB9KTtcbiAgICAgIGlmIChkaWZmUmVhc29uKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUsXG4gICAgICAgICAgICBgdXBkYXRlVHJpZ2dlcnMgaW52YWxpZGF0aW5nIGFsbCBhdHRyaWJ1dGVzOiAke2RpZmZSZWFzb259YCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSxcbiAgICAgICAgICAgIGB1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYXR0cmlidXRlICR7cHJvcE5hbWV9OiAke2RpZmZSZWFzb259YCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX2NoZWNrUmVxdWlyZWRQcm9wKHByb3BlcnR5TmFtZSwgY29uZGl0aW9uKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IHVuZGVmaW5lZCBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICAgIGlmIChjb25kaXRpb24gJiYgIWNvbmRpdGlvbih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRW1pdHMgYSB3YXJuaW5nIGlmIGFuIG9sZCBwcm9wIGlzIHVzZWQsIG9wdGlvbmFsbHkgc3VnZ2VzdGluZyBhIHJlcGxhY2VtZW50XG4gIF9jaGVja1JlbW92ZWRQcm9wKG9sZFByb3AsIG5ld1Byb3AgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMucHJvcHNbb2xkUHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbGF5ZXJOYW1lID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGxldCBtZXNzYWdlID0gYCR7bGF5ZXJOYW1lfSBubyBsb25nZXIgYWNjZXB0cyBwcm9wcy4ke29sZFByb3B9IGluIHRoaXMgdmVyc2lvbiBvZiBkZWNrLmdsLmA7XG4gICAgICBpZiAobmV3UHJvcCkge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5QbGVhc2UgdXNlIHByb3BzLiR7bmV3UHJvcH0gaW5zdGVhZC5gO1xuICAgICAgfVxuICAgICAgbG9nLm9uY2UoMCwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUJhc2VVbmlmb3JtcygpIHtcbiAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICBvcGFjaXR5OiBNYXRoLnBvdyh0aGlzLnByb3BzLm9wYWNpdHksIDEgLyAyLjIpLFxuICAgICAgT05FOiAxLjBcbiAgICB9KTtcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFVuaWZvcm1zKHVuaWZvcm1NYXApIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKTtcbiAgICB9XG4gICAgLy8gVE9ETyAtIHNldCBuZWVkc1JlZHJhdyBvbiB0aGUgbW9kZWw/XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgbG9nKDMsICdsYXllci5zZXRVbmlmb3JtcycsIHVuaWZvcm1NYXApO1xuICB9XG59XG5cbkxheWVyLmxheWVyTmFtZSA9ICdMYXllcic7XG5MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbi8vIEhFTFBFUlNcblxuLy8gQ29uc3RydWN0b3JzIGhhdmUgdGhlaXIgc3VwZXIgY2xhc3MgY29uc3RydWN0b3JzIGFzIHByb3RvdHlwZXNcbmZ1bmN0aW9uIGdldE93blByb3BlcnR5KG9iamVjdCwgcHJvcCkge1xuICByZXR1cm4gb2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApICYmIG9iamVjdFtwcm9wXTtcbn1cbi8qXG4gKiBSZXR1cm4gbWVyZ2VkIGRlZmF1bHQgcHJvcHMgc3RvcmVkIG9uIGxheWVycyBjb25zdHJ1Y3RvciwgY3JlYXRlIHRoZW0gaWYgbmVlZGVkXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcyhsYXllcikge1xuICBjb25zdCBtZXJnZWREZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShsYXllci5jb25zdHJ1Y3RvciwgJ21lcmdlZERlZmF1bHRQcm9wcycpO1xuICBpZiAobWVyZ2VkRGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlZERlZmF1bHRQcm9wcztcbiAgfVxuICByZXR1cm4gbWVyZ2VEZWZhdWx0UHJvcHMobGF5ZXIpO1xufVxuXG4vKlxuICogV2FsayB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBtZXJnZSBhbGwgZGVmYXVsdCBwcm9wc1xuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRQcm9wcyhsYXllcikge1xuICBjb25zdCBzdWJDbGFzc0NvbnN0cnVjdG9yID0gbGF5ZXIuY29uc3RydWN0b3I7XG4gIGNvbnN0IGxheWVyTmFtZSA9IGdldE93blByb3BlcnR5KHN1YkNsYXNzQ29uc3RydWN0b3IsICdsYXllck5hbWUnKTtcbiAgaWYgKCFsYXllck5hbWUpIHtcbiAgICBsb2cub25jZSgwLCBgbGF5ZXIgJHtsYXllci5jb25zdHJ1Y3Rvci5uYW1lfSBkb2VzIG5vdCBzcGVjaWZ5IGEgXCJsYXllck5hbWVcImApO1xuICB9XG4gIGxldCBtZXJnZWREZWZhdWx0UHJvcHMgPSB7XG4gICAgaWQ6IGxheWVyTmFtZSB8fCBsYXllci5jb25zdHJ1Y3Rvci5uYW1lXG4gIH07XG5cbiAgd2hpbGUgKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJEZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShsYXllci5jb25zdHJ1Y3RvciwgJ2RlZmF1bHRQcm9wcycpO1xuICAgIE9iamVjdC5mcmVlemUobGF5ZXJEZWZhdWx0UHJvcHMpO1xuICAgIGlmIChsYXllckRlZmF1bHRQcm9wcykge1xuICAgICAgbWVyZ2VkRGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXJEZWZhdWx0UHJvcHMsIG1lcmdlZERlZmF1bHRQcm9wcyk7XG4gICAgfVxuICAgIGxheWVyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGxheWVyKTtcbiAgfVxuICAvLyBTdG9yZSBmb3IgcXVpY2sgbG9va3VwXG4gIHN1YkNsYXNzQ29uc3RydWN0b3IubWVyZ2VkRGVmYXVsdFByb3BzID0gbWVyZ2VkRGVmYXVsdFByb3BzO1xuICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xufVxuXG5leHBvcnQgY29uc3QgVEVTVF9FWFBPUlRTID0ge1xuICBtZXJnZURlZmF1bHRQcm9wc1xufTtcbiJdfQ==