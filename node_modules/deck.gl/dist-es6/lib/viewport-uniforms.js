var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { Matrix4 } from 'luma.gl';

import assert from 'assert';
import { COORDINATE_SYSTEM } from './constants';

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - Math.fround(a);
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      viewMatrix = viewport.viewMatrix,
      projectionMatrix = viewport.projectionMatrix;


  var projectionCenter = void 0;
  var modelViewMatrix = void 0;

  switch (projectionMode) {

    case COORDINATE_SYSTEM.IDENTITY:
    case COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      modelViewMatrix = new Matrix4(viewMatrix);
      break;

    // TODO: make lighitng work for meter offset mode
    case COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      var viewProjectionMatrix = new Matrix4(projectionMatrix).multiplyRight(viewMatrix);
      projectionCenter = viewProjectionMatrix.transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);

      // Always apply uncentered projection matrix if available (shader adds center)
      modelViewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      .multiplyRight(VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var viewMatrixInv = modelViewMatrix.clone().invert();

  if (modelMatrix) {
    // Apply model matrix if supplied
    modelViewMatrix.multiplyRight(modelMatrix);
  }

  var modelViewProjectionMatrix = new Matrix4(projectionMatrix).multiplyRight(modelViewMatrix);
  var cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];

  return {
    modelViewMatrix: modelViewMatrix,
    modelViewProjectionMatrix: modelViewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
export function getUniformsFromViewport(viewport) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  assert(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      modelViewMatrix = _calculateMatrixAndOf.modelViewMatrix,
      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  assert(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;
  assert(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');

  // calculate WebGL matrices

  // Convert to Float32
  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  var devicePixelRatio = window && window.devicePixelRatio || 1;

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // modelMatrix: modelMatrix || new Matrix4().identity(),
    modelViewMatrix: modelViewMatrix,

    // Screen size
    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],
    devicePixelRatio: devicePixelRatio,

    // Main projection matrices
    projectionMatrix: glProjectionMatrix,
    projectionMatrixUncentered: glProjectionMatrix,
    projectionFP64: glProjectionMatrixFP64,
    projectionPixelsPerUnit: projectionPixelsPerUnit,

    // This is the mercator scale (2 ** zoom)
    projectionScale: viewport.scale,

    // Deprecated?
    projectionScaleFP64: fp64ify(viewport.scale),

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)

  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibmFtZXMiOlsiTWF0cml4NCIsImFzc2VydCIsIkNPT1JESU5BVEVfU1lTVEVNIiwiZnA2NGlmeSIsImEiLCJoaVBhcnQiLCJNYXRoIiwiZnJvdW5kIiwibG9QYXJ0IiwiWkVST19WRUNUT1IiLCJWRUNUT1JfVE9fUE9JTlRfTUFUUklYIiwiY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0IiwicHJvamVjdGlvbk1vZGUiLCJwb3NpdGlvbk9yaWdpbiIsInZpZXdwb3J0IiwibW9kZWxNYXRyaXgiLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsInZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdGlvbkNlbnRlciIsIm1vZGVsVmlld01hdHJpeCIsIklERU5USVRZIiwiTE5HTEFUIiwiTUVURVJfT0ZGU0VUUyIsInBvc2l0aW9uUGl4ZWxzIiwicHJvamVjdEZsYXQiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsIm11bHRpcGx5UmlnaHQiLCJ0cmFuc2Zvcm1WZWN0b3IiLCJFcnJvciIsInZpZXdNYXRyaXhJbnYiLCJjbG9uZSIsImludmVydCIsIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgiLCJjYW1lcmFQb3MiLCJnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCIsInNjYWxlIiwicHJvamVjdGlvblBpeGVsc1BlclVuaXQiLCJnZXREaXN0YW5jZVNjYWxlcyIsInBpeGVsc1Blck1ldGVyIiwiZ2xQcm9qZWN0aW9uTWF0cml4IiwiRmxvYXQzMkFycmF5IiwiZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCIsImkiLCJqIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsInZpZXdwb3J0U2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwicHJvamVjdGlvbk1hdHJpeFVuY2VudGVyZWQiLCJwcm9qZWN0aW9uRlA2NCIsInByb2plY3Rpb25TY2FsZSIsInByb2plY3Rpb25TY2FsZUZQNjQiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRQSxPQUFSLFFBQXNCLFNBQXRCOztBQUVBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7QUFDQSxTQUFRQyxpQkFBUixRQUFnQyxhQUFoQzs7QUFFQSxTQUFTQyxPQUFULENBQWlCQyxDQUFqQixFQUFvQjtBQUNsQixNQUFNQyxTQUFTQyxLQUFLQyxNQUFMLENBQVlILENBQVosQ0FBZjtBQUNBLE1BQU1JLFNBQVNKLElBQUlFLEtBQUtDLE1BQUwsQ0FBWUgsQ0FBWixDQUFuQjtBQUNBLFNBQU8sQ0FBQ0MsTUFBRCxFQUFTRyxNQUFULENBQVA7QUFDRDs7QUFFRDtBQUNBLElBQU1DLGNBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQXBCO0FBQ0E7QUFDQSxJQUFNQyx5QkFBeUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUEvQjs7QUFFQSxTQUFTQyx3QkFBVCxPQUtHO0FBQUEsTUFKREMsY0FJQyxRQUpEQSxjQUlDO0FBQUEsTUFIREMsY0FHQyxRQUhEQSxjQUdDO0FBQUEsTUFGREMsUUFFQyxRQUZEQSxRQUVDO0FBQUEsTUFEREMsV0FDQyxRQUREQSxXQUNDO0FBQUEsTUFDTUMsb0JBRE4sR0FDNERGLFFBRDVELENBQ01FLG9CQUROO0FBQUEsTUFDNEJDLFVBRDVCLEdBQzRESCxRQUQ1RCxDQUM0QkcsVUFENUI7QUFBQSxNQUN3Q0MsZ0JBRHhDLEdBQzRESixRQUQ1RCxDQUN3Q0ksZ0JBRHhDOzs7QUFHRCxNQUFJQyx5QkFBSjtBQUNBLE1BQUlDLHdCQUFKOztBQUVBLFVBQVFSLGNBQVI7O0FBRUEsU0FBS1Ysa0JBQWtCbUIsUUFBdkI7QUFDQSxTQUFLbkIsa0JBQWtCb0IsTUFBdkI7QUFDRUgseUJBQW1CVixXQUFuQjtBQUNBVyx3QkFBa0IsSUFBSXBCLE9BQUosQ0FBWWlCLFVBQVosQ0FBbEI7QUFDQTs7QUFFRjtBQUNBLFNBQUtmLGtCQUFrQnFCLGFBQXZCO0FBQ0U7QUFDQTtBQUNBO0FBQ0EsVUFBTUMsaUJBQWlCVixTQUFTVyxXQUFULENBQXFCWixjQUFyQixDQUF2QjtBQUNBLFVBQU1hLHVCQUF1QixJQUFJMUIsT0FBSixDQUFZa0IsZ0JBQVosRUFBOEJTLGFBQTlCLENBQTRDVixVQUE1QyxDQUE3QjtBQUNBRSx5QkFBbUJPLHFCQUNoQkUsZUFEZ0IsQ0FDQSxDQUFDSixlQUFlLENBQWYsQ0FBRCxFQUFvQkEsZUFBZSxDQUFmLENBQXBCLEVBQXVDLEdBQXZDLEVBQTRDLEdBQTVDLENBREEsQ0FBbkI7O0FBR0E7QUFDQUosd0JBQWtCLElBQUlwQixPQUFKLENBQVlnQix3QkFBd0JDLFVBQXBDO0FBQ2hCO0FBRGdCLE9BRWZVLGFBRmUsQ0FFRGpCLHNCQUZDLENBQWxCO0FBR0E7O0FBRUY7QUFDRSxZQUFNLElBQUltQixLQUFKLENBQVUseUJBQVYsQ0FBTjtBQXpCRjs7QUE0QkEsTUFBTUMsZ0JBQWdCVixnQkFBZ0JXLEtBQWhCLEdBQXdCQyxNQUF4QixFQUF0Qjs7QUFFQSxNQUFJakIsV0FBSixFQUFpQjtBQUNmO0FBQ0FLLG9CQUFnQk8sYUFBaEIsQ0FBOEJaLFdBQTlCO0FBQ0Q7O0FBRUQsTUFBTWtCLDRCQUE0QixJQUFJakMsT0FBSixDQUFZa0IsZ0JBQVosRUFBOEJTLGFBQTlCLENBQTRDUCxlQUE1QyxDQUFsQztBQUNBLE1BQU1jLFlBQVksQ0FBQ0osY0FBYyxFQUFkLENBQUQsRUFBb0JBLGNBQWMsRUFBZCxDQUFwQixFQUF1Q0EsY0FBYyxFQUFkLENBQXZDLENBQWxCOztBQUVBLFNBQU87QUFDTFYsb0NBREs7QUFFTGEsd0RBRks7QUFHTGQsc0NBSEs7QUFJTGU7QUFKSyxHQUFQO0FBTUQ7O0FBRUQ7Ozs7Ozs7OztBQVNBLE9BQU8sU0FBU0MsdUJBQVQsQ0FBaUNyQixRQUFqQyxFQUlDO0FBQUEsa0ZBQUosRUFBSTtBQUFBLGdDQUhOQyxXQUdNO0FBQUEsTUFITkEsV0FHTSxxQ0FIUSxJQUdSO0FBQUEsbUNBRk5ILGNBRU07QUFBQSxNQUZOQSxjQUVNLHdDQUZXVixrQkFBa0JvQixNQUU3QjtBQUFBLG1DQUROVCxjQUNNO0FBQUEsTUFETkEsY0FDTSx3Q0FEVyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQ1g7O0FBQ05aLFNBQU9hLFNBQVNzQixLQUFoQixFQUF1Qix3QkFBdkI7O0FBRE0sOEJBSUp6Qix5QkFBeUIsRUFBQ0MsOEJBQUQsRUFBaUJDLDhCQUFqQixFQUFpQ0Usd0JBQWpDLEVBQThDRCxrQkFBOUMsRUFBekIsQ0FKSTtBQUFBLE1BR0NLLGdCQUhELHlCQUdDQSxnQkFIRDtBQUFBLE1BR21CQyxlQUhuQix5QkFHbUJBLGVBSG5CO0FBQUEsTUFHb0NhLHlCQUhwQyx5QkFHb0NBLHlCQUhwQztBQUFBLE1BRytEQyxTQUgvRCx5QkFHK0RBLFNBSC9EOztBQU1OakMsU0FBT2dDLHlCQUFQLEVBQWtDLDRDQUFsQzs7QUFFQTtBQUNBLE1BQU1JLDBCQUEwQnZCLFNBQVN3QixpQkFBVCxHQUE2QkMsY0FBN0Q7QUFDQXRDLFNBQU9vQyx1QkFBUCxFQUFnQyxpQ0FBaEM7O0FBRUE7O0FBRUE7QUFDQSxNQUFNRyxxQkFBcUIsSUFBSUMsWUFBSixDQUFpQlIseUJBQWpCLENBQTNCOztBQUVBO0FBQ0E7QUFDQSxNQUFNUyx5QkFBeUIsSUFBSUQsWUFBSixDQUFpQixFQUFqQixDQUEvQjtBQUNBLE9BQUssSUFBSUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLENBQXBCLEVBQXVCLEVBQUVBLENBQXpCLEVBQTRCO0FBQzFCLFNBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLENBQXBCLEVBQXVCLEVBQUVBLENBQXpCLEVBQTRCO0FBQUEscUJBSXRCekMsUUFBUThCLDBCQUEwQlcsSUFBSSxDQUFKLEdBQVFELENBQWxDLENBQVIsQ0FKc0I7O0FBQUE7O0FBRXhCRCw2QkFBdUIsQ0FBQ0MsSUFBSSxDQUFKLEdBQVFDLENBQVQsSUFBYyxDQUFyQyxDQUZ3QjtBQUd4QkYsNkJBQXVCLENBQUNDLElBQUksQ0FBSixHQUFRQyxDQUFULElBQWMsQ0FBZCxHQUFrQixDQUF6QyxDQUh3QjtBQUszQjtBQUNGOztBQUVELE1BQU1DLG1CQUFvQkMsVUFBVUEsT0FBT0QsZ0JBQWxCLElBQXVDLENBQWhFOztBQUVBLFNBQU87QUFDTDtBQUNBakMsa0NBRks7QUFHTE8sc0NBSEs7O0FBS0w7QUFDQUMsb0NBTks7O0FBUUw7QUFDQTJCLGtCQUFjLENBQUNqQyxTQUFTa0MsS0FBVCxHQUFpQkgsZ0JBQWxCLEVBQW9DL0IsU0FBU21DLE1BQVQsR0FBa0JKLGdCQUF0RCxDQVRUO0FBVUxBLHNDQVZLOztBQVlMO0FBQ0EzQixzQkFBa0JzQixrQkFiYjtBQWNMVSxnQ0FBNEJWLGtCQWR2QjtBQWVMVyxvQkFBZ0JULHNCQWZYO0FBZ0JMTCxvREFoQks7O0FBa0JMO0FBQ0FlLHFCQUFpQnRDLFNBQVNzQixLQW5CckI7O0FBcUJMO0FBQ0FpQix5QkFBcUJsRCxRQUFRVyxTQUFTc0IsS0FBakIsQ0F0QmhCOztBQXdCTDtBQUNBRixlQUFXLElBQUlPLFlBQUosQ0FBaUJQLFNBQWpCOztBQXpCTixHQUFQO0FBNEJEIiwiZmlsZSI6InZpZXdwb3J0LXVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7TWF0cml4NH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vY29uc3RhbnRzJztcblxuZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gTWF0aC5mcm91bmQoYSk7XG4gIHJldHVybiBbaGlQYXJ0LCBsb1BhcnRdO1xufVxuXG4vLyBUbyBxdWlja2x5IHNldCBhIHZlY3RvciB0byB6ZXJvXG5jb25zdCBaRVJPX1ZFQ1RPUiA9IFswLCAwLCAwLCAwXTtcbi8vIDR4NCBtYXRyaXggdGhhdCBkcm9wcyA0dGggY29tcG9uZW50IG9mIHZlY3RvclxuY29uc3QgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgcHJvamVjdGlvbk1vZGUsXG4gIHBvc2l0aW9uT3JpZ2luLFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXhcbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4fSA9IHZpZXdwb3J0O1xuXG4gIGxldCBwcm9qZWN0aW9uQ2VudGVyO1xuICBsZXQgbW9kZWxWaWV3TWF0cml4O1xuXG4gIHN3aXRjaCAocHJvamVjdGlvbk1vZGUpIHtcblxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLklERU5USVRZOlxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVDpcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gWkVST19WRUNUT1I7XG4gICAgbW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeCk7XG4gICAgYnJlYWs7XG5cbiAgLy8gVE9ETzogbWFrZSBsaWdoaXRuZyB3b3JrIGZvciBtZXRlciBvZmZzZXQgbW9kZVxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLk1FVEVSX09GRlNFVFM6XG4gICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWVkIHByb2plY3Rpb25DZW50ZXIgKGluIDY0IGJpdCBwcmVjaXNpb24pXG4gICAgLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvbiAoYXZvaWRzIGRvaW5nIHRoaXNcbiAgICAvLyBhZGRpdGlvbiBpbiAzMiBiaXQgcHJlY2lzaW9uKVxuICAgIGNvbnN0IHBvc2l0aW9uUGl4ZWxzID0gdmlld3BvcnQucHJvamVjdEZsYXQocG9zaXRpb25PcmlnaW4pO1xuICAgIGNvbnN0IHZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQocHJvamVjdGlvbk1hdHJpeCkubXVsdGlwbHlSaWdodCh2aWV3TWF0cml4KTtcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmlld1Byb2plY3Rpb25NYXRyaXhcbiAgICAgIC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcblxuICAgIC8vIEFsd2F5cyBhcHBseSB1bmNlbnRlcmVkIHByb2plY3Rpb24gbWF0cml4IGlmIGF2YWlsYWJsZSAoc2hhZGVyIGFkZHMgY2VudGVyKVxuICAgIG1vZGVsVmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KHZpZXdNYXRyaXhVbmNlbnRlcmVkIHx8IHZpZXdNYXRyaXgpXG4gICAgICAvLyBaZXJvIG91dCA0dGggY29vcmRpbmF0ZSAoXCJhZnRlclwiIG1vZGVsIG1hdHJpeCkgLSBhdm9pZHMgZnVydGhlciB0cmFuc2xhdGlvbnNcbiAgICAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb2plY3Rpb24gbW9kZScpO1xuICB9XG5cbiAgY29uc3Qgdmlld01hdHJpeEludiA9IG1vZGVsVmlld01hdHJpeC5jbG9uZSgpLmludmVydCgpO1xuXG4gIGlmIChtb2RlbE1hdHJpeCkge1xuICAgIC8vIEFwcGx5IG1vZGVsIG1hdHJpeCBpZiBzdXBwbGllZFxuICAgIG1vZGVsVmlld01hdHJpeC5tdWx0aXBseVJpZ2h0KG1vZGVsTWF0cml4KTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NChwcm9qZWN0aW9uTWF0cml4KS5tdWx0aXBseVJpZ2h0KG1vZGVsVmlld01hdHJpeCk7XG4gIGNvbnN0IGNhbWVyYVBvcyA9IFt2aWV3TWF0cml4SW52WzEyXSwgdmlld01hdHJpeEludlsxM10sIHZpZXdNYXRyaXhJbnZbMTRdXTtcblxuICByZXR1cm4ge1xuICAgIG1vZGVsVmlld01hdHJpeCxcbiAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh2aWV3cG9ydCwge1xuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBwb3NpdGlvbk9yaWdpbiA9IFswLCAwXVxufSA9IHt9KSB7XG4gIGFzc2VydCh2aWV3cG9ydC5zY2FsZSwgJ1ZpZXdwb3J0IHNjYWxlIG1pc3NpbmcnKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgbW9kZWxWaWV3TWF0cml4LCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe3Byb2plY3Rpb25Nb2RlLCBwb3NpdGlvbk9yaWdpbiwgbW9kZWxNYXRyaXgsIHZpZXdwb3J0fSk7XG5cbiAgYXNzZXJ0KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgcHJvamVjdGlvblBpeGVsc1BlclVuaXQgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpLnBpeGVsc1Blck1ldGVyO1xuICBhc3NlcnQocHJvamVjdGlvblBpeGVsc1BlclVuaXQsICdWaWV3cG9ydCBtaXNzaW5nIHBpeGVsc1Blck1ldGVyJyk7XG5cbiAgLy8gY2FsY3VsYXRlIFdlYkdMIG1hdHJpY2VzXG5cbiAgLy8gQ29udmVydCB0byBGbG9hdDMyXG4gIGNvbnN0IGdsUHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgLy8gXCJGbG9hdDY0QXJyYXlcIlxuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBbXG4gICAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyXSxcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gbW9kZWxNYXRyaXg6IG1vZGVsTWF0cml4IHx8IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKSxcbiAgICBtb2RlbFZpZXdNYXRyaXgsXG5cbiAgICAvLyBTY3JlZW4gc2l6ZVxuICAgIHZpZXdwb3J0U2l6ZTogW3ZpZXdwb3J0LndpZHRoICogZGV2aWNlUGl4ZWxSYXRpbywgdmlld3BvcnQuaGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpb10sXG4gICAgZGV2aWNlUGl4ZWxSYXRpbyxcblxuICAgIC8vIE1haW4gcHJvamVjdGlvbiBtYXRyaWNlc1xuICAgIHByb2plY3Rpb25NYXRyaXg6IGdsUHJvamVjdGlvbk1hdHJpeCxcbiAgICBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25GUDY0OiBnbFByb2plY3Rpb25NYXRyaXhGUDY0LFxuICAgIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LFxuXG4gICAgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcbiAgICBwcm9qZWN0aW9uU2NhbGU6IHZpZXdwb3J0LnNjYWxlLFxuXG4gICAgLy8gRGVwcmVjYXRlZD9cbiAgICBwcm9qZWN0aW9uU2NhbGVGUDY0OiBmcDY0aWZ5KHZpZXdwb3J0LnNjYWxlKSxcblxuICAgIC8vIFRoaXMgaXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICAgIGNhbWVyYVBvczogbmV3IEZsb2F0MzJBcnJheShjYW1lcmFQb3MpXG5cbiAgfTtcbn1cbiJdfQ==