var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// View and Projection Matrix calculations for mapbox-js style
// map view properties
import Viewport, { createMat4 } from './viewport';
import { mat4, vec2 } from 'gl-matrix';
import assert from 'assert';

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE;

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity, max-statements */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var distanceScales = calculateDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    // The uncentered matrix allows us two move the center addition to the
    // shader (cheap) which gives a coordinate system that has its center in
    // the layer's center position. This makes rotations and other modelMatrx
    // transforms much more useful.
    var viewMatrixUncentered = makeUncenteredViewMatrixFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales
    });

    // Make a centered version of the matrix for projection modes without an offset
    var center = projectFlat([longitude, latitude], scale);

    var viewMatrix = mat4.translate(createMat4(), viewMatrixUncentered, [-center[0], -center[1], 0]);

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    // Save calculated values
    _this.scale = scale;
    _this.center = center;
    _this.viewMatrixUncentered = viewMatrixUncentered;
    _this._distanceScales = distanceScales;

    // Bind methods
    _this.getDistanceScales = _this.getDistanceScales.bind(_this);
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity, max-statements */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return unprojectFlat(xy, scale);
    }
  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var c = this.project(lngLat, { topLeft: false });
      var coordCenter = this.project([this.longitude, this.latitude], { topLeft: false });
      var coordAtPoint = pos;
      var translate = vec2.sub([], coordAtPoint, c);
      var newPos = vec2.sub([], coordCenter, translate);
      var newLngLat = this.unproject(newPos, { topLeft: false });

      return newLngLat;
    }

    /*
    getLngLatAtViewportPosition(lnglat, xy) {
      const c = this.locationCoordinate(lnglat);
      const coordAtPoint = this.pointCoordinate(xy);
      const coordCenter = this.pointCoordinate(this.centerPoint);
      const translate = coordAtPoint._sub(c);
      this.center = this.coordinateLocation(coordCenter._sub(translate));
    }
    */

  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this._distanceScales;
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this._distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      assert(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this._distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this._distanceScales;
    }
  }]);

  return WebMercatorViewport;
}(Viewport);

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */


export default WebMercatorViewport;
function projectFlat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      lng = _ref4[0],
      lat = _ref4[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function unprojectFlat(_ref5, scale) {
  var _ref6 = _slicedToArray(_ref5, 2),
      x = _ref6[0],
      y = _ref6[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function calculateDistanceScales(_ref7) {
  var latitude = _ref7.latitude,
      longitude = _ref7.longitude,
      scale = _ref7.scale;

  assert(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale), ERR_ARGUMENT);
  // Approximately 111km per degree at equator
  var METERS_PER_DEGREE = 111000;

  var latCosine = Math.cos(latitude * Math.PI / 180);

  var metersPerDegree = METERS_PER_DEGREE * latCosine;

  // Calculate number of pixels occupied by one degree longitude
  // around current lat/lon
  var pixelsPerDegreeX = vec2.distance(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale));
  // Calculate number of pixels occupied by one degree latitude
  // around current lat/lon
  var pixelsPerDegreeY = vec2.distance(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));

  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;
  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];

  var worldSize = TILE_SIZE * scale;
  var altPixelsPerMeter = worldSize / (4e7 * latCosine);
  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];

  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];
  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return {
    pixelsPerMeter: pixelsPerMeter,
    metersPerPixel: metersPerPixel,
    pixelsPerDegree: pixelsPerDegree,
    degreesPerPixel: degreesPerPixel
  };
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
export function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

export function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
export function makeProjectionMatrixFromMercatorParams(_ref10) {
  var width = _ref10.width,
      height = _ref10.height,
      pitch = _ref10.pitch,
      altitude = _ref10.altitude,
      _ref10$farZMultiplier = _ref10.farZMultiplier,
      farZMultiplier = _ref10$farZMultiplier === undefined ? 10 : _ref10$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = mat4.perspective(createMat4(), fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

function makeUncenteredViewMatrixFromMercatorParams(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      longitude = _ref11.longitude,
      latitude = _ref11.latitude,
      zoom = _ref11.zoom,
      pitch = _ref11.pitch,
      bearing = _ref11.bearing,
      altitude = _ref11.altitude,
      center = _ref11.center;

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = createMat4();

  // Move camera to altitude
  mat4.translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  mat4.scale(vm, vm, [1, -1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  mat4.rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);
  mat4.rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);

  return vm;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJWaWV3cG9ydCIsImNyZWF0ZU1hdDQiLCJtYXQ0IiwidmVjMiIsImFzc2VydCIsIlBJIiwiTWF0aCIsIlBJXzQiLCJERUdSRUVTX1RPX1JBRElBTlMiLCJSQURJQU5TX1RPX0RFR1JFRVMiLCJUSUxFX1NJWkUiLCJXT1JMRF9TQ0FMRSIsIkRFRkFVTFRfTUFQX1NUQVRFIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwiYWx0aXR1ZGUiLCJFUlJfQVJHVU1FTlQiLCJXZWJNZXJjYXRvclZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJmYXJaTXVsdGlwbGllciIsInVuZGVmaW5lZCIsInNjYWxlIiwicG93IiwibWF4IiwiZGlzdGFuY2VTY2FsZXMiLCJjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyIsInByb2plY3Rpb25NYXRyaXgiLCJtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwibWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zIiwiY2VudGVyIiwicHJvamVjdEZsYXQiLCJ2aWV3TWF0cml4IiwidHJhbnNsYXRlIiwiX2Rpc3RhbmNlU2NhbGVzIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJiaW5kIiwibWV0ZXJzVG9MbmdMYXREZWx0YSIsImxuZ0xhdERlbHRhVG9NZXRlcnMiLCJhZGRNZXRlcnNUb0xuZ0xhdCIsIk9iamVjdCIsImZyZWV6ZSIsImxuZ0xhdCIsInh5IiwidW5wcm9qZWN0RmxhdCIsInBvcyIsImMiLCJwcm9qZWN0IiwidG9wTGVmdCIsImNvb3JkQ2VudGVyIiwiY29vcmRBdFBvaW50Iiwic3ViIiwibmV3UG9zIiwibmV3TG5nTGF0IiwidW5wcm9qZWN0IiwieHl6IiwieCIsInkiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwaXhlbHNQZXJNZXRlciIsImRlZ3JlZXNQZXJQaXhlbCIsImRlbHRhTG5nIiwiZGVsdGFMYXQiLCJsZW5ndGgiLCJkZWx0YUxuZ0xhdFoiLCJkZWx0YVoiLCJwaXhlbHNQZXJEZWdyZWUiLCJtZXRlcnNQZXJQaXhlbCIsImRlbHRhWCIsImRlbHRhWSIsImxuZ0xhdFoiLCJsbmciLCJsYXQiLCJaIiwibGFtYmRhMiIsInBoaTIiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwiaXNOYU4iLCJNRVRFUlNfUEVSX0RFR1JFRSIsImxhdENvc2luZSIsImNvcyIsIm1ldGVyc1BlckRlZ3JlZSIsInBpeGVsc1BlckRlZ3JlZVgiLCJkaXN0YW5jZSIsInBpeGVsc1BlckRlZ3JlZVkiLCJwaXhlbHNQZXJNZXRlclgiLCJwaXhlbHNQZXJNZXRlclkiLCJwaXhlbHNQZXJNZXRlcloiLCJ3b3JsZFNpemUiLCJhbHRQaXhlbHNQZXJNZXRlciIsImdldEZvdiIsImdldENsaXBwaW5nUGxhbmVzIiwicGl0Y2hSYWRpYW5zIiwiaGFsZkZvdiIsInRvcEhhbGZTdXJmYWNlRGlzdGFuY2UiLCJzaW4iLCJmYXJaIiwibmVhcloiLCJmb3YiLCJwZXJzcGVjdGl2ZSIsInZtIiwicm90YXRlWCIsInJvdGF0ZVoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBT0EsUUFBUCxJQUFrQkMsVUFBbEIsUUFBbUMsWUFBbkM7QUFDQSxTQUFRQyxJQUFSLEVBQWNDLElBQWQsUUFBeUIsV0FBekI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBO0FBQ0EsSUFBTUMsS0FBS0MsS0FBS0QsRUFBaEI7QUFDQSxJQUFNRSxPQUFPRixLQUFLLENBQWxCO0FBQ0EsSUFBTUcscUJBQXFCSCxLQUFLLEdBQWhD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LGdCQUFQO0FBQ0Q7O0FBRUQsU0FBU0csMENBQVQsU0FVRztBQUFBLE1BVERaLEtBU0MsVUFUREEsS0FTQztBQUFBLE1BUkRDLE1BUUMsVUFSREEsTUFRQztBQUFBLE1BUERSLFNBT0MsVUFQREEsU0FPQztBQUFBLE1BTkRELFFBTUMsVUFOREEsUUFNQztBQUFBLE1BTERFLElBS0MsVUFMREEsSUFLQztBQUFBLE1BSkRDLEtBSUMsVUFKREEsS0FJQztBQUFBLE1BSERDLE9BR0MsVUFIREEsT0FHQztBQUFBLE1BRkRDLFFBRUMsVUFGREEsUUFFQztBQUFBLE1BRERnQixNQUNDLFVBRERBLE1BQ0M7O0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTJFLEtBQUs1RyxZQUFYOztBQUVBO0FBQ0FDLE9BQUttQyxTQUFMLENBQWV3RSxFQUFmLEVBQW1CQSxFQUFuQixFQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQzNGLFFBQVIsQ0FBdkI7O0FBRUE7QUFDQTtBQUNBaEIsT0FBS3VCLEtBQUwsQ0FBV29GLEVBQVgsRUFBZUEsRUFBZixFQUFtQixDQUFDLENBQUQsRUFBSSxDQUFDLENBQUwsRUFBUSxJQUFJdkYsTUFBWixDQUFuQjs7QUFFQTtBQUNBcEIsT0FBSzRHLE9BQUwsQ0FBYUQsRUFBYixFQUFpQkEsRUFBakIsRUFBcUI3RixRQUFRUixrQkFBN0I7QUFDQU4sT0FBSzZHLE9BQUwsQ0FBYUYsRUFBYixFQUFpQkEsRUFBakIsRUFBcUIsQ0FBQzVGLE9BQUQsR0FBV1Qsa0JBQWhDOztBQUVBLFNBQU9xRyxFQUFQO0FBQ0QiLCJmaWxlIjoid2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IGNhbGN1bGF0aW9ucyBmb3IgbWFwYm94LWpzIHN0eWxlXG4vLyBtYXAgdmlldyBwcm9wZXJ0aWVzXG5pbXBvcnQgVmlld3BvcnQsIHtjcmVhdGVNYXQ0fSBmcm9tICcuL3ZpZXdwb3J0JztcbmltcG9ydCB7bWF0NCwgdmVjMn0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gQ09OU1RBTlRTXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBQSV80ID0gUEkgLyA0O1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG5jb25zdCBSQURJQU5TX1RPX0RFR1JFRVMgPSAxODAgLyBQSTtcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmNvbnN0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFO1xuXG5jb25zdCBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuY29uc3QgRVJSX0FSR1VNRU5UID0gJ0lsbGVnYWwgYXJndW1lbnQgdG8gV2ViTWVyY2F0b3JWaWV3cG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIENyZWF0ZXMgdmlldy9wcm9qZWN0aW9uIG1hdHJpY2VzIGZyb20gbWVyY2F0b3IgcGFyYW1zXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG5cbiAgICogTm90ZXM6XG4gICAqICAtIE9ubHkgb25lIG9mIGNlbnRlciBvciBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIGJlIHNwZWNpZmllZFxuICAgKiAgLSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIHdoZW4gXCJtZXJjYXRvclwiIGlzIHRydWVcbiAgICogIC0gQWx0aXR1ZGUgaGFzIGEgZGVmYXVsdCB2YWx1ZSB0aGF0IG1hdGNoZXMgYXNzdW1wdGlvbnMgaW4gbWFwYm94LWdsXG4gICAqICAtIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGZvcmNlZCB0byAxIGlmIHN1cHBsaWVkIGFzIDAsIHRvIGF2b2lkXG4gICAqICAgIGRpdmlzaW9uIGJ5IHplcm8uIFRoaXMgaXMgaW50ZW5kZWQgdG8gcmVkdWNlIHRoZSBidXJkZW4gb2YgYXBwcyB0b1xuICAgKiAgICB0byBjaGVjayB2YWx1ZXMgYmVmb3JlIGluc3RhbnRpYXRpbmcgYSBWaWV3cG9ydC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBNYXAgc3RhdGVcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGF0aXR1ZGUsXG4gICAgbG9uZ2l0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBmYXJaTXVsdGlwbGllciA9IDEwXG4gIH0gPSB7fSkge1xuICAgIC8vIFZpZXdwb3J0IC0gc3VwcG9ydCB1bmRlZmluZWQgYXJndW1lbnRzXG4gICAgd2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiBERUZBVUxUX01BUF9TVEFURS53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IERFRkFVTFRfTUFQX1NUQVRFLmhlaWdodDtcbiAgICB6b29tID0gem9vbSAhPT0gdW5kZWZpbmVkID8gem9vbSA6IERFRkFVTFRfTUFQX1NUQVRFLnpvb207XG4gICAgbGF0aXR1ZGUgPSBsYXRpdHVkZSAhPT0gdW5kZWZpbmVkID8gbGF0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sYXRpdHVkZTtcbiAgICBsb25naXR1ZGUgPSBsb25naXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxvbmdpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxvbmdpdHVkZTtcbiAgICBiZWFyaW5nID0gYmVhcmluZyAhPT0gdW5kZWZpbmVkID8gYmVhcmluZyA6IERFRkFVTFRfTUFQX1NUQVRFLmJlYXJpbmc7XG4gICAgcGl0Y2ggPSBwaXRjaCAhPT0gdW5kZWZpbmVkID8gcGl0Y2ggOiBERUZBVUxUX01BUF9TVEFURS5waXRjaDtcbiAgICBhbHRpdHVkZSA9IGFsdGl0dWRlICE9PSB1bmRlZmluZWQgPyBhbHRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmFsdGl0dWRlO1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMCB0byBmYWNpbGl0YXRlIGlzb21vcnBoaWMgcmVuZGVyIGV0Y1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgLy8gQWx0aXR1ZGUgLSBwcmV2ZW50IGRpdmlzaW9uIGJ5IDBcbiAgICAvLyBUT0RPIC0ganVzdCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkP1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuXG4gICAgY29uc3QgZGlzdGFuY2VTY2FsZXMgPSBjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGV9KTtcblxuICAgIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlLFxuICAgICAgZmFyWk11bHRpcGxpZXJcbiAgICB9KTtcblxuICAgIC8vIFRoZSB1bmNlbnRlcmVkIG1hdHJpeCBhbGxvd3MgdXMgdHdvIG1vdmUgdGhlIGNlbnRlciBhZGRpdGlvbiB0byB0aGVcbiAgICAvLyBzaGFkZXIgKGNoZWFwKSB3aGljaCBnaXZlcyBhIGNvb3JkaW5hdGUgc3lzdGVtIHRoYXQgaGFzIGl0cyBjZW50ZXIgaW5cbiAgICAvLyB0aGUgbGF5ZXIncyBjZW50ZXIgcG9zaXRpb24uIFRoaXMgbWFrZXMgcm90YXRpb25zIGFuZCBvdGhlciBtb2RlbE1hdHJ4XG4gICAgLy8gdHJhbnNmb3JtcyBtdWNoIG1vcmUgdXNlZnVsLlxuICAgIGNvbnN0IHZpZXdNYXRyaXhVbmNlbnRlcmVkID0gbWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBkaXN0YW5jZVNjYWxlc1xuICAgIH0pO1xuXG4gICAgLy8gTWFrZSBhIGNlbnRlcmVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeCBmb3IgcHJvamVjdGlvbiBtb2RlcyB3aXRob3V0IGFuIG9mZnNldFxuICAgIGNvbnN0IGNlbnRlciA9IHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlXSwgc2NhbGUpO1xuXG4gICAgY29uc3Qgdmlld01hdHJpeCA9IG1hdDQudHJhbnNsYXRlKFxuICAgICAgY3JlYXRlTWF0NCgpLCB2aWV3TWF0cml4VW5jZW50ZXJlZCwgWy1jZW50ZXJbMF0sIC1jZW50ZXJbMV0sIDBdKTtcblxuICAgIHN1cGVyKHt3aWR0aCwgaGVpZ2h0LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4fSk7XG5cbiAgICAvLyBTYXZlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG5cbiAgICAvLyBTYXZlIGNhbGN1bGF0ZWQgdmFsdWVzXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuICAgIHRoaXMudmlld01hdHJpeFVuY2VudGVyZWQgPSB2aWV3TWF0cml4VW5jZW50ZXJlZDtcbiAgICB0aGlzLl9kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuXG4gICAgLy8gQmluZCBtZXRob2RzXG4gICAgdGhpcy5nZXREaXN0YW5jZVNjYWxlcyA9IHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEgPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMgPSB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZE1ldGVyc1RvTG5nTGF0ID0gdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdC5iaW5kKHRoaXMpO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgX3Byb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICBfdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHVucHJvamVjdEZsYXQoeHksIHNjYWxlKTtcbiAgfVxuXG4gIGdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0LCBwb3N9KSB7XG4gICAgY29uc3QgYyA9IHRoaXMucHJvamVjdChsbmdMYXQsIHt0b3BMZWZ0OiBmYWxzZX0pO1xuICAgIGNvbnN0IGNvb3JkQ2VudGVyID0gdGhpcy5wcm9qZWN0KFt0aGlzLmxvbmdpdHVkZSwgdGhpcy5sYXRpdHVkZV0sIHt0b3BMZWZ0OiBmYWxzZX0pO1xuICAgIGNvbnN0IGNvb3JkQXRQb2ludCA9IHBvcztcbiAgICBjb25zdCB0cmFuc2xhdGUgPSB2ZWMyLnN1YihbXSwgY29vcmRBdFBvaW50LCBjKTtcbiAgICBjb25zdCBuZXdQb3MgPSB2ZWMyLnN1YihbXSwgY29vcmRDZW50ZXIsIHRyYW5zbGF0ZSk7XG4gICAgY29uc3QgbmV3TG5nTGF0ID0gdGhpcy51bnByb2plY3QobmV3UG9zLCB7dG9wTGVmdDogZmFsc2V9KTtcblxuICAgIHJldHVybiBuZXdMbmdMYXQ7XG4gIH1cblxuICAvKlxuICBnZXRMbmdMYXRBdFZpZXdwb3J0UG9zaXRpb24obG5nbGF0LCB4eSkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgIGNvbnN0IGNvb3JkQXRQb2ludCA9IHRoaXMucG9pbnRDb29yZGluYXRlKHh5KTtcbiAgICBjb25zdCBjb29yZENlbnRlciA9IHRoaXMucG9pbnRDb29yZGluYXRlKHRoaXMuY2VudGVyUG9pbnQpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgfVxuICAqL1xuXG4gIGdldERpc3RhbmNlU2NhbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG1ldGVyIG9mZnNldCB0byBhIGxuZ2xhdCBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBtZXRlcnNUb0xuZ0xhdERlbHRhKHh5eikge1xuICAgIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopLCBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlciwgZGVncmVlc1BlclBpeGVsfSA9IHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhTG5nID0geCAqIHBpeGVsc1Blck1ldGVyWzBdICogZGVncmVlc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhTGF0ID0geSAqIHBpeGVsc1Blck1ldGVyWzFdICogZGVncmVlc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW2RlbHRhTG5nLCBkZWx0YUxhdF0gOiBbZGVsdGFMbmcsIGRlbHRhTGF0LCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGxuZ2xhdCBvZmZzZXQgdG8gYSBtZXRlciBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBkZWx0YUxuZ0xhdFogLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqL1xuICBsbmdMYXREZWx0YVRvTWV0ZXJzKGRlbHRhTG5nTGF0Wikge1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gZGVsdGFMbmdMYXRaO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGVsdGFMbmcpICYmIE51bWJlci5pc0Zpbml0ZShkZWx0YUxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhWiksXG4gICAgICBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJEZWdyZWUsIG1ldGVyc1BlclBpeGVsfSA9IHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhWCA9IGRlbHRhTG5nICogcGl4ZWxzUGVyRGVncmVlWzBdICogbWV0ZXJzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFZID0gZGVsdGFMYXQgKiBwaXhlbHNQZXJEZWdyZWVbMV0gKiBtZXRlcnNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4gZGVsdGFMbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFtkZWx0YVgsIGRlbHRhWV0gOiBbZGVsdGFYLCBkZWx0YVksIGRlbHRhWl07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbWV0ZXIgZGVsdGEgdG8gYSBiYXNlIGxuZ2xhdCBjb29yZGluYXRlLCByZXR1cm5pbmcgYSBuZXcgbG5nbGF0IGFycmF5XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgbG5nTGF0WiAtIGJhc2UgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKi9cbiAgYWRkTWV0ZXJzVG9MbmdMYXQobG5nTGF0WiwgeHl6KSB7XG4gICAgY29uc3QgW2xuZywgbGF0LCBaID0gMF0gPSBsbmdMYXRaO1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhKHh5eik7XG4gICAgcmV0dXJuIGxuZ0xhdFoubGVuZ3RoID09PSAyID9cbiAgICAgIFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXRdIDpcbiAgICAgIFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXQsIFogKyBkZWx0YVpdO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIF9nZXRQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICB9XG59XG5cbi8qKlxuICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiBwcm9qZWN0RmxhdChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZnVuY3Rpb24gdW5wcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgY29uc3QgbGFtYmRhMiA9ICh4IC8gc2NhbGUpICogKDIgKiBQSSkgLSBQSTtcbiAgY29uc3QgcGhpMiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFBJIC0gKHkgLyBzY2FsZSkgKiAoMiAqIFBJKSkpIC0gUElfNCk7XG4gIHJldHVybiBbbGFtYmRhMiAqIFJBRElBTlNfVE9fREVHUkVFUywgcGhpMiAqIFJBRElBTlNfVE9fREVHUkVFU107XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpbiBtZXRlcnMgYXJvdW5kIGN1cnJlbnQgbGF0L2xvbiwgYm90aCBmb3JcbiAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAqIEluIG1lcmNhdG9yIHByb2plY3Rpb24gbW9kZSwgdGhlIGRpc3RhbmNlIHNjYWxlcyB2YXJ5IHNpZ25pZmljYW50bHlcbiAqIHdpdGggbGF0aXR1ZGUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZX0pIHtcbiAgYXNzZXJ0KCFpc05hTihsYXRpdHVkZSkgJiYgIWlzTmFOKGxvbmdpdHVkZSkgJiYgIWlzTmFOKHNjYWxlKSwgRVJSX0FSR1VNRU5UKTtcbiAgLy8gQXBwcm94aW1hdGVseSAxMTFrbSBwZXIgZGVncmVlIGF0IGVxdWF0b3JcbiAgY29uc3QgTUVURVJTX1BFUl9ERUdSRUUgPSAxMTEwMDA7XG5cbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBNYXRoLlBJIC8gMTgwKTtcblxuICBjb25zdCBtZXRlcnNQZXJEZWdyZWUgPSBNRVRFUlNfUEVSX0RFR1JFRSAqIGxhdENvc2luZTtcblxuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyLmRpc3RhbmNlKFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgKyAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpLFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgLSAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpXG4gICk7XG4gIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbGF0aXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWVZID0gdmVjMi5kaXN0YW5jZShcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSArIDAuNV0sIHNjYWxlKSxcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSAtIDAuNV0sIHNjYWxlKVxuICApO1xuXG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWSA9IHBpeGVsc1BlckRlZ3JlZVkgLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWiA9IChwaXhlbHNQZXJNZXRlclggKyBwaXhlbHNQZXJNZXRlclkpIC8gMjtcbiAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbcGl4ZWxzUGVyTWV0ZXJYLCBwaXhlbHNQZXJNZXRlclksIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyID0gd29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFsxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlID0gW3BpeGVsc1BlckRlZ3JlZVgsIHBpeGVsc1BlckRlZ3JlZVksIHBpeGVsc1Blck1ldGVyWl07XG4gIGNvbnN0IGRlZ3JlZXNQZXJQaXhlbCA9IFsxIC8gcGl4ZWxzUGVyRGVncmVlWCwgMSAvIHBpeGVsc1BlckRlZ3JlZVksIDEgLyBwaXhlbHNQZXJNZXRlclpdO1xuXG4gIC8vIE1haW4gcmVzdWx0cywgdXNlZCBmb3IgY29udmVydGluZyBtZXRlcnMgdG8gbGF0bG5nIGRlbHRhcyBhbmQgc2NhbGluZyBvZmZzZXRzXG4gIHJldHVybiB7XG4gICAgcGl4ZWxzUGVyTWV0ZXIsXG4gICAgbWV0ZXJzUGVyUGl4ZWwsXG4gICAgcGl4ZWxzUGVyRGVncmVlLFxuICAgIGRlZ3JlZXNQZXJQaXhlbFxuICB9O1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5cbi8vIFZhcmlhYmxlIGZvdiAoaW4gcmFkaWFucylcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3Yoe2hlaWdodCwgYWx0aXR1ZGV9KSB7XG4gIHJldHVybiAyICogTWF0aC5hdGFuKChoZWlnaHQgLyAyKSAvIGFsdGl0dWRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KSB7XG4gIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcFxuICAvLyBpbiBhbHRpdHVkZSB1bml0cyB1c2luZyBsYXcgb2Ygc2luZXMuXG4gIGNvbnN0IHBpdGNoUmFkaWFucyA9IHBpdGNoICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBoYWxmRm92ID0gTWF0aC5hdGFuKDAuNSAvIGFsdGl0dWRlKTtcbiAgY29uc3QgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9XG4gICAgTWF0aC5zaW4oaGFsZkZvdikgKiBhbHRpdHVkZSAvIE1hdGguc2luKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zIC0gaGFsZkZvdik7XG5cbiAgLy8gQ2FsY3VsYXRlIHogdmFsdWUgb2YgdGhlIGZhcnRoZXN0IGZyYWdtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICBjb25zdCBmYXJaID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIGFsdGl0dWRlO1xuXG4gIHJldHVybiB7ZmFyWiwgbmVhclo6IDAuMX07XG59XG5cbi8vIFBST0pFQ1RJT04gTUFUUklYOiBQUk9KRUNUUyBGUk9NIENBTUVSQSAoVklFVykgU1BBQ0UgVE8gQ0xJUFNQQUNFXG5leHBvcnQgZnVuY3Rpb24gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGUsXG4gIGZhclpNdWx0aXBsaWVyID0gMTBcbn0pIHtcbiAgY29uc3Qge25lYXJaLCBmYXJafSA9IGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KTtcbiAgY29uc3QgZm92ID0gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSk7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoXG4gICAgY3JlYXRlTWF0NCgpLFxuICAgIGZvdiwgICAgICAgICAgICAgIC8vIGZvdiBpbiByYWRpYW5zXG4gICAgd2lkdGggLyBoZWlnaHQsICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgbmVhclosICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiBmYXJaTXVsdGlwbGllciAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cblxuZnVuY3Rpb24gbWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgcGl0Y2gsXG4gIGJlYXJpbmcsXG4gIGFsdGl0dWRlLFxuICBjZW50ZXJcbn0pIHtcbiAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIEZST00gVklSVFVBTCBQSVhFTFMgVE8gQ0FNRVJBIFNQQUNFXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZVxuICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0LnNjYWxlKHZtLCB2bSwgWzEsIC0xLCAxIC8gaGVpZ2h0XSk7XG5cbiAgLy8gUm90YXRlIGJ5IGJlYXJpbmcsIGFuZCB0aGVuIGJ5IHBpdGNoICh3aGljaCB0aWx0cyB0aGUgdmlldylcbiAgbWF0NC5yb3RhdGVYKHZtLCB2bSwgcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCAtYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG5cbiAgcmV0dXJuIHZtO1xufVxuIl19