// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { glGetDebugInfo } from 'luma.gl';

// Load shader chunks
// import SHADER_CHUNKS from '../../dist/shaderlib/shader-chunks';
import * as SHADER_CHUNKS from './shader-chunks';

export function checkRendererVendor(debugInfo, gpuVendor) {
  var vendor = debugInfo.vendor,
      renderer = debugInfo.renderer;

  var result = void 0;
  switch (gpuVendor) {
    case 'nvidia':
      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);
      break;
    case 'intel':
      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);
      break;
    case 'amd':
      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);
      break;
    default:
      result = false;
  }
  return result;
}

export function getPlatformShaderDefines(gl) {
  /* eslint-disable */
  var platformDefines = '';
  var debugInfo = glGetDebugInfo(gl);

  if (checkRendererVendor(debugInfo, 'nvidia')) {
    platformDefines += '#define NVIDIA_GPU\n#define NVIDIA_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'intel')) {
    platformDefines += '#define INTEL_GPU\n#define INTEL_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n #define INTEL_TAN_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'amd')) {
    platformDefines += '#define AMD_GPU\n';
  } else {
    platformDefines += '#define DEFAULT_GPU\n';
  }

  return platformDefines;
}

function assembleShader(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _opts = opts,
      vs = _opts.vs,
      _opts$project = _opts.project,
      project = _opts$project === undefined ? true : _opts$project,
      _opts$project2 = _opts.project64,
      project64 = _opts$project2 === undefined ? false : _opts$project2;
  var _opts2 = opts,
      _opts2$fp = _opts2.fp64,
      fp64 = _opts2$fp === undefined ? false : _opts2$fp;

  if (project64 === true) {
    fp64 = true;
  }
  var source = getPlatformShaderDefines(gl) + '\n';
  opts = Object.assign({}, opts, { project: project, project64: project64, fp64: fp64 });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(SHADER_CHUNKS)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var chunkName = _step.value;

      if (opts[chunkName]) {
        source += SHADER_CHUNKS[chunkName].source + '\n';
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (opts.modules || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _chunkName = _step2.value;

      if (SHADER_CHUNKS[_chunkName]) {
        source += SHADER_CHUNKS[_chunkName].source + '\n';
      } else {
        throw new Error('Shader module ' + _chunkName + ' not found');
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  source += vs;
  return source;
}

export function assembleShaders(gl, opts) {
  return {
    gl: gl,
    vs: assembleShader(gl, opts),
    fs: opts.fs
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFkZXItdXRpbHMvYXNzZW1ibGUtc2hhZGVycy5qcyJdLCJuYW1lcyI6WyJnbEdldERlYnVnSW5mbyIsIlNIQURFUl9DSFVOS1MiLCJjaGVja1JlbmRlcmVyVmVuZG9yIiwiZGVidWdJbmZvIiwiZ3B1VmVuZG9yIiwidmVuZG9yIiwicmVuZGVyZXIiLCJyZXN1bHQiLCJtYXRjaCIsImdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyIsImdsIiwicGxhdGZvcm1EZWZpbmVzIiwiYXNzZW1ibGVTaGFkZXIiLCJvcHRzIiwidnMiLCJwcm9qZWN0IiwicHJvamVjdDY0IiwiZnA2NCIsInNvdXJjZSIsIk9iamVjdCIsImFzc2lnbiIsImtleXMiLCJjaHVua05hbWUiLCJtb2R1bGVzIiwiRXJyb3IiLCJhc3NlbWJsZVNoYWRlcnMiLCJmcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsY0FBUixRQUE2QixTQUE3Qjs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxLQUFLQyxhQUFaLE1BQStCLGlCQUEvQjs7QUFFQSxPQUFPLFNBQVNDLG1CQUFULENBQTZCQyxTQUE3QixFQUF3Q0MsU0FBeEMsRUFBbUQ7QUFBQSxNQUNqREMsTUFEaUQsR0FDN0JGLFNBRDZCLENBQ2pERSxNQURpRDtBQUFBLE1BQ3pDQyxRQUR5QyxHQUM3QkgsU0FENkIsQ0FDekNHLFFBRHlDOztBQUV4RCxNQUFJQyxlQUFKO0FBQ0EsVUFBUUgsU0FBUjtBQUNBLFNBQUssUUFBTDtBQUNFRyxlQUFTRixPQUFPRyxLQUFQLENBQWEsU0FBYixLQUEyQkYsU0FBU0UsS0FBVCxDQUFlLFNBQWYsQ0FBcEM7QUFDQTtBQUNGLFNBQUssT0FBTDtBQUNFRCxlQUFTRixPQUFPRyxLQUFQLENBQWEsUUFBYixLQUEwQkYsU0FBU0UsS0FB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Y2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtnbEdldERlYnVnSW5mb30gZnJvbSAnbHVtYS5nbCc7XG5cbi8vIExvYWQgc2hhZGVyIGNodW5rc1xuLy8gaW1wb3J0IFNIQURFUl9DSFVOS1MgZnJvbSAnLi4vLi4vZGlzdC9zaGFkZXJsaWIvc2hhZGVyLWNodW5rcyc7XG5pbXBvcnQgKiBhcyBTSEFERVJfQ0hVTktTIGZyb20gJy4vc2hhZGVyLWNodW5rcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgZ3B1VmVuZG9yKSB7XG4gIGNvbnN0IHt2ZW5kb3IsIHJlbmRlcmVyfSA9IGRlYnVnSW5mbztcbiAgbGV0IHJlc3VsdDtcbiAgc3dpdGNoIChncHVWZW5kb3IpIHtcbiAgY2FzZSAnbnZpZGlhJzpcbiAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL05WSURJQS9pKSB8fCByZW5kZXJlci5tYXRjaCgvTlZJRElBL2kpO1xuICAgIGJyZWFrO1xuICBjYXNlICdpbnRlbCc6XG4gICAgcmVzdWx0ID0gdmVuZG9yLm1hdGNoKC9JTlRFTC9pKSB8fCByZW5kZXJlci5tYXRjaCgvSU5URUwvaSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FtZCc6XG4gICAgcmVzdWx0ID1cbiAgICAgIHZlbmRvci5tYXRjaCgvQU1EL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BTUQvaSkgfHxcbiAgICAgIHZlbmRvci5tYXRjaCgvQVRJL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BVEkvaSk7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgcmVzdWx0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICBsZXQgcGxhdGZvcm1EZWZpbmVzID0gJyc7XG4gIGNvbnN0IGRlYnVnSW5mbyA9IGdsR2V0RGVidWdJbmZvKGdsKTtcblxuICBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdudmlkaWEnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgTlZJRElBX0dQVVxuI2RlZmluZSBOVklESUFfRlA2NF9XT1JLQVJPVU5EIDFcbiNkZWZpbmUgTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQgMVxuYDtcbiAgfSBlbHNlIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ2ludGVsJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIElOVEVMX0dQVVxuI2RlZmluZSBJTlRFTF9GUDY0X1dPUktBUk9VTkQgMVxuI2RlZmluZSBOVklESUFfRVFVQVRJT05fV09SS0FST1VORCAxXFxuIFxcXG4jZGVmaW5lIElOVEVMX1RBTl9XT1JLQVJPVU5EIDFcbmA7XG4gIH0gZWxzZSBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdhbWQnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgQU1EX0dQVVxuYDtcbiAgfSBlbHNlIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIERFRkFVTFRfR1BVXG5gO1xuICB9XG5cbiAgcmV0dXJuIHBsYXRmb3JtRGVmaW5lcztcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXIoZ2wsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7dnMsIHByb2plY3QgPSB0cnVlLCBwcm9qZWN0NjQgPSBmYWxzZX0gPSBvcHRzO1xuICBsZXQge2ZwNjQgPSBmYWxzZX0gPSBvcHRzO1xuICBpZiAocHJvamVjdDY0ID09PSB0cnVlKSB7XG4gICAgZnA2NCA9IHRydWU7XG4gIH1cbiAgbGV0IHNvdXJjZSA9IGAke2dldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCl9XFxuYDtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtwcm9qZWN0LCBwcm9qZWN0NjQsIGZwNjR9KTtcbiAgZm9yIChjb25zdCBjaHVua05hbWUgb2YgT2JqZWN0LmtleXMoU0hBREVSX0NIVU5LUykpIHtcbiAgICBpZiAob3B0c1tjaHVua05hbWVdKSB7XG4gICAgICBzb3VyY2UgKz0gYCR7U0hBREVSX0NIVU5LU1tjaHVua05hbWVdLnNvdXJjZX1cXG5gO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGNodW5rTmFtZSBvZiBvcHRzLm1vZHVsZXMgfHwgW10pIHtcbiAgICBpZiAoU0hBREVSX0NIVU5LU1tjaHVua05hbWVdKSB7XG4gICAgICBzb3VyY2UgKz0gYCR7U0hBREVSX0NIVU5LU1tjaHVua05hbWVdLnNvdXJjZX1cXG5gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNoYWRlciBtb2R1bGUgJHtjaHVua05hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICBzb3VyY2UgKz0gdnM7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlbWJsZVNoYWRlcnMoZ2wsIG9wdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBnbCxcbiAgICB2czogYXNzZW1ibGVTaGFkZXIoZ2wsIG9wdHMpLFxuICAgIGZzOiBvcHRzLmZzXG4gIH07XG59XG4iXX0=