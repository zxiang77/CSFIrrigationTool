// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

export default "uniform float ONE;\n\nconst vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#else\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 quickTwoSum(float a, float b) {\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n  return vec2(sum, err);\n}\n#else\nvec2 quickTwoSum(float a, float b) {\n  float sum = a + b;\n  float err = b - (sum - a);\n  return vec2(sum, err);\n}\n#endif\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n\n/* The purpose of this workaround is to prevent compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' from.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be one only at the runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSum(float a, float b) {\n  float s = a + b;\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n  return vec2(s, err);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n/* Same thing as in twoSum() */\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSub(float a, float b) {\n  float s = a - b;\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n  return vec2(s, err);\n}\n#endif\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n  return vec2(prod, err);\n}\n#else\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n  return vec2(prod, err);\n}\n#endif\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n  prod.y += a.y * b.x;\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n  vec2 yn = a * xn;\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n  return sum_fp64(vec2(yn, 0.0), prod);\n}\n\n/* k_power controls how much range reduction we would like to have\nRange reduction uses the following method:\nassume a = k_power * r + m * log(2), k and m being integers.\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\n*/\n\nvec2 exp_fp64(vec2 a) {\n  // We need to make sure these two numbers match\n  // as bit-wise shift is not available in GLSL 1.0\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\n\n  s = sum_fp64(s, t);\n\n\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n//   return r;\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    // We just can't get PI/16 * 3.0 very accurately.\n    // so let's just store it\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\n// Vector functions\n// vec2 functions\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\n\n// vec3 functions\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\n\n// vec4 functions\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvZnA2NC9tYXRoLWZwNjQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJtYXRoLWZwNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbnVuaWZvcm0gZmxvYXQgT05FO1xuXG5jb25zdCB2ZWMyIEVfRlA2NCA9IHZlYzIoMi43MTgyODE3NDU5MTA2NDQ1ZSswMCwgOC4yNTQ4NDAzNjY4MTcwMDdlLTA4KTtcbmNvbnN0IHZlYzIgTE9HMl9GUDY0ID0gdmVjMigwLjY5MzE0NzE4MjQ2NDU5OTZlKzAwLCAtMS45MDQ2NTQyMTIxMjU5MzM2ZS0wOSk7XG5jb25zdCB2ZWMyIFBJX0ZQNjQgPSB2ZWMyKDMuMTQxNTkyNzQxMDEyNTczMiwgLTguNzQyMjc4MDEyNjE4OTU0ZS04KTtcbmNvbnN0IHZlYzIgVFdPX1BJX0ZQNjQgPSB2ZWMyKDYuMjgzMTg1NDgyMDI1MTQ2NSwgLTEuNzQ4NDU1NjAyNTIzNzkwN2UtNyk7XG5jb25zdCB2ZWMyIFBJXzJfRlA2NCA9IHZlYzIoMS41NzA3OTYzNzA1MDYyODY2LCAtNC4zNzExMzkwMDYzMDk0NzdlLTgpO1xuY29uc3QgdmVjMiBQSV80X0ZQNjQgPSB2ZWMyKDAuNzg1Mzk4MTg1MjUzMTQzMywgLTIuMTg1NTY5NTAzMTU0NzM4NGUtOCk7XG5jb25zdCB2ZWMyIFBJXzE2X0ZQNjQgPSB2ZWMyKDAuMTk2MzQ5NTQ2MzEzMjg1ODMsIC01LjQ2MzkyMzc1Nzg4Njg0NmUtOSk7XG5jb25zdCB2ZWMyIFBJXzE2XzJfRlA2NCA9IHZlYzIoMC4zOTI2OTkwOTI2MjY1NzE2NiwgLTEuMDkyNzg0NzUxNTc3MzY5MmUtOCk7XG5jb25zdCB2ZWMyIFBJXzE2XzNfRlA2NCA9IHZlYzIoMC41ODkwNDg2MjQwMzg2OTYzLCAtMS40OTA2MTAwNzk4MTI4ODE4ZS05KTtcbmNvbnN0IHZlYzIgUElfMTgwX0ZQNjQgPSB2ZWMyKDAuMDE3NDUzMjkyMzg0NzQzNjksIDEuMzUxOTk2MDQ5ODM2NDkwMmUtMTApO1xuXG5jb25zdCB2ZWMyIFNJTl9UQUJMRV8wX0ZQNjQgPSB2ZWMyKDAuMTk1MDkwMzIzNjg2NTk5NzMsIC0xLjY3MDQ3MTQ4MzM2MTUyNDJlLTkpO1xuY29uc3QgdmVjMiBTSU5fVEFCTEVfMV9GUDY0ID0gdmVjMigwLjM4MjY4MzQyNjE0MTczODksIDYuMjIzMzUwODkwMTc3NjdlLTkpO1xuY29uc3QgdmVjMiBTSU5fVEFCTEVfMl9GUDY0ID0gdmVjMigwLjU1NTU3MDI0NDc4OTEyMzUsIC0xLjE3Njk1MjEzNTc1MDc1MjllLTgpO1xuY29uc3QgdmVjMiBTSU5fVEFCTEVfM19GUDY0ID0gdmVjMigwLjcwNzEwNjc2OTA4NDkzMDQsIDEuMjEwMTYxNzA0MTc5MzEzM2UtOCk7XG5cbmNvbnN0IHZlYzIgQ09TX1RBQkxFXzBfRlA2NCA9IHZlYzIoMC45ODA3ODUyNTA2NjM3NTczLCAyLjk3Mzk0NzMxMDYzNjA0OTJlLTgpO1xuY29uc3QgdmVjMiBDT1NfVEFCTEVfMV9GUDY0ID0gdmVjMigwLjkyMzg3OTUwNDIwMzc5NjQsIDIuODMwNzQ5MDM1MTc2NDM4NmUtOCk7XG5jb25zdCB2ZWMyIENPU19UQUJMRV8yX0ZQNjQgPSB2ZWMyKDAuODMxNDY5NTk1NDMyMjgxNSwgMS42ODcwMjYzNzQxNTMwNzc4ZS04KTtcbmNvbnN0IHZlYzIgQ09TX1RBQkxFXzNfRlA2NCA9IHZlYzIoMC43MDcxMDY3NjkwODQ5MzA0LCAxLjIxMDE2MTcxNTI4MTU0MzZlLTgpO1xuXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzNfRlA2NCA9IHZlYzIoMS42NjY2NjY3MTYzMzcyMDRlLTAxLCAtNC45NjcwNTM4NzkzMTIyODllLTA5KTsgLy8gMS8zIVxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF80X0ZQNjQgPSB2ZWMyKDQuMTY2NjY2NzkwODQzMDFlLTAyLCAtMS4yNDE3NjM0Njk4MjgwNzIyZS0wOSk7IC8vIDEvNCFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNV9GUDY0ID0gdmVjMig4LjMzMzMzMzc2Nzk1MDUzNWUtMDMsIC00LjM0NjE3MjAzMzM3NTk1ZS0xMCk7IC8vIDEvNSFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNl9GUDY0ID0gdmVjMigxLjM4ODg4ODkyMjUxOTk4MTllLTAzLCAtMy4zNjMxMDk0NDM3MTAzMjE1ZS0xMSk7IC8vIDEvNiFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0ID0gdmVjMigxLjk4NDEyNzAxMTM4Mjk1MjNlLTA0LCAgLTIuNzI1NTk2ODc0OTMzNDU2ZS0xMik7IC8vIDEvNyFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfOF9GUDY0ID0gdmVjMigyLjQ4MDE1ODc2NDIyODY5MDRlLTA1LCAtMy40MDY5OTYwMjU5MDQxODRlLTEzKTsgLy8gMS84IVxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF85X0ZQNjQgPSB2ZWMyKDIuNzU1NzMxODg0NDYyODc1MzNlLTA2LCAzLjc5MzU3MTM5MzcwMzgxODZlLTE0KTsgLy8gMS85IVxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF8xMF9GUDY0ID0gdmVjMigyLjc1NTczMTk5ODE0OTcxM2UtMDcsIC03LjU3NTExMjM2Nzg2OTg3M2UtMTUpOyAvLyAxLzEwIVxuXG5mbG9hdCBuaW50KGZsb2F0IGQpIHtcbiAgICBpZiAoZCA9PSBmbG9vcihkKSkgcmV0dXJuIGQ7XG4gICAgcmV0dXJuIGZsb29yKGQgKyAwLjUpO1xufVxuXG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbnZlYzIgc3BsaXQoZmxvYXQgYSkge1xuICBjb25zdCBmbG9hdCBTUExJVCA9IDQwOTcuMDtcbiAgZmxvYXQgdCA9IGEgKiBTUExJVDtcbiAgZmxvYXQgYV9oaSA9IHQgKiBPTkUgLSAodCAtIGEpO1xuICBmbG9hdCBhX2xvID0gYSAqIE9ORSAtIGFfaGk7XG4gIHJldHVybiB2ZWMyKGFfaGksIGFfbG8pO1xufVxuI2Vsc2VcbnZlYzIgc3BsaXQoZmxvYXQgYSkge1xuICBjb25zdCBmbG9hdCBTUExJVCA9IDQwOTcuMDtcbiAgZmxvYXQgdCA9IGEgKiBTUExJVDtcbiAgZmxvYXQgYV9oaSA9IHQgLSAodCAtIGEpO1xuICBmbG9hdCBhX2xvID0gYSAtIGFfaGk7XG4gIHJldHVybiB2ZWMyKGFfaGksIGFfbG8pO1xufVxuI2VuZGlmXG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG52ZWMyIHF1aWNrVHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgc3VtID0gKGEgKyBiKSAqIE9ORTtcbiAgZmxvYXQgZXJyID0gYiAtIChzdW0gLSBhKSAqIE9ORTtcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xufVxuI2Vsc2VcbnZlYzIgcXVpY2tUd29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzdW0gPSBhICsgYjtcbiAgZmxvYXQgZXJyID0gYiAtIChzdW0gLSBhKTtcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xufVxuI2VuZGlmXG5cbnZlYzIgbmludF9mcDY0KHZlYzIgYSkge1xuICAgIGZsb2F0IGhpID0gbmludChhLngpO1xuICAgIGZsb2F0IGxvO1xuICAgIHZlYzIgdG1wO1xuICAgIGlmIChoaSA9PSBhLngpIHtcbiAgICAgICAgbG8gPSBuaW50KGEueSk7XG4gICAgICAgIHRtcCA9IHF1aWNrVHdvU3VtKGhpLCBsbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSAwLjA7XG4gICAgICAgIGlmIChhYnMoaGkgLSBhLngpID09IDAuNSAmJiBhLnkgPCAwLjApIHtcbiAgICAgICAgICAgIGhpIC09IDEuMDtcbiAgICAgICAgfVxuICAgICAgICB0bXAgPSB2ZWMyKGhpLCBsbyk7XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG59XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG5cbi8qIFRoZSBwdXJwb3NlIG9mIHRoaXMgd29ya2Fyb3VuZCBpcyB0byBwcmV2ZW50IGNvbXBpbGVycyBmcm9tXG5vcHRpbWl6aW5nIGF3YXkgbmVjZXNzYXJ5IGFyaXRobWV0aWMgb3BlcmF0aW9ucyBieSBzd2FwcGluZyB0aGVpciBzZXF1ZW5jZXNcbm9yIHRyYW5zZm9ybSB0aGUgZXF1YXRpb24gdG8gc29tZSAnZXF1aXZhbGVudCcgZnJvbS5cblxuVGhlIG1ldGhvZCBpcyB0byBtdWx0aXBseSBhbiBhcnRpZmljYWwgdmFyaWFibGUsIE9ORSwgd2hpY2ggd2lsbCBiZSBrbm93biB0b1xudGhlIGNvbXBpbGVyIHRvIGJlIG9uZSBvbmx5IGF0IHRoZSBydW50aW1lLiBUaGUgd2hvbGUgZXhwcmVzc2lvbiBpcyB0aGVuIHJlcHJlc2VudGVkXG5hcyBhIHBvbHlub21pYWwgd2l0aCByZXNwZWN0aXZlIHRvIE9ORS4gSW4gdGhlIGNvZWZmaWNpZW50cyBvZiBhbGwgdGVybXMsIG9ubHkgb25lIGFcbmFuZCBvbmUgYiBzaG91bGQgYXBwZWFyXG5cbmVyciA9IChhICsgYikgKiBPTkVeNiAtIGEgKiBPTkVeNSAtIChhICsgYikgKiBPTkVeNCArIGEgKiBPTkVeMyAtIGIgLSAoYSArIGIpICogT05FXjIgKyBhICogT05FXG4qL1xuXG52ZWMyIHR3b1N1bShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHMgPSAoYSArIGIpO1xuICBmbG9hdCB2ID0gKHMgKiBPTkUgLSBhKSAqIE9ORTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpICogT05FKSAqIE9ORSAqIE9ORSAqIE9ORSArIChiIC0gdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZWxzZVxudmVjMiB0d29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzID0gYSArIGI7XG4gIGZsb2F0IHYgPSBzIC0gYTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpKSArIChiIC0gdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZW5kaWZcblxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcbi8qIFNhbWUgdGhpbmcgYXMgaW4gdHdvU3VtKCkgKi9cbnZlYzIgdHdvU3ViKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgcyA9IChhIC0gYik7XG4gIGZsb2F0IHYgPSAocyAqIE9ORSAtIGEpICogT05FO1xuICBmbG9hdCBlcnIgPSAoYSAtIChzIC0gdikgKiBPTkUpICogT05FICogT05FICogT05FIC0gKGIgKyB2KTtcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcbn1cbiNlbHNlXG52ZWMyIHR3b1N1YihmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHMgPSBhIC0gYjtcbiAgZmxvYXQgdiA9IHMgLSBhO1xuICBmbG9hdCBlcnIgPSAoYSAtIChzIC0gdikpIC0gKGIgKyB2KTtcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcbn1cbiNlbmRpZlxuXG52ZWMyIHR3b1Byb2QoZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBwcm9kID0gYSAqIGI7XG4gIHZlYzIgYV9mcDY0ID0gc3BsaXQoYSk7XG4gIHZlYzIgYl9mcDY0ID0gc3BsaXQoYik7XG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBiX2ZwNjQueCAtIHByb2QpICsgYV9mcDY0LnggKiBiX2ZwNjQueSArXG4gICAgYV9mcDY0LnkgKiBiX2ZwNjQueCkgKyBhX2ZwNjQueSAqIGJfZnA2NC55O1xuICByZXR1cm4gdmVjMihwcm9kLCBlcnIpO1xufVxuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxudmVjMiB0d29TcXIoZmxvYXQgYSkge1xuICBmbG9hdCBwcm9kID0gYSAqIGE7XG4gIHZlYzIgYV9mcDY0ID0gc3BsaXQoYSk7XG5cbiAgZmxvYXQgZXJyID0gKChhX2ZwNjQueCAqIGFfZnA2NC54IC0gcHJvZCkgKiBPTkUgKyAyLjAgKiBhX2ZwNjQueCAqXG4gICAgYV9mcDY0LnkgKiBPTkUgKiBPTkUpICsgYV9mcDY0LnkgKiBhX2ZwNjQueSAqIE9ORSAqIE9ORSAqIE9ORTtcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcbn1cbiNlbHNlXG52ZWMyIHR3b1NxcihmbG9hdCBhKSB7XG4gIGZsb2F0IHByb2QgPSBhICogYTtcbiAgdmVjMiBhX2ZwNjQgPSBzcGxpdChhKTtcblxuICBmbG9hdCBlcnIgPSAoKGFfZnA2NC54ICogYV9mcDY0LnggLSBwcm9kKSArIDIuMCAqIGFfZnA2NC54ICogYV9mcDY0LnkpICsgYV9mcDY0LnkgKiBhX2ZwNjQueTtcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcbn1cbiNlbmRpZlxuXG52ZWMyIHN1bV9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XG4gIHZlYzIgcywgdDtcbiAgcyA9IHR3b1N1bShhLngsIGIueCk7XG4gIHQgPSB0d29TdW0oYS55LCBiLnkpO1xuICBzLnkgKz0gdC54O1xuICBzID0gcXVpY2tUd29TdW0ocy54LCBzLnkpO1xuICBzLnkgKz0gdC55O1xuICBzID0gcXVpY2tUd29TdW0ocy54LCBzLnkpO1xuICByZXR1cm4gcztcbn1cblxudmVjMiBzdWJfZnA2NCh2ZWMyIGEsIHZlYzIgYikge1xuICB2ZWMyIHMsIHQ7XG4gIHMgPSB0d29TdWIoYS54LCBiLngpO1xuICB0ID0gdHdvU3ViKGEueSwgYi55KTtcbiAgcy55ICs9IHQueDtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcy55ICs9IHQueTtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcmV0dXJuIHM7XG59XG5cbnZlYzIgbXVsX2ZwNjQodmVjMiBhLCB2ZWMyIGIpIHtcbiAgdmVjMiBwcm9kID0gdHdvUHJvZChhLngsIGIueCk7XG4gIC8vIHkgY29tcG9uZW50IGlzIGZvciB0aGUgZXJyb3JcbiAgcHJvZC55ICs9IGEueCAqIGIueTtcbiAgcHJvZC55ICs9IGEueSAqIGIueDtcbiAgcHJvZCA9IHF1aWNrVHdvU3VtKHByb2QueCwgcHJvZC55KTtcbiAgcmV0dXJuIHByb2Q7XG59XG5cbnZlYzIgZGl2X2ZwNjQodmVjMiBhLCB2ZWMyIGIpIHtcbiAgZmxvYXQgeG4gPSAxLjAgLyBiLng7XG4gIHZlYzIgeW4gPSBhICogeG47XG4gIGZsb2F0IGRpZmYgPSAoc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoYiwgeW4pKSkueDtcbiAgdmVjMiBwcm9kID0gdHdvUHJvZCh4biwgZGlmZik7XG4gIHJldHVybiBzdW1fZnA2NCh5biwgcHJvZCk7XG59XG5cbnZlYzIgc3FydF9mcDY0KHZlYzIgYSkge1xuXG4gIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgaWYgKGEueCA8IDAuMCkgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuXG4gIGZsb2F0IHggPSAxLjAgLyBzcXJ0KGEueCk7XG4gIGZsb2F0IHluID0gYS54ICogeDtcbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRlA2NF9XT1JLQVJPVU5EKVxuICB2ZWMyIHluX3NxciA9IHR3b1Nxcih5bikgKiBPTkU7XG4jZWxzZVxuICB2ZWMyIHluX3NxciA9IHR3b1Nxcih5bik7XG4jZW5kaWZcbiAgZmxvYXQgZGlmZiA9IHN1Yl9mcDY0KGEsIHluX3NxcikueDtcbiAgdmVjMiBwcm9kID0gdHdvUHJvZCh4ICogMC41LCBkaWZmKTtcbiAgcmV0dXJuIHN1bV9mcDY0KHZlYzIoeW4sIDAuMCksIHByb2QpO1xufVxuXG4vKiBrX3Bvd2VyIGNvbnRyb2xzIGhvdyBtdWNoIHJhbmdlIHJlZHVjdGlvbiB3ZSB3b3VsZCBsaWtlIHRvIGhhdmVcblJhbmdlIHJlZHVjdGlvbiB1c2VzIHRoZSBmb2xsb3dpbmcgbWV0aG9kOlxuYXNzdW1lIGEgPSBrX3Bvd2VyICogciArIG0gKiBsb2coMiksIGsgYW5kIG0gYmVpbmcgaW50ZWdlcnMuXG5TZXQga19wb3dlciA9IDQgKHdlIGNhbiBjaG9vc2Ugb3RoZXIgayB0byB0cmFkZSBhY2N1cmFjeSB3aXRoIHBlcmZvcm1hbmNlLlxud2Ugb25seSBuZWVkIHRvIGNhbGN1bGF0ZSBleHAocikgYW5kIHVzaW5nIGV4cChhKSA9IDJebSAqIGV4cChyKV5rX3Bvd2VyO1xuKi9cblxudmVjMiBleHBfZnA2NCh2ZWMyIGEpIHtcbiAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlc2UgdHdvIG51bWJlcnMgbWF0Y2hcbiAgLy8gYXMgYml0LXdpc2Ugc2hpZnQgaXMgbm90IGF2YWlsYWJsZSBpbiBHTFNMIDEuMFxuICBjb25zdCBpbnQga19wb3dlciA9IDQ7XG4gIGNvbnN0IGZsb2F0IGsgPSAxNi4wO1xuXG4gIGNvbnN0IGZsb2F0IGludl9rID0gMS4wIC8gaztcblxuICBpZiAoYS54IDw9IC04OC4wKSByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gIGlmIChhLnggPj0gODguMCkgcmV0dXJuIHZlYzIoMS4wIC8gMC4wLCAxLjAgLyAwLjApO1xuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSByZXR1cm4gdmVjMigxLjAsIDAuMCk7XG4gIGlmIChhLnggPT0gMS4wICYmIGEueSA9PSAwLjApIHJldHVybiBFX0ZQNjQ7XG5cbiAgZmxvYXQgbSA9IGZsb29yKGEueCAvIExPRzJfRlA2NC54ICsgMC41KTtcbiAgdmVjMiByID0gc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoTE9HMl9GUDY0LCB2ZWMyKG0sIDAuMCkpKSAqIGludl9rO1xuICB2ZWMyIHMsIHQsIHA7XG5cbiAgcCA9IG11bF9mcDY0KHIsIHIpO1xuICBzID0gc3VtX2ZwNjQociwgcCAqIDAuNSk7XG4gIHAgPSBtdWxfZnA2NChwLCByKTtcbiAgdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzNfRlA2NCk7XG5cbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuICBwID0gbXVsX2ZwNjQocCwgcik7XG4gIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF80X0ZQNjQpO1xuXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcbiAgcCA9IG11bF9mcDY0KHAsIHIpO1xuICB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfNV9GUDY0KTtcblxuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XG4gIC8vIHAgPSBtdWxfZnA2NChwLCByKTtcbiAgLy8gdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzZfRlA2NCk7XG5cbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuICAvLyBwID0gbXVsX2ZwNjQocCwgcik7XG4gIC8vIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF83X0ZQNjQpO1xuXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHMgPSBleHAocikgLSAxOyBidXQgYWZ0ZXIgZm9sbG93aW5nIDQgcmVjdXJzaW9ucywgd2Ugd2lsbCBnZXQgZXhwKHIpIF4gNTEyIC0gMS5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBrX3Bvd2VyOyBpKyspIHtcbiAgICBzID0gc3VtX2ZwNjQocyAqIDIuMCwgbXVsX2ZwNjQocywgcykpO1xuICB9XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRlA2NF9XT1JLQVJPVU5EKVxuICBzID0gc3VtX2ZwNjQocywgdmVjMihPTkUsIDAuMCkpO1xuI2Vsc2VcbiAgcyA9IHN1bV9mcDY0KHMsIHZlYzIoMS4wLCAwLjApKTtcbiNlbmRpZlxuXG4gIHJldHVybiBzICogcG93KDIuMCwgbSk7XG4vLyAgIHJldHVybiByO1xufVxuXG52ZWMyIGxvZ19mcDY0KHZlYzIgYSlcbntcbiAgaWYgKGEueCA9PSAxLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xuICBpZiAoYS54IDw9IDAuMCkgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICB2ZWMyIHggPSB2ZWMyKGxvZyhhLngpLCAwLjApO1xuICB2ZWMyIHM7XG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbiAgcyA9IHZlYzIoT05FLCAwLjApO1xuI2Vsc2VcbiAgcyA9IHZlYzIoMS4wLCAwLjApO1xuI2VuZGlmXG5cbiAgeCA9IHN1Yl9mcDY0KHN1bV9mcDY0KHgsIG11bF9mcDY0KGEsIGV4cF9mcDY0KC14KSkpLCBzKTtcbiAgcmV0dXJuIHg7XG59XG5cbnZlYzIgc2luX3RheWxvcl9mcDY0KHZlYzIgYSkge1xuICB2ZWMyIHIsIHMsIHQsIHg7XG5cbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgfVxuXG4gIHggPSAtbXVsX2ZwNjQoYSwgYSk7XG4gIHMgPSBhO1xuICByID0gYTtcblxuICByID0gbXVsX2ZwNjQociwgeCk7XG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQpO1xuICBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgciA9IG11bF9mcDY0KHIsIHgpO1xuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfNV9GUDY0KTtcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIC8qIGtlZXAgdGhlIGZvbGxvd2luZyBjb21tZW50ZWQgY29kZSBpbiBjYXNlIHdlIG5lZWQgdGhlbVxuICBmb3IgZXh0cmEgYWNjdXJhY3kgZnJvbSB0aGUgVGF5bG9yIGV4cGFuc2lvbiovXG5cbiAgLy8gciA9IG11bF9mcDY0KHIsIHgpO1xuICAvLyB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0KTtcbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgLy8gdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzlfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICByZXR1cm4gcztcbn1cblxudmVjMiBjb3NfdGF5bG9yX2ZwNjQodmVjMiBhKSB7XG4gIHZlYzIgciwgcywgdCwgeDtcblxuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XG4gICAgcmV0dXJuIHZlYzIoMS4wLCAwLjApO1xuICB9XG5cbiAgeCA9IC1tdWxfZnA2NChhLCBhKTtcbiAgciA9IHg7XG4gIHMgPSBzdW1fZnA2NCh2ZWMyKDEuMCwgMC4wKSwgciAqIDAuNSk7XG5cbiAgciA9IG11bF9mcDY0KHIsIHgpO1xuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0KTtcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzZfRlA2NCk7XG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvKiBrZWVwIHRoZSBmb2xsb3dpbmcgY29tbWVudGVkIGNvZGUgaW4gY2FzZSB3ZSBuZWVkIHRoZW1cbiAgZm9yIGV4dHJhIGFjY3VyYWN5IGZyb20gdGhlIFRheWxvciBleHBhbnNpb24qL1xuXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgLy8gdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzhfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvLyByID0gbXVsX2ZwNjQociwgeCk7XG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF8xMF9GUDY0KTtcbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIHJldHVybiBzO1xufVxuXG52b2lkIHNpbmNvc190YXlsb3JfZnA2NCh2ZWMyIGEsIG91dCB2ZWMyIHNpbl90LCBvdXQgdmVjMiBjb3NfdCkge1xuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XG4gICAgc2luX3QgPSB2ZWMyKDAuMCwgMC4wKTtcbiAgICBjb3NfdCA9IHZlYzIoMS4wLCAwLjApO1xuICB9XG5cbiAgc2luX3QgPSBzaW5fdGF5bG9yX2ZwNjQoYSk7XG4gIGNvc190ID0gc3FydF9mcDY0KHN1Yl9mcDY0KHZlYzIoMS4wLCAwLjApLCBtdWxfZnA2NChzaW5fdCwgc2luX3QpKSk7XG59XG5cbnZlYzIgc2luX2ZwNjQodmVjMiBhKSB7XG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XG5cbiAgICB2ZWMyIHQ7XG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgaiA9IGludChxKTtcblxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICAgIH1cblxuICAgIHQgPSBzdWJfZnA2NChyLCBtdWxfZnA2NChQSV8yX0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuXG4gICAgcSA9IGZsb29yKHQueCAvIFBJXzE2X0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGsgPSBpbnQocSk7XG5cbiAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgIGlmIChqID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5fdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC1zaW5fdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XG5cbiAgICBpZiAoYWJzX2sgPiA0KSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgbXVsX2ZwNjQoUElfMTZfRlA2NCwgdmVjMihxLCAwLjApKSk7XG4gICAgfVxuXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgdmVjMiB2ID0gdmVjMigwLjAsIDAuMCk7XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG4gICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZWxzZVxuICAgIGlmIChhYnNfayA9PSAxKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZW5kaWZcblxuICAgIHZlYzIgc2luX3QsIGNvc190O1xuICAgIHNpbmNvc190YXlsb3JfZnA2NCh0LCBzaW5fdCwgY29zX3QpO1xuXG5cblxuICAgIHZlYzIgcmVzdWx0ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgc2luX3QpLCBtdWxfZnA2NCh1LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHYsIHNpbl90KSwgbXVsX2ZwNjQodSwgY29zX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIGNvc190KSwgbXVsX2ZwNjQodSwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZlYzIgY29zX2ZwNjQodmVjMiBhKSB7XG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgICAgICByZXR1cm4gdmVjMigxLjAsIDAuMCk7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XG5cbiAgICB2ZWMyIHQ7XG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgaiA9IGludChxKTtcblxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICAgIH1cblxuICAgIHQgPSBzdWJfZnA2NChyLCBtdWxfZnA2NChQSV8yX0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuXG4gICAgcSA9IGZsb29yKHQueCAvIFBJXzE2X0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGsgPSBpbnQocSk7XG5cbiAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgIGlmIChqID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb3NfdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gLXNpbl90YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC1jb3NfdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XG5cbiAgICBpZiAoYWJzX2sgPiA0KSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgbXVsX2ZwNjQoUElfMTZfRlA2NCwgdmVjMihxLCAwLjApKSk7XG4gICAgfVxuXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgdmVjMiB2ID0gdmVjMigwLjAsIDAuMCk7XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG4gICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZWxzZVxuICAgIGlmIChhYnNfayA9PSAxKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZW5kaWZcblxuICAgIHZlYzIgc2luX3QsIGNvc190O1xuICAgIHNpbmNvc190YXlsb3JfZnA2NCh0LCBzaW5fdCwgY29zX3QpO1xuXG4gICAgdmVjMiByZXN1bHQgPSB2ZWMyKDAuMCwgMC4wKTtcbiAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChqID09IDEpIHtcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAtc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgY29zX3QpLCBtdWxfZnA2NCh1LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBzaW5fdCksIG11bF9mcDY0KHUsIGNvc190KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAtc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmVjMiB0YW5fZnA2NCh2ZWMyIGEpIHtcbiAgICB2ZWMyIHNpbl9hO1xuICAgIHZlYzIgY29zX2E7XG5cbiAgICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgICB9XG5cbiAgICAvLyAycGkgcmFuZ2UgcmVkdWN0aW9uXG4gICAgdmVjMiB6ID0gbmludF9mcDY0KGRpdl9mcDY0KGEsIFRXT19QSV9GUDY0KSk7XG4gICAgdmVjMiByID0gc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoVFdPX1BJX0ZQNjQsIHopKTtcblxuICAgIHZlYzIgdDtcbiAgICBmbG9hdCBxID0gZmxvb3Ioci54IC8gUElfMl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBqID0gaW50KHEpO1xuXG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9XG5cbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcblxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcblxuICAgIC8vIFdlIGp1c3QgY2FuJ3QgZ2V0IFBJLzE2ICogMy4wIHZlcnkgYWNjdXJhdGVseS5cbiAgICAvLyBzbyBsZXQncyBqdXN0IHN0b3JlIGl0XG4gICAgaWYgKGFic19rID4gNCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuICAgIH1cblxuXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgdmVjMiB2ID0gdmVjMigwLjAsIDAuMCk7XG5cbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcbiAgICB2ZWMyIHMsIGM7XG4gICAgc2luY29zX3RheWxvcl9mcDY0KHQsIHNpbl90LCBjb3NfdCk7XG5cbiAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgIHMgPSBzaW5fdDtcbiAgICAgICAgYyA9IGNvc190O1xuICAgIH0gZWxzZSB7XG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuICAgICAgICBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDEuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDIuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDMuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDQuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgICAgIH1cbiNlbHNlXG4gICAgICAgIGlmIChhYnNfayA9PSAxKSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMF9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfM19GUDY0O1xuICAgICAgICB9XG4jZW5kaWZcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICBzID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICAgICAgYyA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgICAgICBjID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBzaW5fYSA9IHM7XG4gICAgICAgIGNvc19hID0gYztcbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICBzaW5fYSA9IGM7XG4gICAgICAgIGNvc19hID0gLXM7XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIHNpbl9hID0gLWM7XG4gICAgICAgIGNvc19hID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5fYSA9IC1zO1xuICAgICAgICBjb3NfYSA9IC1jO1xuICAgIH1cbiAgICByZXR1cm4gZGl2X2ZwNjQoc2luX2EsIGNvc19hKTtcbn1cblxudmVjMiByYWRpYW5zX2ZwNjQodmVjMiBkZWdyZWUpIHtcbiAgcmV0dXJuIG11bF9mcDY0KGRlZ3JlZSwgUElfMTgwX0ZQNjQpO1xufVxuXG52ZWMyIG1peF9mcDY0KHZlYzIgYSwgdmVjMiBiLCBmbG9hdCB4KSB7XG4gIHZlYzIgcmFuZ2UgPSBzdWJfZnA2NChiLCBhKTtcbiAgcmV0dXJuIHN1bV9mcDY0KGEsIG11bF9mcDY0KHJhbmdlLCB2ZWMyKHgsIDAuMCkpKTtcbn1cblxuLy8gVmVjdG9yIGZ1bmN0aW9uc1xuLy8gdmVjMiBmdW5jdGlvbnNcbnZvaWQgdmVjMl9zdW1fZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBzdW1fZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gc3VtX2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9zdWJfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBzdWJfZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gc3ViX2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9tdWxfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBtdWxfZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gbXVsX2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9kaXZfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBkaXZfZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gZGl2X2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9taXhfZnA2NCh2ZWMyIHhbMl0sIHZlYzIgeVsyXSwgZmxvYXQgYSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICB2ZWMyIHJhbmdlWzJdO1xuICB2ZWMyX3N1Yl9mcDY0KHksIHgsIHJhbmdlKTtcbiAgdmVjMiBwb3J0aW9uWzJdO1xuICBwb3J0aW9uWzBdID0gcmFuZ2VbMF0gKiBhO1xuICBwb3J0aW9uWzFdID0gcmFuZ2VbMV0gKiBhO1xuICB2ZWMyX3N1bV9mcDY0KHgsIHBvcnRpb24sIG91dF92YWwpO1xufVxuXG52ZWMyIHZlYzJfbGVuZ3RoX2ZwNjQodmVjMiB4WzJdKSB7XG4gIHJldHVybiBzcXJ0X2ZwNjQoc3VtX2ZwNjQobXVsX2ZwNjQoeFswXSwgeFswXSksIG11bF9mcDY0KHhbMV0sIHhbMV0pKSk7XG59XG5cbnZvaWQgdmVjMl9ub3JtYWxpemVfZnA2NCh2ZWMyIHhbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgdmVjMiBsZW5ndGggPSB2ZWMyX2xlbmd0aF9mcDY0KHgpO1xuICB2ZWMyIGxlbmd0aF92ZWMyWzJdO1xuICBsZW5ndGhfdmVjMlswXSA9IGxlbmd0aDtcbiAgbGVuZ3RoX3ZlYzJbMV0gPSBsZW5ndGg7XG5cbiAgdmVjMl9kaXZfZnA2NCh4LCBsZW5ndGhfdmVjMiwgb3V0X3ZhbCk7XG59XG5cbnZlYzIgdmVjMl9kaXN0YW5jZV9mcDY0KHZlYzIgeFsyXSwgdmVjMiB5WzJdKSB7XG4gIHZlYzIgZGlmZlsyXTtcbiAgdmVjMl9zdWJfZnA2NCh4LCB5LCBkaWZmKTtcbiAgcmV0dXJuIHZlYzJfbGVuZ3RoX2ZwNjQoZGlmZik7XG59XG5cbnZlYzIgdmVjMl9kb3RfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSkge1xuICB2ZWMyIHZbMl07XG5cbiAgdlswXSA9IG11bF9mcDY0KGFbMF0sIGJbMF0pO1xuICB2WzFdID0gbXVsX2ZwNjQoYVsxXSwgYlsxXSk7XG5cbiAgcmV0dXJuIHN1bV9mcDY0KHZbMF0sIHZbMV0pO1xufVxuXG4vLyB2ZWMzIGZ1bmN0aW9uc1xudm9pZCB2ZWMzX3N1Yl9mcDY0KHZlYzIgYVszXSwgdmVjMiBiWzNdLCBvdXQgdmVjMiBvdXRfdmFsWzNdKSB7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgb3V0X3ZhbFtpXSA9IHN1bV9mcDY0KGFbaV0sIGJbaV0pO1xuICB9XG59XG5cbnZvaWQgdmVjM19zdW1fZnA2NCh2ZWMyIGFbM10sIHZlYzIgYlszXSwgb3V0IHZlYzIgb3V0X3ZhbFszXSkge1xuICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcbiAgfVxufVxuXG52ZWMyIHZlYzNfbGVuZ3RoX2ZwNjQodmVjMiB4WzNdKSB7XG4gIHJldHVybiBzcXJ0X2ZwNjQoc3VtX2ZwNjQoc3VtX2ZwNjQobXVsX2ZwNjQoeFswXSwgeFswXSksIG11bF9mcDY0KHhbMV0sIHhbMV0pKSxcbiAgICBtdWxfZnA2NCh4WzJdLCB4WzJdKSkpO1xufVxuXG52ZWMyIHZlYzNfZGlzdGFuY2VfZnA2NCh2ZWMyIHhbM10sIHZlYzIgeVszXSkge1xuICB2ZWMyIGRpZmZbM107XG4gIHZlYzNfc3ViX2ZwNjQoeCwgeSwgZGlmZik7XG4gIHJldHVybiB2ZWMzX2xlbmd0aF9mcDY0KGRpZmYpO1xufVxuXG4vLyB2ZWM0IGZ1bmN0aW9uc1xudm9pZCB2ZWM0X2ZwNjQodmVjNCBhLCBvdXQgdmVjMiBvdXRfdmFsWzRdKSB7XG4gIG91dF92YWxbMF0ueCA9IGFbMF07XG4gIG91dF92YWxbMF0ueSA9IDAuMDtcblxuICBvdXRfdmFsWzFdLnggPSBhWzFdO1xuICBvdXRfdmFsWzFdLnkgPSAwLjA7XG5cbiAgb3V0X3ZhbFsyXS54ID0gYVsyXTtcbiAgb3V0X3ZhbFsyXS55ID0gMC4wO1xuXG4gIG91dF92YWxbM10ueCA9IGFbM107XG4gIG91dF92YWxbM10ueSA9IDAuMDtcbn1cblxudm9pZCB2ZWM0X3NjYWxhcl9tdWxfZnA2NCh2ZWMyIGFbNF0sIHZlYzIgYiwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICBvdXRfdmFsWzBdID0gbXVsX2ZwNjQoYVswXSwgYik7XG4gIG91dF92YWxbMV0gPSBtdWxfZnA2NChhWzFdLCBiKTtcbiAgb3V0X3ZhbFsyXSA9IG11bF9mcDY0KGFbMl0sIGIpO1xuICBvdXRfdmFsWzNdID0gbXVsX2ZwNjQoYVszXSwgYik7XG59XG5cbnZvaWQgdmVjNF9zdW1fZnA2NCh2ZWMyIGFbNF0sIHZlYzIgYls0XSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcbiAgfVxufVxuXG52b2lkIHZlYzRfZG90X2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGJbNF0sIG91dCB2ZWMyIG91dF92YWwpIHtcbiAgdmVjMiB2WzRdO1xuXG4gIHZbMF0gPSBtdWxfZnA2NChhWzBdLCBiWzBdKTtcbiAgdlsxXSA9IG11bF9mcDY0KGFbMV0sIGJbMV0pO1xuICB2WzJdID0gbXVsX2ZwNjQoYVsyXSwgYlsyXSk7XG4gIHZbM10gPSBtdWxfZnA2NChhWzNdLCBiWzNdKTtcblxuICBvdXRfdmFsID0gc3VtX2ZwNjQoc3VtX2ZwNjQodlswXSwgdlsxXSksIHN1bV9mcDY0KHZbMl0sIHZbM10pKTtcbn1cblxudm9pZCBtYXQ0X3ZlYzRfbXVsX2ZwNjQodmVjMiBiWzE2XSwgdmVjMiBhWzRdLCBvdXQgdmVjMiBvdXRfdmFsWzRdKSB7XG4gIHZlYzIgdG1wWzRdO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKVxuICB7XG4gICAgZm9yIChpbnQgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgdG1wW2pdID0gYltqICsgaSAqIDRdO1xuICAgIH1cbiAgICB2ZWM0X2RvdF9mcDY0KGEsIHRtcCwgb3V0X3ZhbFtpXSk7XG4gIH1cbn1cbmA7XG4iXX0=