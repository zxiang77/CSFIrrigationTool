// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

export default "const float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\n\n// ref: lib/constants.js\nconst float PROJECT_IDENTITY = 0.;\nconst float PROJECT_MERCATOR = 1.;\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\n\nuniform float projectionMode;\nuniform float projectionScale;\nuniform vec4 projectionCenter;\nuniform vec3 projectionPixelsPerUnit;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 projectionMatrixUncentered;\n\n#ifdef INTEL_TAN_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef INTEL_TAN_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n\n//\n// Scaling offsets\n//\n\nfloat project_scale(float meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return meters * projectionPixelsPerUnit.x;\n  }\n}\n\nvec2 project_scale(vec2 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec2(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec3 project_scale(vec3 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec3(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec4 project_scale(vec4 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec4(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x,\n      meters.w\n    );\n  }\n}\n\n//\n// Projecting positions\n//\n\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\nvec2 project_mercator_(vec2 lnglat) {\n  return vec2(\n    radians(lnglat.x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nvec2 project_position(vec2 position) {\n  if (projectionMode == PROJECT_IDENTITY) {\n    return position;\n  }\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return position;\n    return project_scale(position);\n  }\n  // Covers projectionMode == PROJECT_MERCATOR\n  return project_mercator_(position) * WORLD_SCALE * projectionScale;\n}\n\nvec3 project_position(vec3 position) {\n  return vec3(project_position(position.xy), project_scale(position.z));\n}\n\nvec4 project_position(vec4 position) {\n  return vec4(project_position(position.xyz), position.w);\n}\n\n//\n\nvec4 project_to_viewspace(vec4 position) {\n  return modelViewMatrix * position;\n}\n\nvec4 project_to_clipspace(vec4 position) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    position = position * projectionPixelsPerUnit.x;\n  }\n  return projectionMatrix * position + projectionCenter;\n}\n\n// Backwards compatibility\n\nfloat scale(float position) {\n  return project_scale(position);\n}\n\nvec2 scale(vec2 position) {\n  return project_scale(position);\n}\n\nvec3 scale(vec3 position) {\n  return project_scale(position);\n}\n\nvec4 scale(vec4 position) {\n  return project_scale(position);\n}\n\nvec2 preproject(vec2 position) {\n  return project_position(position);\n}\n\nvec3 preproject(vec3 position) {\n  return project_position(position);\n}\n\nvec4 preproject(vec4 position) {\n  return project_position(position);\n}\n\nvec4 project(vec4 position) {\n  return project_to_clipspace(position);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9wcm9qZWN0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoicHJvamVjdC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuY29uc3QgZmxvYXQgVElMRV9TSVpFID0gNTEyLjA7XG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNjtcbmNvbnN0IGZsb2F0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFIC8gKFBJICogMi4wKTtcblxuLy8gcmVmOiBsaWIvY29uc3RhbnRzLmpzXG5jb25zdCBmbG9hdCBQUk9KRUNUX0lERU5USVRZID0gMC47XG5jb25zdCBmbG9hdCBQUk9KRUNUX01FUkNBVE9SID0gMS47XG5jb25zdCBmbG9hdCBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMgPSAyLjtcblxudW5pZm9ybSBmbG9hdCBwcm9qZWN0aW9uTW9kZTtcbnVuaWZvcm0gZmxvYXQgcHJvamVjdGlvblNjYWxlO1xudW5pZm9ybSB2ZWM0IHByb2plY3Rpb25DZW50ZXI7XG51bmlmb3JtIHZlYzMgcHJvamVjdGlvblBpeGVsc1BlclVuaXQ7XG5cbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDtcblxuI2lmZGVmIElOVEVMX1RBTl9XT1JLQVJPVU5EXG5cbi8vIEFsbCB0aGVzZSBmdW5jdGlvbnMgYXJlIGZvciBzdWJzdGl0dXRpbmcgdGFuKCkgZnVuY3Rpb24gZnJvbSBJbnRlbCBHUFUgb25seVxuY29uc3QgZmxvYXQgVFdPX1BJID0gNi4yODMxODU0ODIwMjUxNDY1O1xuY29uc3QgZmxvYXQgUElfMiA9IDEuNTcwNzk2MzcwNTA2Mjg2NjtcbmNvbnN0IGZsb2F0IFBJXzE2ID0gMC4xOTYzNDk1NDYzMTMyODU4O1xuXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMCA9IDAuMTk1MDkwMzIzNjg2NTk5NzM7XG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMSA9IDAuMzgyNjgzNDI2MTQxNzM4OTtcbmNvbnN0IGZsb2F0IFNJTl9UQUJMRV8yID0gMC41NTU1NzAyNDQ3ODkxMjM1O1xuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XG5cbmNvbnN0IGZsb2F0IENPU19UQUJMRV8wID0gMC45ODA3ODUyNTA2NjM3NTczO1xuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzEgPSAwLjkyMzg3OTUwNDIwMzc5NjQ7XG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMiA9IDAuODMxNDY5NTk1NDMyMjgxNTtcbmNvbnN0IGZsb2F0IENPU19UQUJMRV8zID0gMC43MDcxMDY3NjkwODQ5MzA0O1xuXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF8zID0gMS42NjY2NjY3MTYzMzcyMDRlLTAxOyAvLyAxLzMhXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF81ID0gOC4zMzMzMzM3Njc5NTA1MzVlLTAzOyAvLyAxLzUhXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF83ID0gMS45ODQxMjcwMTEzODI5NTIzZS0wNDsgLy8gMS83IVxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfOSA9IDIuNzU1NzMxODg0NDYyODc1MzNlLTA2OyAvLyAxLzkhXG5cbmZsb2F0IHNpbl90YXlsb3JfZnAzMihmbG9hdCBhKSB7XG4gIGZsb2F0IHIsIHMsIHQsIHg7XG5cbiAgaWYgKGEgPT0gMC4wKSB7XG4gICAgcmV0dXJuIDAuMDtcbiAgfVxuXG4gIHggPSAtYSAqIGE7XG4gIHMgPSBhO1xuICByID0gYTtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfMztcbiAgcyA9IHMgKyB0O1xuXG4gIHIgPSByICogeDtcbiAgdCA9IHIgKiBJTlZFUlNFX0ZBQ1RPUklBTF81O1xuICBzID0gcyArIHQ7XG5cbiAgciA9IHIgKiB4O1xuICB0ID0gciAqIElOVkVSU0VfRkFDVE9SSUFMXzc7XG4gIHMgPSBzICsgdDtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfOTtcbiAgcyA9IHMgKyB0O1xuXG4gIHJldHVybiBzO1xufVxuXG52b2lkIHNpbmNvc190YXlsb3JfZnAzMihmbG9hdCBhLCBvdXQgZmxvYXQgc2luX3QsIG91dCBmbG9hdCBjb3NfdCkge1xuICBpZiAoYSA9PSAwLjApIHtcbiAgICBzaW5fdCA9IDAuMDtcbiAgICBjb3NfdCA9IDEuMDtcbiAgfVxuICBzaW5fdCA9IHNpbl90YXlsb3JfZnAzMihhKTtcbiAgY29zX3QgPSBzcXJ0KDEuMCAtIHNpbl90ICogc2luX3QpO1xufVxuXG5mbG9hdCB0YW5fdGF5bG9yX2ZwMzIoZmxvYXQgYSkge1xuICAgIGZsb2F0IHNpbl9hO1xuICAgIGZsb2F0IGNvc19hO1xuXG4gICAgaWYgKGEgPT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIGZsb2F0IHogPSBmbG9vcihhIC8gVFdPX1BJKTtcbiAgICBmbG9hdCByID0gYSAtIFRXT19QSSAqIHo7XG5cbiAgICBmbG9hdCB0O1xuICAgIGZsb2F0IHEgPSBmbG9vcihyIC8gUElfMiArIDAuNSk7XG4gICAgaW50IGogPSBpbnQocSk7XG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiAwLjAgLyAwLjA7XG4gICAgfVxuXG4gICAgdCA9IHIgLSBQSV8yICogcTtcblxuICAgIHEgPSBmbG9vcih0IC8gUElfMTYgKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcblxuICAgIGlmIChhYnNfayA+IDQpIHtcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdCAtIFBJXzE2ICogcTtcbiAgICB9XG5cbiAgICBmbG9hdCB1ID0gMC4wO1xuICAgIGZsb2F0IHYgPSAwLjA7XG5cbiAgICBmbG9hdCBzaW5fdCwgY29zX3Q7XG4gICAgZmxvYXQgcywgYztcbiAgICBzaW5jb3NfdGF5bG9yX2ZwMzIodCwgc2luX3QsIGNvc190KTtcblxuICAgIGlmIChrID09IDApIHtcbiAgICAgICAgcyA9IHNpbl90O1xuICAgICAgICBjID0gY29zX3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzA7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzA7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDIuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMTtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMTtcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yO1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yO1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzM7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICBzID0gdSAqIHNpbl90ICsgdiAqIGNvc190O1xuICAgICAgICAgICAgYyA9IHUgKiBjb3NfdCAtIHYgKiBzaW5fdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSB1ICogc2luX3QgLSB2ICogY29zX3Q7XG4gICAgICAgICAgICBjID0gdSAqIGNvc190ICsgdiAqIHNpbl90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBzaW5fYSA9IHM7XG4gICAgICAgIGNvc19hID0gYztcbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICBzaW5fYSA9IGM7XG4gICAgICAgIGNvc19hID0gLXM7XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIHNpbl9hID0gLWM7XG4gICAgICAgIGNvc19hID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5fYSA9IC1zO1xuICAgICAgICBjb3NfYSA9IC1jO1xuICAgIH1cbiAgICByZXR1cm4gc2luX2EgLyBjb3NfYTtcbn1cbiNlbmRpZlxuXG5mbG9hdCB0YW5fZnAzMihmbG9hdCBhKSB7XG4jaWZkZWYgSU5URUxfVEFOX1dPUktBUk9VTkRcbiAgcmV0dXJuIHRhbl90YXlsb3JfZnAzMihhKTtcbiNlbHNlXG4gIHJldHVybiB0YW4oYSk7XG4jZW5kaWZcbn1cblxuLy9cbi8vIFNjYWxpbmcgb2Zmc2V0c1xuLy9cblxuZmxvYXQgcHJvamVjdF9zY2FsZShmbG9hdCBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1ldGVycyAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XG4gIH1cbn1cblxudmVjMiBwcm9qZWN0X3NjYWxlKHZlYzIgbWV0ZXJzKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICByZXR1cm4gbWV0ZXJzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2ZWMyKFxuICAgICAgbWV0ZXJzLnggKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54XG4gICAgKTtcbiAgfVxufVxuXG52ZWMzIHByb2plY3Rfc2NhbGUodmVjMyBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZlYzMoXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueSAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LnhcbiAgICApO1xuICB9XG59XG5cbnZlYzQgcHJvamVjdF9zY2FsZSh2ZWM0IG1ldGVycykge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcmV0dXJuIG1ldGVycztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmVjNChcbiAgICAgIG1ldGVycy54ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy55ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy56ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy53XG4gICAgKTtcbiAgfVxufVxuXG4vL1xuLy8gUHJvamVjdGluZyBwb3NpdGlvbnNcbi8vXG5cbi8vIG5vbi1saW5lYXIgcHJvamVjdGlvbjogbG5nbGF0cyA9PiB1bml0IHRpbGUgWzAtMSwgMC0xXVxudmVjMiBwcm9qZWN0X21lcmNhdG9yXyh2ZWMyIGxuZ2xhdCkge1xuICByZXR1cm4gdmVjMihcbiAgICByYWRpYW5zKGxuZ2xhdC54KSArIFBJLFxuICAgIFBJIC0gbG9nKHRhbl9mcDMyKFBJICogMC4yNSArIHJhZGlhbnMobG5nbGF0LnkpICogMC41KSlcbiAgKTtcbn1cblxudmVjMiBwcm9qZWN0X3Bvc2l0aW9uKHZlYzIgcG9zaXRpb24pIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfSURFTlRJVFkpIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XG4gIH1cbiAgLy8gQ292ZXJzIHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JcbiAgcmV0dXJuIHByb2plY3RfbWVyY2F0b3JfKHBvc2l0aW9uKSAqIFdPUkxEX1NDQUxFICogcHJvamVjdGlvblNjYWxlO1xufVxuXG52ZWMzIHByb2plY3RfcG9zaXRpb24odmVjMyBwb3NpdGlvbikge1xuICByZXR1cm4gdmVjMyhwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uLnh5KSwgcHJvamVjdF9zY2FsZShwb3NpdGlvbi56KSk7XG59XG5cbnZlYzQgcHJvamVjdF9wb3NpdGlvbih2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiB2ZWM0KHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24ueHl6KSwgcG9zaXRpb24udyk7XG59XG5cbi8vXG5cbnZlYzQgcHJvamVjdF90b192aWV3c3BhY2UodmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gbW9kZWxWaWV3TWF0cml4ICogcG9zaXRpb247XG59XG5cbnZlYzQgcHJvamVjdF90b19jbGlwc3BhY2UodmVjNCBwb3NpdGlvbikge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XG4gIH1cbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXggKiBwb3NpdGlvbiArIHByb2plY3Rpb25DZW50ZXI7XG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbmZsb2F0IHNjYWxlKGZsb2F0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMiBzY2FsZSh2ZWMyIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMyBzY2FsZSh2ZWMzIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjNCBzY2FsZSh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMiBwcmVwcm9qZWN0KHZlYzIgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xufVxuXG52ZWMzIHByZXByb2plY3QodmVjMyBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbik7XG59XG5cbnZlYzQgcHJlcHJvamVjdCh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uKTtcbn1cblxudmVjNCBwcm9qZWN0KHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uKTtcbn1cbmA7XG4iXX0=