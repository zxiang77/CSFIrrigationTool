"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float width = clamp(project_scale(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(1.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(1.0, 0.0);\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  // do not bevel if line segment is too short\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  // trim if inside corner extends further than the line segment\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  float isStartCap = step(0.0, -lenA);\n  float isEndCap = step(0.0, -lenB);\n  float isCap = max(isStartCap, isEndCap);\n\n  // 0: center, 1: side\n  cornerPosition = isCap * (1.0 - positions.z);\n\n  // start of path: use next - curr\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  // end of path: use curr - prev\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n\n  // extend out a triangle to envelope the round cap\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors, 255.) / 255.;\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  float isEnd = positions.x;\n\n  // Calculate previous position\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\n  prevPosition = project_position(prevPosition);\n\n  // Calculate current position\n  // Only here we need to do the 64-bit calculations.\n\n  vec2 instanceStartPositions64[2];\n  instanceStartPositions64[0] = vec2(instanceStartPositions.x, instanceStartEndPositions64xyLow.x);\n  instanceStartPositions64[1] = vec2(instanceStartPositions.y, instanceStartEndPositions64xyLow.y);\n\n  vec2 instanceEndPositions64[2];\n  instanceEndPositions64[0] = vec2(instanceEndPositions.x, instanceStartEndPositions64xyLow.z);\n  instanceEndPositions64[1] = vec2(instanceEndPositions.y, instanceStartEndPositions64xyLow.w);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n\n  vec2 tempCurrPosition64[2];\n  vec2_mix_fp64(instanceStartPositions64, instanceEndPositions64, isEnd, tempCurrPosition64);\n\n  vec4 currPosition64 = vec4(tempCurrPosition64[0].xy, tempCurrPosition64[1].xy);\n\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition64, projected_curr_position);\n  float projected_curr_position_z = project_scale(currPosition.z);\n\n  currPosition = project_position(currPosition);\n\n  // Calculate next positions\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\n  nextPosition = project_position(nextPosition);\n\n  vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwYXRoLWxheWVyLXZlcnRleC02NC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBhdGgtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUVuZFBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VMZWZ0RGVsdGFzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VSaWdodERlbHRhcztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVN0cm9rZVdpZHRocztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG51bmlmb3JtIGZsb2F0IHdpZHRoU2NhbGU7XG51bmlmb3JtIGZsb2F0IHdpZHRoTWluUGl4ZWxzO1xudW5pZm9ybSBmbG9hdCB3aWR0aE1heFBpeGVscztcbnVuaWZvcm0gZmxvYXQgam9pbnRUeXBlO1xudW5pZm9ybSBmbG9hdCBtaXRlckxpbWl0O1xuXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdkNvcm5lck9mZnNldDtcbnZhcnlpbmcgZmxvYXQgdk1pdGVyTGVuZ3RoO1xuXG5jb25zdCBmbG9hdCBFUFNJTE9OID0gMC4wMDE7XG5cbmZsb2F0IGZsaXBJZlRydWUoYm9vbCBmbGFnKSB7XG4gIHJldHVybiAtKGZsb2F0KGZsYWcpICogMi4gLSAxLik7XG59XG52ZWMzIGxpbmVKb2luKHZlYzMgcHJldlBvaW50LCB2ZWMzIGN1cnJQb2ludCwgdmVjMyBuZXh0UG9pbnQpIHtcblxuICBmbG9hdCB3aWR0aCA9IGNsYW1wKHByb2plY3Rfc2NhbGUoaW5zdGFuY2VTdHJva2VXaWR0aHMgKiB3aWR0aFNjYWxlKSxcbiAgICB3aWR0aE1pblBpeGVscywgd2lkdGhNYXhQaXhlbHMpIC8gMi4wO1xuXG4gIHZlYzIgZGVsdGFBID0gY3VyclBvaW50Lnh5IC0gcHJldlBvaW50Lnh5O1xuICB2ZWMyIGRlbHRhQiA9IG5leHRQb2ludC54eSAtIGN1cnJQb2ludC54eTtcblxuICB2ZWMyIG9mZnNldFZlYztcbiAgZmxvYXQgb2Zmc2V0U2NhbGU7XG4gIGZsb2F0IG9mZnNldERpcmVjdGlvbjtcblxuICBmbG9hdCBsZW5BID0gbGVuZ3RoKGRlbHRhQSk7XG4gIGZsb2F0IGxlbkIgPSBsZW5ndGgoZGVsdGFCKTtcbiAgdmVjMiBkaXJBID0gbGVuQSA+IDAuID8gbm9ybWFsaXplKGRlbHRhQSkgOiB2ZWMyKDEuMCwgMC4wKTtcbiAgdmVjMiBkaXJCID0gbGVuQiA+IDAuID8gbm9ybWFsaXplKGRlbHRhQikgOiB2ZWMyKDEuMCwgMC4wKTtcbiAgdmVjMiBwZXJwQSA9IHZlYzIoLWRpckEueSwgZGlyQS54KTtcbiAgdmVjMiBwZXJwQiA9IHZlYzIoLWRpckIueSwgZGlyQi54KTtcblxuICAvLyB0YW5nZW50IG9mIHRoZSBjb3JuZXJcbiAgdmVjMiB0YW5nZW50ID0gdmVjMihkaXJBICsgZGlyQik7XG4gIHRhbmdlbnQgPSBsZW5ndGgodGFuZ2VudCkgPiAwLiA/IG5vcm1hbGl6ZSh0YW5nZW50KSA6IHBlcnBBO1xuICAvLyBkaXJlY3Rpb24gb2YgdGhlIGNvcm5lclxuICB2ZWMyIG1pdGVyVmVjID0gdmVjMigtdGFuZ2VudC55LCB0YW5nZW50LngpO1xuICAvLyB3aWR0aCBvZmZzZXQgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gIHZlYzIgcGVycCA9IG1peChwZXJwQiwgcGVycEEsIHBvc2l0aW9ucy54KTtcbiAgZmxvYXQgTCA9IG1peChsZW5CLCBsZW5BLCBwb3NpdGlvbnMueCk7XG5cbiAgLy8gY2FwIHN1cGVyIHNoYXJwIGFuZ2xlc1xuICBmbG9hdCBzaW5IYWxmQSA9IGFicyhkb3QobWl0ZXJWZWMsIHBlcnApKTtcbiAgZmxvYXQgY29zSGFsZkEgPSBhYnMoZG90KGRpckEsIG1pdGVyVmVjKSk7XG4gIGJvb2wgdHVybnNSaWdodCA9IGRpckEueCAqIGRpckIueSA+IGRpckEueSAqIGRpckIueDtcblxuICAvLyByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgY29ybmVyOlxuICAvLyAtMTogaW5zaWRlIChzbWFsbGVyIHNpZGUgb2YgdGhlIGFuZ2xlKVxuICAvLyAwOiBjZW50ZXJcbiAgLy8gMTogb3V0c2lkZSAoYmlnZ2VyIHNpZGUgb2YgdGhlIGFuZ2xlKVxuICBmbG9hdCBjb3JuZXJQb3NpdGlvbiA9IG1peChcbiAgICBmbGlwSWZUcnVlKHR1cm5zUmlnaHQgPT0gKHBvc2l0aW9ucy55ID4gMC4wKSksXG4gICAgMC4wLFxuICAgIHBvc2l0aW9ucy56XG4gICk7XG5cbiAgb2Zmc2V0U2NhbGUgPSAxLjAgLyBtYXgoc2luSGFsZkEsIEVQU0lMT04pO1xuXG4gIC8vIGRvIG5vdCBiZXZlbCBpZiBsaW5lIHNlZ21lbnQgaXMgdG9vIHNob3J0XG4gIGNvcm5lclBvc2l0aW9uICo9IGZsb2F0KGNvcm5lclBvc2l0aW9uIDw9IDAuMCB8fCBzaW5IYWxmQSA8IG1pbihsZW5BLCBsZW5CKSAvIHdpZHRoICogY29zSGFsZkEpO1xuICAvLyB0cmltIGlmIGluc2lkZSBjb3JuZXIgZXh0ZW5kcyBmdXJ0aGVyIHRoYW4gdGhlIGxpbmUgc2VnbWVudFxuICBvZmZzZXRTY2FsZSA9IG1peChcbiAgICBvZmZzZXRTY2FsZSxcbiAgICBtaW4ob2Zmc2V0U2NhbGUsIEwgLyB3aWR0aCAvIG1heChjb3NIYWxmQSwgRVBTSUxPTikpLFxuICAgIGZsb2F0KGNvcm5lclBvc2l0aW9uIDwgMC4wKVxuICApO1xuXG4gIHZNaXRlckxlbmd0aCA9IG1peChcbiAgICBvZmZzZXRTY2FsZSAqIGNvcm5lclBvc2l0aW9uLFxuICAgIG1peChvZmZzZXRTY2FsZSwgMC4wLCBjb3JuZXJQb3NpdGlvbiksXG4gICAgc3RlcCgwLjAsIGNvcm5lclBvc2l0aW9uKVxuICApIC0gc2luSGFsZkEgKiBqb2ludFR5cGU7XG4gIG9mZnNldERpcmVjdGlvbiA9IG1peChcbiAgICBwb3NpdGlvbnMueSxcbiAgICBtaXgoXG4gICAgICBmbGlwSWZUcnVlKHR1cm5zUmlnaHQpLFxuICAgICAgcG9zaXRpb25zLnkgKiBmbGlwSWZUcnVlKHR1cm5zUmlnaHQgPT0gKHBvc2l0aW9ucy54ID09IDEuKSksXG4gICAgICBjb3JuZXJQb3NpdGlvblxuICAgICksXG4gICAgc3RlcCgwLjAsIGNvcm5lclBvc2l0aW9uKVxuICApO1xuICBvZmZzZXRWZWMgPSBtaXgobWl0ZXJWZWMsIC10YW5nZW50LCBzdGVwKDAuNSwgY29ybmVyUG9zaXRpb24pKTtcbiAgb2Zmc2V0U2NhbGUgPSBtaXgob2Zmc2V0U2NhbGUsIDEuMCAvIG1heChjb3NIYWxmQSwgMC4wMDEpLCBzdGVwKDAuNSwgY29ybmVyUG9zaXRpb24pKTtcblxuICAvLyBzcGVjaWFsIHRyZWF0bWVudCBmb3Igc3RhcnQgY2FwIGFuZCBlbmQgY2FwXG4gIGZsb2F0IGlzU3RhcnRDYXAgPSBzdGVwKDAuMCwgLWxlbkEpO1xuICBmbG9hdCBpc0VuZENhcCA9IHN0ZXAoMC4wLCAtbGVuQik7XG4gIGZsb2F0IGlzQ2FwID0gbWF4KGlzU3RhcnRDYXAsIGlzRW5kQ2FwKTtcblxuICAvLyAwOiBjZW50ZXIsIDE6IHNpZGVcbiAgY29ybmVyUG9zaXRpb24gPSBpc0NhcCAqICgxLjAgLSBwb3NpdGlvbnMueik7XG5cbiAgLy8gc3RhcnQgb2YgcGF0aDogdXNlIG5leHQgLSBjdXJyXG4gIG9mZnNldFZlYyA9IG1peChvZmZzZXRWZWMsIG1peChkaXJCLCBwZXJwQiwgY29ybmVyUG9zaXRpb24pLCBpc1N0YXJ0Q2FwKTtcbiAgLy8gZW5kIG9mIHBhdGg6IHVzZSBjdXJyIC0gcHJldlxuICBvZmZzZXRWZWMgPSBtaXgob2Zmc2V0VmVjLCBtaXgoZGlyQSwgcGVycEEsIGNvcm5lclBvc2l0aW9uKSwgaXNFbmRDYXApO1xuXG4gIC8vIGV4dGVuZCBvdXQgYSB0cmlhbmdsZSB0byBlbnZlbG9wZSB0aGUgcm91bmQgY2FwXG4gIG9mZnNldFNjYWxlID0gbWl4KFxuICAgIG9mZnNldFNjYWxlLFxuICAgIG1peCg0LjAgKiBqb2ludFR5cGUsIDEuMCwgY29ybmVyUG9zaXRpb24pLFxuICAgIGlzQ2FwXG4gICk7XG4gIHZNaXRlckxlbmd0aCA9IG1peCh2TWl0ZXJMZW5ndGgsIDEuMCAtIGNvcm5lclBvc2l0aW9uLCBpc0NhcCk7XG5cbiAgb2Zmc2V0RGlyZWN0aW9uID0gbWl4KFxuICAgIG9mZnNldERpcmVjdGlvbixcbiAgICBtaXgoZmxpcElmVHJ1ZShpc1N0YXJ0Q2FwID4gMC4pLCBwb3NpdGlvbnMueSwgY29ybmVyUG9zaXRpb24pLFxuICAgIGlzQ2FwXG4gICk7XG5cbiAgdkNvcm5lck9mZnNldCA9IG9mZnNldFZlYyAqIG9mZnNldERpcmVjdGlvbiAqIG9mZnNldFNjYWxlO1xuXG4gIHJldHVybiB2ZWMzKHZDb3JuZXJPZmZzZXQgKiB3aWR0aCwgMC4wKTtcbn1cblxudm9pZCBtYWluKCkge1xuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMsIDI1NS4pIC8gMjU1LjtcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xuXG4gIGZsb2F0IGlzRW5kID0gcG9zaXRpb25zLng7XG5cbiAgLy8gQ2FsY3VsYXRlIHByZXZpb3VzIHBvc2l0aW9uXG4gIHZlYzMgcHJldlBvc2l0aW9uID0gbWl4KC1pbnN0YW5jZUxlZnREZWx0YXMsIHZlYzMoMC4wKSwgaXNFbmQpICsgaW5zdGFuY2VTdGFydFBvc2l0aW9ucztcbiAgcHJldlBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihwcmV2UG9zaXRpb24pO1xuXG4gIC8vIENhbGN1bGF0ZSBjdXJyZW50IHBvc2l0aW9uXG4gIC8vIE9ubHkgaGVyZSB3ZSBuZWVkIHRvIGRvIHRoZSA2NC1iaXQgY2FsY3VsYXRpb25zLlxuXG4gIHZlYzIgaW5zdGFuY2VTdGFydFBvc2l0aW9uczY0WzJdO1xuICBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zNjRbMF0gPSB2ZWMyKGluc3RhbmNlU3RhcnRQb3NpdGlvbnMueCwgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3cueCk7XG4gIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM2NFsxXSA9IHZlYzIoaW5zdGFuY2VTdGFydFBvc2l0aW9ucy55LCBpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdy55KTtcblxuICB2ZWMyIGluc3RhbmNlRW5kUG9zaXRpb25zNjRbMl07XG4gIGluc3RhbmNlRW5kUG9zaXRpb25zNjRbMF0gPSB2ZWMyKGluc3RhbmNlRW5kUG9zaXRpb25zLngsIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93LnopO1xuICBpbnN0YW5jZUVuZFBvc2l0aW9uczY0WzFdID0gdmVjMihpbnN0YW5jZUVuZFBvc2l0aW9ucy55LCBpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdy53KTtcblxuICB2ZWMzIGN1cnJQb3NpdGlvbiA9IG1peChpbnN0YW5jZVN0YXJ0UG9zaXRpb25zLCBpbnN0YW5jZUVuZFBvc2l0aW9ucywgaXNFbmQpO1xuXG4gIHZlYzIgdGVtcEN1cnJQb3NpdGlvbjY0WzJdO1xuICB2ZWMyX21peF9mcDY0KGluc3RhbmNlU3RhcnRQb3NpdGlvbnM2NCwgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NCwgaXNFbmQsIHRlbXBDdXJyUG9zaXRpb242NCk7XG5cbiAgdmVjNCBjdXJyUG9zaXRpb242NCA9IHZlYzQodGVtcEN1cnJQb3NpdGlvbjY0WzBdLnh5LCB0ZW1wQ3VyclBvc2l0aW9uNjRbMV0ueHkpO1xuXG4gIHZlYzIgcHJvamVjdGVkX2N1cnJfcG9zaXRpb25bMl07XG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChjdXJyUG9zaXRpb242NCwgcHJvamVjdGVkX2N1cnJfcG9zaXRpb24pO1xuICBmbG9hdCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvbl96ID0gcHJvamVjdF9zY2FsZShjdXJyUG9zaXRpb24ueik7XG5cbiAgY3VyclBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihjdXJyUG9zaXRpb24pO1xuXG4gIC8vIENhbGN1bGF0ZSBuZXh0IHBvc2l0aW9uc1xuICB2ZWMzIG5leHRQb3NpdGlvbiA9IG1peCh2ZWMzKDAuMCksIGluc3RhbmNlUmlnaHREZWx0YXMsIGlzRW5kKSArIGluc3RhbmNlRW5kUG9zaXRpb25zO1xuICBuZXh0UG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKG5leHRQb3NpdGlvbik7XG5cbiAgdmVjMyBwb3MgPSBsaW5lSm9pbihwcmV2UG9zaXRpb24sIGN1cnJQb3NpdGlvbiwgbmV4dFBvc2l0aW9uKTtcbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHN1bV9mcDY0KHZlYzIocG9zLngsIDAuMCksIHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uWzBdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gc3VtX2ZwNjQodmVjMihwb3MueSwgMC4wKSwgcHJvamVjdGVkX2N1cnJfcG9zaXRpb25bMV0pO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0gPSB2ZWMyKHBvcy56ICsgcHJvamVjdGVkX2N1cnJfcG9zaXRpb25feiwgMC4wKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XG59XG5gO1xuIl19