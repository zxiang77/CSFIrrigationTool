'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawLayers = drawLayers;
exports.pickLayers = pickLayers;

var _luma = require('luma.gl');

var _viewportUniforms = require('./viewport-uniforms');

var _utils = require('./utils');

var EMPTY_PIXEL = new Uint8Array(4); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */

var renderCount = 0;

function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  _utils.log.log(3, 'DRAWING ' + layers.length + ' layers');

  // render layers in normal colors
  var visibleCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });

  _utils.log.log(3, 'RENDER PASS ' + pass + ': ' + renderCount++ + '\n    ' + visibleCount + ' visible, ' + layers.length + ' total');
}

/* eslint-disable max-depth, max-statements */
function pickLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      _ref2$uniforms = _ref2.uniforms,
      uniforms = _ref2$uniforms === undefined ? {} : _ref2$uniforms,
      x = _ref2.x,
      y = _ref2.y,
      viewport = _ref2.viewport,
      mode = _ref2.mode,
      lastPickedInfo = _ref2.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * pixelRatio;
  var deviceY = gl.canvas.height - y * pixelRatio;

  // TODO - just return glContextWithState once luma updates
  var unhandledPickInfos = [];

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  (0, _luma.glContextWithState)(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {

    // Picking process start
    // Clear the frame buffer
    gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);
    // Save current blend settings
    var oldBlendMode = (0, _utils.getBlendMode)(gl);
    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);

        layer.drawLayer({
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColor = new Uint8Array(4);
    gl.readPixels(deviceX, deviceY, 1, 1, _luma.GL.RGBA, _luma.GL.UNSIGNED_BYTE, pickedColor);

    // restore blend mode
    (0, _utils.setBlendMode)(gl, oldBlendMode);
    // Picking process end

    // Process picked info start
    // Decode picked color
    var pickedLayerIndex = pickedColor[3] - 1;
    var pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;
    var pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;
    var affectedLayers = pickedLayer ? [pickedLayer] : [];

    if (mode === 'hover') {
      // only invoke onHover events if picked object has changed
      var lastPickedObjectIndex = lastPickedInfo.index;
      var lastPickedLayerId = lastPickedInfo.layerId;

      if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {
        // picked object did not change, no need to proceed
        return;
      }

      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (l) {
          return l.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }

    var baseInfo = createInfo([x, y], viewport);
    baseInfo.devicePixel = [deviceX, deviceY];
    baseInfo.pixelRatio = pixelRatio;

    // Use a Map to store all picking infos.
    // The following two forEach loops are the result of
    // https://github.com/uber/deck.gl/issues/443
    // Please be very careful when changing this pattern
    var infos = new Map();

    affectedLayers.forEach(function (layer) {
      var info = Object.assign({}, baseInfo);

      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }

      // Walk up the composite chain and find the owner of the event
      // sublayers are never directly exposed to the user
      while (layer && info) {
        // For a composite layer, sourceLayer will point to the sublayer
        // where the event originates from.
        // It provides additional context for the composite layer's
        // getPickingInfo() method to populate the info object
        var sourceLayer = info.layer || layer;
        info.layer = layer;
        // layer.pickLayer() function requires a non-null ```layer.state```
        // object to funtion properly. So the layer refereced here
        // must be the "current" layer, not an "out-dated" / "invalidated" layer
        info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
        layer = layer.parentLayer;
      }

      // This guarantees that there will be only one copy of info for
      // one composite layer
      if (info) {
        infos.set(info.layer.id, info);
      }
    });

    infos.forEach(function (info) {
      var handled = false;
      // The onClick and onHover functions are provided by the user
      // and out of control by deck.gl. It's very much possible that
      // the user calls React lifecycle methods in these function, such as
      // ReactComponent.setState(). React lifecycle methods sometimes induce
      // a re-render and re-generation of props of deck.gl and its layers,
      // which invalidates all layers currently passed to this very function.

      // Therefore, calls to functions like onClick and onHover need to be done
      // at the end of the function. NO operation relies on the states of current
      // layers should be called after this two lines of code.
      switch (mode) {
        case 'click':
          handled = info.layer.props.onClick(info);break;
        case 'hover':
          handled = info.layer.props.onHover(info);break;
        default:
          throw new Error('unknown pick type');
      }

      if (!handled) {
        unhandledPickInfos.push(info);
      }
    });
  });

  return unhandledPickInfos;
}
/* eslint-enable max-depth, max-statements */

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJkcmF3TGF5ZXJzIiwicGlja0xheWVycyIsIkVNUFRZX1BJWEVMIiwiVWludDhBcnJheSIsInJlbmRlckNvdW50IiwibGF5ZXJzIiwicGFzcyIsImxvZyIsImxlbmd0aCIsInZpc2libGVDb3VudCIsImZvckVhY2giLCJsYXllciIsImxheWVySW5kZXgiLCJwcm9wcyIsInZpc2libGUiLCJkcmF3TGF5ZXIiLCJ1bmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJwaWNraW5nRW5hYmxlZCIsImNvbnRleHQiLCJ2aWV3cG9ydCIsImdsIiwicGlja2luZ0ZCTyIsIngiLCJ5IiwibW9kZSIsImxhc3RQaWNrZWRJbmZvIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VYIiwiZGV2aWNlWSIsImNhbnZhcyIsImhlaWdodCIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImZyYW1lQnVmZmVyIiwiZnJhbWVidWZmZXIiLCJzY2lzc29yVGVzdCIsInciLCJoIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsIm9sZEJsZW5kTW9kZSIsImVuYWJsZSIsIkJMRU5EIiwiYmxlbmRGdW5jU2VwYXJhdGUiLCJPTkUiLCJaRVJPIiwiQ09OU1RBTlRfQUxQSEEiLCJibGVuZEVxdWF0aW9uIiwiRlVOQ19BREQiLCJwaWNrYWJsZSIsImJsZW5kQ29sb3IiLCJwaWNrZWRDb2xvciIsInJlYWRQaXhlbHMiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInBpY2tlZExheWVySW5kZXgiLCJwaWNrZWRMYXllciIsInBpY2tlZE9iamVjdEluZGV4IiwiZGVjb2RlUGlja2luZ0NvbG9yIiwicGlja2VkTGF5ZXJJZCIsImlkIiwiYWZmZWN0ZWRMYXllcnMiLCJsYXN0UGlja2VkT2JqZWN0SW5kZXgiLCJpbmRleCIsImxhc3RQaWNrZWRMYXllcklkIiwibGF5ZXJJZCIsImxhc3RQaWNrZWRMYXllciIsImZpbmQiLCJsIiwidW5zaGlmdCIsImJhc2VJbmZvIiwiY3JlYXRlSW5mbyIsImRldmljZVBpeGVsIiwiaW5mb3MiLCJNYXAiLCJpbmZvIiwiY29sb3IiLCJwaWNrZWQiLCJzb3VyY2VMYXllciIsInBpY2tMYXllciIsInBhcmVudExheWVyIiwic2V0IiwiaGFuZGxlZCIsIm9uQ2xpY2siLCJvbkhvdmVyIiwiRXJyb3IiLCJwdXNoIiwicGl4ZWwiLCJsbmdMYXQiLCJ1bnByb2plY3QiXSwibWFwcGluZ3MiOiI7Ozs7O1FBNEJnQkEsVSxHQUFBQSxVO1FBeUJBQyxVLEdBQUFBLFU7O0FBaENoQjs7QUFDQTs7QUFDQTs7QUFFQSxJQUFNQyxjQUFjLElBQUlDLFVBQUosQ0FBZSxDQUFmLENBQXBCLEMsQ0F6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBTUEsSUFBSUMsY0FBYyxDQUFsQjs7QUFFTyxTQUFTSixVQUFULE9BQW9DO0FBQUEsTUFBZkssTUFBZSxRQUFmQSxNQUFlO0FBQUEsTUFBUEMsSUFBTyxRQUFQQSxJQUFPOztBQUN6QyxhQUFJQyxHQUFKLENBQVEsQ0FBUixlQUFzQkYsT0FBT0csTUFBN0I7O0FBRUE7QUFDQSxNQUFJQyxlQUFlLENBQW5CO0FBQ0E7QUFDQUosU0FBT0ssT0FBUCxDQUFlLFVBQUNDLEtBQUQsRUFBUUMsVUFBUixFQUF1QjtBQUNwQyxRQUFJRCxNQUFNRSxLQUFOLENBQVlDLE9BQWhCLEVBQXlCO0FBQ3ZCSCxZQUFNSSxTQUFOLENBQWdCO0FBQ2RDLGtCQUFVQyxPQUFPQyxNQUFQLENBQ1IsRUFBQ0MscUJBQXFCLENBQXRCLEVBQXlCQyxnQkFBZ0IsQ0FBekMsRUFEUSxFQUVSVCxNQUFNVSxPQUFOLENBQWNMLFFBRk4sRUFHUiwrQ0FBd0JMLE1B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QUFVUCxLQUFLckUsS0FBTCxDQUFXRSxLQUFYLENBQWlCNEUsT0FBakIsQ0FBeUJULElBQXpCLENBQVYsQ0FBMEM7QUFDeEQ7QUFBUyxnQkFBTSxJQUFJVSxLQUFKLENBQVUsbUJBQVYsQ0FBTjtBQUhUOztBQU1BLFVBQUksQ0FBQ0gsT0FBTCxFQUFjO0FBQ1puRCwyQkFBbUJ1RCxJQUFuQixDQUF3QlgsSUFBeEI7QUFDRDtBQUNGLEtBckJEO0FBc0JELEdBN0lEOztBQStJQSxTQUFPNUMsa0JBQVA7QUFDRDtBQUNEOztBQUVBLFNBQVN3QyxVQUFULENBQW9CZ0IsS0FBcEIsRUFBMkJ0RSxRQUEzQixFQUFxQztBQUNuQztBQUNBLFNBQU87QUFDTDJELFdBQU8vRSxXQURGO0FBRUxrRSxXQUFPLENBQUMsQ0FGSDtBQUdMYyxZQUFRLEtBSEg7QUFJTHpELE9BQUdtRSxNQUFNLENBQU4sQ0FKRTtBQUtMbEUsT0FBR2tFLE1BQU0sQ0FBTixDQUxFO0FBTUxBLGdCQU5LO0FBT0xDLFlBQVF2RSxTQUFTd0UsU0FBVCxDQUFtQkYsS0FBbkI7QUFQSCxHQUFQO0FBU0QiLCJmaWxlIjoiZHJhdy1hbmQtcGljay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCBnbENvbnRleHRXaXRoU3RhdGV9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydC11bmlmb3Jtcyc7XG5pbXBvcnQge2xvZywgZ2V0QmxlbmRNb2RlLCBzZXRCbGVuZE1vZGV9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBFTVBUWV9QSVhFTCA9IG5ldyBVaW50OEFycmF5KDQpO1xubGV0IHJlbmRlckNvdW50ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXllcnMoe2xheWVycywgcGFzc30pIHtcbiAgbG9nLmxvZygzLCBgRFJBV0lORyAke2xheWVycy5sZW5ndGh9IGxheWVyc2ApO1xuXG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsZXQgdmlzaWJsZUNvdW50ID0gMDtcbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlKSB7XG4gICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMCwgcGlja2luZ0VuYWJsZWQ6IDB9LFxuICAgICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgICAgZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQobGF5ZXIuY29udGV4dC52aWV3cG9ydCwgbGF5ZXIucHJvcHMpLFxuICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIHZpc2libGVDb3VudCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgbG9nLmxvZygzLCBgUkVOREVSIFBBU1MgJHtwYXNzfTogJHtyZW5kZXJDb3VudCsrfVxuICAgICR7dmlzaWJsZUNvdW50fSB2aXNpYmxlLCAke2xheWVycy5sZW5ndGh9IHRvdGFsYCk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrTGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgdW5pZm9ybXMgPSB7fSxcbiAgeCxcbiAgeSxcbiAgdmlld3BvcnQsXG4gIG1vZGUsXG4gIGxhc3RQaWNrZWRJbmZvXG59KSB7XG5cbiAgLy8gQ29udmVydCBmcm9tIGNhbnZhcyB0b3AtbGVmdCB0byBXZWJHTCBib3R0b20tbGVmdCBjb29yZGluYXRlc1xuICAvLyBBbmQgY29tcGVuc2F0ZSBmb3IgcGl4ZWxSYXRpb1xuICBjb25zdCBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgY29uc3QgZGV2aWNlWCA9IHggKiBwaXhlbFJhdGlvO1xuICBjb25zdCBkZXZpY2VZID0gZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvO1xuXG4gIC8vIFRPRE8gLSBqdXN0IHJldHVybiBnbENvbnRleHRXaXRoU3RhdGUgb25jZSBsdW1hIHVwZGF0ZXNcbiAgY29uc3QgdW5oYW5kbGVkUGlja0luZm9zID0gW107XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGNsZWFyIHNjaXNzb3IgdGVzdCBhbmQgZmJvIGJpbmRpbmdzIGluIGNhc2Ugb2YgZXhjZXB0aW9uc1xuICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG9uZSBwaXhlbCwgbm8gbmVlZCB0byByZW5kZXIgYW55dGhpbmcgZWxzZVxuICBnbENvbnRleHRXaXRoU3RhdGUoZ2wsIHtcbiAgICBmcmFtZUJ1ZmZlcjogcGlja2luZ0ZCTyxcbiAgICBmcmFtZWJ1ZmZlcjogcGlja2luZ0ZCTyxcbiAgICBzY2lzc29yVGVzdDoge3g6IGRldmljZVgsIHk6IGRldmljZVksIHc6IDEsIGg6IDF9XG4gIH0sICgpID0+IHtcblxuICAgIC8vIFBpY2tpbmcgcHJvY2VzcyBzdGFydFxuICAgIC8vIENsZWFyIHRoZSBmcmFtZSBidWZmZXJcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgLy8gU2F2ZSBjdXJyZW50IGJsZW5kIHNldHRpbmdzXG4gICAgY29uc3Qgb2xkQmxlbmRNb2RlID0gZ2V0QmxlbmRNb2RlKGdsKTtcbiAgICAvLyBTZXQgYmxlbmQgbW9kZSBmb3IgcGlja2luZ1xuICAgIC8vIGFsd2F5cyBvdmVyd3JpdGUgZXhpc3RpbmcgcGl4ZWwgd2l0aCBbcixnLGIsbGF5ZXJJbmRleF1cbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuWkVSTywgZ2wuQ09OU1RBTlRfQUxQSEEsIGdsLlpFUk8pO1xuICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuXG4gICAgLy8gUmVuZGVyIGFsbCBwaWNrYWJsZSBsYXllcnMgaW4gcGlja2luZyBjb2xvcnNcbiAgICBsYXllcnMuZm9yRWFjaCgobGF5ZXIsIGxheWVySW5kZXgpID0+IHtcbiAgICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlICYmIGxheWVyLnByb3BzLnBpY2thYmxlKSB7XG5cbiAgICAgICAgLy8gRW5jb2RlIGxheWVySW5kZXggd2l0aCBhbHBoYVxuICAgICAgICBnbC5ibGVuZENvbG9yKDAsIDAsIDAsIChsYXllckluZGV4ICsgMSkgLyAyNTUpO1xuXG4gICAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMSwgcGlja2luZ0VuYWJsZWQ6IDF9LFxuICAgICAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWFkIGNvbG9yIGluIHRoZSBjZW50cmFsIHBpeGVsLCB0byBiZSBtYXBwZWQgd2l0aCBwaWNraW5nIGNvbG9yc1xuICAgIGNvbnN0IHBpY2tlZENvbG9yID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZ2wucmVhZFBpeGVscyhkZXZpY2VYLCBkZXZpY2VZLCAxLCAxLCBHTC5SR0JBLCBHTC5VTlNJR05FRF9CWVRFLCBwaWNrZWRDb2xvcik7XG5cbiAgICAvLyByZXN0b3JlIGJsZW5kIG1vZGVcbiAgICBzZXRCbGVuZE1vZGUoZ2wsIG9sZEJsZW5kTW9kZSk7XG4gICAgLy8gUGlja2luZyBwcm9jZXNzIGVuZFxuXG4gICAgLy8gUHJvY2VzcyBwaWNrZWQgaW5mbyBzdGFydFxuICAgIC8vIERlY29kZSBwaWNrZWQgY29sb3JcbiAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JbM10gLSAxO1xuICAgIGNvbnN0IHBpY2tlZExheWVyID0gcGlja2VkTGF5ZXJJbmRleCA+PSAwID8gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdIDogbnVsbDtcbiAgICBjb25zdCBwaWNrZWRPYmplY3RJbmRleCA9IHBpY2tlZExheWVyID8gcGlja2VkTGF5ZXIuZGVjb2RlUGlja2luZ0NvbG9yKHBpY2tlZENvbG9yKSA6IC0xO1xuICAgIGNvbnN0IHBpY2tlZExheWVySWQgPSBwaWNrZWRMYXllciAmJiBwaWNrZWRMYXllci5wcm9wcy5pZDtcbiAgICBjb25zdCBhZmZlY3RlZExheWVycyA9IHBpY2tlZExheWVyID8gW3BpY2tlZExheWVyXSA6IFtdO1xuXG4gICAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAgIC8vIG9ubHkgaW52b2tlIG9uSG92ZXIgZXZlbnRzIGlmIHBpY2tlZCBvYmplY3QgaGFzIGNoYW5nZWRcbiAgICAgIGNvbnN0IGxhc3RQaWNrZWRPYmplY3RJbmRleCA9IGxhc3RQaWNrZWRJbmZvLmluZGV4O1xuICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVySWQgPSBsYXN0UGlja2VkSW5mby5sYXllcklkO1xuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCA9PT0gbGFzdFBpY2tlZExheWVySWQgJiYgcGlja2VkT2JqZWN0SW5kZXggPT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgICAvLyBwaWNrZWQgb2JqZWN0IGRpZCBub3QgY2hhbmdlLCBubyBuZWVkIHRvIHByb2NlZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHN0b3JlIGEgcmVmIHRvIGxhc3RQaWNrZWRMYXllciBpbiB0aGUgY29udGV4dCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBzdGF0ZSBvZiBhbiBvdXRkYXRlZCBsYXllciBpcyBubyBsb25nZXIgdmFsaWRcbiAgICAgICAgLy8gYW5kIHRoZSBwcm9wcyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllciA9IGxheWVycy5maW5kKGwgPT4gbC5wcm9wcy5pZCA9PT0gbGFzdFBpY2tlZExheWVySWQpO1xuICAgICAgICBpZiAobGFzdFBpY2tlZExheWVyKSB7XG4gICAgICAgICAgLy8gTGV0IGxlYXZlIGV2ZW50IGZpcmUgYmVmb3JlIGVudGVyIGV2ZW50XG4gICAgICAgICAgYWZmZWN0ZWRMYXllcnMudW5zaGlmdChsYXN0UGlja2VkTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllciBtYW5hZ2VyIGNvbnRleHRcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmxheWVySWQgPSBwaWNrZWRMYXllcklkO1xuICAgICAgbGFzdFBpY2tlZEluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlSW5mbyA9IGNyZWF0ZUluZm8oW3gsIHldLCB2aWV3cG9ydCk7XG4gICAgYmFzZUluZm8uZGV2aWNlUGl4ZWwgPSBbZGV2aWNlWCwgZGV2aWNlWV07XG4gICAgYmFzZUluZm8ucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICAvLyBVc2UgYSBNYXAgdG8gc3RvcmUgYWxsIHBpY2tpbmcgaW5mb3MuXG4gICAgLy8gVGhlIGZvbGxvd2luZyB0d28gZm9yRWFjaCBsb29wcyBhcmUgdGhlIHJlc3VsdCBvZlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvaXNzdWVzLzQ0M1xuICAgIC8vIFBsZWFzZSBiZSB2ZXJ5IGNhcmVmdWwgd2hlbiBjaGFuZ2luZyB0aGlzIHBhdHRlcm5cbiAgICBjb25zdCBpbmZvcyA9IG5ldyBNYXAoKTtcblxuICAgIGFmZmVjdGVkTGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgbGV0IGluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSW5mbyk7XG5cbiAgICAgIGlmIChsYXllciA9PT0gcGlja2VkTGF5ZXIpIHtcbiAgICAgICAgaW5mby5jb2xvciA9IHBpY2tlZENvbG9yO1xuICAgICAgICBpbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2FsayB1cCB0aGUgY29tcG9zaXRlIGNoYWluIGFuZCBmaW5kIHRoZSBvd25lciBvZiB0aGUgZXZlbnRcbiAgICAgIC8vIHN1YmxheWVycyBhcmUgbmV2ZXIgZGlyZWN0bHkgZXhwb3NlZCB0byB0aGUgdXNlclxuICAgICAgd2hpbGUgKGxheWVyICYmIGluZm8pIHtcbiAgICAgICAgLy8gRm9yIGEgY29tcG9zaXRlIGxheWVyLCBzb3VyY2VMYXllciB3aWxsIHBvaW50IHRvIHRoZSBzdWJsYXllclxuICAgICAgICAvLyB3aGVyZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tLlxuICAgICAgICAvLyBJdCBwcm92aWRlcyBhZGRpdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBjb21wb3NpdGUgbGF5ZXInc1xuICAgICAgICAvLyBnZXRQaWNraW5nSW5mbygpIG1ldGhvZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3RcbiAgICAgICAgY29uc3Qgc291cmNlTGF5ZXIgPSBpbmZvLmxheWVyIHx8IGxheWVyO1xuICAgICAgICBpbmZvLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIC8vIGxheWVyLnBpY2tMYXllcigpIGZ1bmN0aW9uIHJlcXVpcmVzIGEgbm9uLW51bGwgYGBgbGF5ZXIuc3RhdGVgYGBcbiAgICAgICAgLy8gb2JqZWN0IHRvIGZ1bnRpb24gcHJvcGVybHkuIFNvIHRoZSBsYXllciByZWZlcmVjZWQgaGVyZVxuICAgICAgICAvLyBtdXN0IGJlIHRoZSBcImN1cnJlbnRcIiBsYXllciwgbm90IGFuIFwib3V0LWRhdGVkXCIgLyBcImludmFsaWRhdGVkXCIgbGF5ZXJcbiAgICAgICAgaW5mbyA9IGxheWVyLnBpY2tMYXllcih7aW5mbywgbW9kZSwgc291cmNlTGF5ZXJ9KTtcbiAgICAgICAgbGF5ZXIgPSBsYXllci5wYXJlbnRMYXllcjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBjb3B5IG9mIGluZm8gZm9yXG4gICAgICAvLyBvbmUgY29tcG9zaXRlIGxheWVyXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpbmZvcy5zZXQoaW5mby5sYXllci5pZCwgaW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgIC8vIFRoZSBvbkNsaWNrIGFuZCBvbkhvdmVyIGZ1bmN0aW9ucyBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICAgIC8vIGFuZCBvdXQgb2YgY29udHJvbCBieSBkZWNrLmdsLiBJdCdzIHZlcnkgbXVjaCBwb3NzaWJsZSB0aGF0XG4gICAgICAvLyB0aGUgdXNlciBjYWxscyBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBpbiB0aGVzZSBmdW5jdGlvbiwgc3VjaCBhc1xuICAgICAgLy8gUmVhY3RDb21wb25lbnQuc2V0U3RhdGUoKS4gUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgc29tZXRpbWVzIGluZHVjZVxuICAgICAgLy8gYSByZS1yZW5kZXIgYW5kIHJlLWdlbmVyYXRpb24gb2YgcHJvcHMgb2YgZGVjay5nbCBhbmQgaXRzIGxheWVycyxcbiAgICAgIC8vIHdoaWNoIGludmFsaWRhdGVzIGFsbCBsYXllcnMgY3VycmVudGx5IHBhc3NlZCB0byB0aGlzIHZlcnkgZnVuY3Rpb24uXG5cbiAgICAgIC8vIFRoZXJlZm9yZSwgY2FsbHMgdG8gZnVuY3Rpb25zIGxpa2Ugb25DbGljayBhbmQgb25Ib3ZlciBuZWVkIHRvIGJlIGRvbmVcbiAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uLiBOTyBvcGVyYXRpb24gcmVsaWVzIG9uIHRoZSBzdGF0ZXMgb2YgY3VycmVudFxuICAgICAgLy8gbGF5ZXJzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyB0d28gbGluZXMgb2YgY29kZS5cbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnY2xpY2snOiBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkNsaWNrKGluZm8pOyBicmVhaztcbiAgICAgIGNhc2UgJ2hvdmVyJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25Ib3ZlcihpbmZvKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGljayB0eXBlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgICB1bmhhbmRsZWRQaWNrSW5mb3MucHVzaChpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHBpeGVsLCB2aWV3cG9ydCkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogRU1QVFlfUElYRUwsXG4gICAgaW5kZXg6IC0xLFxuICAgIHBpY2tlZDogZmFsc2UsXG4gICAgeDogcGl4ZWxbMF0sXG4gICAgeTogcGl4ZWxbMV0sXG4gICAgcGl4ZWwsXG4gICAgbG5nTGF0OiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWwpXG4gIH07XG59XG4iXX0=