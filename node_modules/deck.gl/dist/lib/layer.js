'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TEST_EXPORTS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


var _constants = require('./constants');

var _attributeManager = require('./attribute-manager');

var _attributeManager2 = _interopRequireDefault(_attributeManager);

var _utils = require('./utils');

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_UPDATE = 2;

/*
 * @param {string} props.id - layer name
 * @param {array}  props.data - array of data instances
 * @param {bool} props.opacity - opacity of the layer
 */
var defaultProps = {
  dataComparator: null,
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: 0.8,
  onHover: function onHover() {},
  onClick: function onClick() {},
  // Update triggers: a key change detection mechanism in deck.gl
  // See layer documentation
  updateTriggers: {},
  projectionMode: _constants.COORDINATE_SYSTEM.LNGLAT
};

var counter = 0;

var Layer = function () {
  /**
   * @class
   * @param {object} props - See docs and defaults above
   */
  function Layer(props) {
    _classCallCheck(this, Layer);

    // If sublayer has static defaultProps member, getDefaultProps will return it
    var mergedDefaultProps = getDefaultProps(this);
    // Merge supplied props with pre-merged default props
    props = Object.assign({}, mergedDefaultProps, props);
    // Accept null as data - otherwise apps and layers need to add ugly checks
    props.data = props.data || [];
    // Props are immutable
    Object.freeze(props);

    // Define all members and freeze layer
    this.id = props.id;
    this.props = props;
    this.oldProps = null;
    this.state = null;
    this.context = null;
    this.parentLayer = null;
    this.count = counter++;
    this.lifecycle = 'Awaiting state';
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className !== this.props.id ? '<' + className + ':\'' + this.props.id + '\'>' : '<' + className + '>';
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          oldContext = _ref.oldContext,
          context = _ref.context,
          changeFlags = _ref.changeFlags;

      return changeFlags.somethingChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          oldContext = _ref2.oldContext,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;

      if (changeFlags.dataChanged) {
        this.invalidateAttribute('all');
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // Implement to generate sublayers

  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      return null;
    }

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var _ref3$uniforms = _ref3.uniforms,
          uniforms = _ref3$uniforms === undefined ? {} : _ref3$uniforms;

      if (this.state.model) {
        this.state.model.render(uniforms);
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref4) {
      var info = _ref4.info,
          mode = _ref4.mode;
      var color = info.color,
          index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      // TODO - move to the JS part of a shader picking shader package
      if (mode === 'hover') {
        var selectedPickingColor = new Float32Array(3);
        selectedPickingColor[0] = color[0];
        selectedPickingColor[1] = color[1];
        selectedPickingColor[2] = color[2];
        this.setUniforms({ selectedPickingColor: selectedPickingColor });
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Default implementation of attribute invalidation, can be redefine

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';

      if (name === 'all') {
        this.state.attributeManager.invalidateAll();
      } else {
        this.state.attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          model = _state.model;

      if (!attributeManager) {
        return;
      }

      var numInstances = this.getNumInstances(props);
      // Figure out data length
      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });
      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      return [(i + 1) % 256, Math.floor((i + 1) / 256) % 256, Math.floor((i + 1) / 256 / 256) % 256];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      (0, _assert2.default)(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref5) {
      var numInstances = _ref5.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return (0, _utils.count)(data);
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: 'initializeLayer',
    value: function initializeLayer(updateParams) {
      (0, _assert2.default)(this.context.gl, 'Layer context missing gl');
      (0, _assert2.default)(!this.state, 'Layer missing state');

      this.state = {};

      // Initialize state only once
      this.setState({
        attributeManager: new _attributeManager2.default({ id: this.props.id }),
        model: null,
        needsRedraw: true,
        dataChanged: true
      });

      var attributeManager = this.state.attributeManager;
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slows down non instanced layers

      attributeManager.addInstanced({
        instancePickingColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      // Call subclass lifecycle methods
      this.initializeState();
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();

      var model = this.state.model;

      if (model) {
        model.setInstanceCount(this.getNumInstances());
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }
    }

    // Called by layer manager when existing layer is getting new props

  }, {
    key: 'updateLayer',
    value: function updateLayer(updateParams) {
      // Check for deprecated method
      if (this.shouldUpdate) {
        _utils.log.once(0, 'deck.gl v3 ' + this + ': "shouldUpdate" deprecated, renamed to "shouldUpdateState"');
      }

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.shouldUpdateState(updateParams);
      // End lifecycle method

      if (stateNeedsUpdate) {
        // Call subclass lifecycle method
        this.updateState(updateParams);
        // End lifecycle method

        // Run the attribute updaters
        this.updateAttributes(updateParams.props);
        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    }
    /* eslint-enable max-statements */

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: 'finalizeLayer',
    value: function finalizeLayer() {
      // Call subclass lifecycle method
      this.finalizeState();
      // End lifecycle method
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref6) {
      var _ref6$uniforms = _ref6.uniforms,
          uniforms = _ref6$uniforms === undefined ? {} : _ref6$uniforms;

      // Call subclass lifecycle method
      this.draw({ uniforms: uniforms });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }
  }, {
    key: 'diffProps',
    value: function diffProps(oldProps, newProps, context) {
      // First check if any props have changed (ignore props that will be examined separately)
      var propsChangedReason = (0, _utils.compareProps)({
        newProps: newProps,
        oldProps: oldProps,
        ignoreProps: { data: null, updateTriggers: null }
      });

      // Now check if any data related props have changed
      var dataChangedReason = this._diffDataProps(oldProps, newProps);

      var propsChanged = Boolean(propsChangedReason);
      var dataChanged = Boolean(dataChangedReason);
      var viewportChanged = context.viewportChanged;
      var somethingChanged = propsChanged || dataChanged || viewportChanged;

      // Check update triggers to determine if any attributes need regeneration
      // Note - if data has changed, all attributes will need regeneration, so skip this step
      if (!dataChanged) {
        this._diffUpdateTriggers(oldProps, newProps);
      } else {
        _utils.log.log(2, 'dataChanged: ' + dataChanged);
      }

      return {
        propsChanged: propsChanged,
        dataChanged: dataChanged,
        viewportChanged: viewportChanged,
        somethingChanged: somethingChanged,
        reason: dataChangedReason || propsChangedReason
      };
    }

    // Checks state of attributes and model
    // TODO - is attribute manager needed? - Model should be enough.

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,
          clearRedrawFlags = _ref7$clearRedrawFlag === undefined ? false : _ref7$clearRedrawFlag;

      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      var _state2 = this.state,
          attributeManager = _state2.attributeManager,
          model = _state2.model;

      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });

      return redraw;
    }

    // PRIVATE METHODS

    // The comparison of the data prop requires special handling
    // the dataComparator should be used if supplied

  }, {
    key: '_diffDataProps',
    value: function _diffDataProps(oldProps, newProps) {
      // Support optional app defined comparison of data
      var dataComparator = newProps.dataComparator;

      if (dataComparator) {
        if (!dataComparator(newProps.data, oldProps.data)) {
          return 'Data comparator detected a change';
        }
        // Otherwise, do a shallow equal on props
      } else if (newProps.data !== oldProps.data) {
        return 'A new data container was supplied';
      }

      return null;
    }

    // Checks if any update triggers have changed, and invalidate
    // attributes accordingly.
    /* eslint-disable max-statements */

  }, {
    key: '_diffUpdateTriggers',
    value: function _diffUpdateTriggers(oldProps, newProps) {
      // const {attributeManager} = this.state;
      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();

      var change = false;

      for (var propName in newProps.updateTriggers) {
        var oldTriggers = oldProps.updateTriggers[propName] || {};
        var newTriggers = newProps.updateTriggers[propName] || {};
        var diffReason = (0, _utils.compareProps)({
          oldProps: oldTriggers,
          newProps: newTriggers
        });
        if (diffReason) {
          if (propName === 'all') {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
            this.invalidateAttribute('all');
            change = true;
          } else {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);
            this.invalidateAttribute(propName);
            change = true;
          }
        }
      }

      return change;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }

    // Emits a warning if an old prop is used, optionally suggesting a replacement

  }, {
    key: '_checkRemovedProp',
    value: function _checkRemovedProp(oldProp) {
      var newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.props[oldProp] !== undefined) {
        var layerName = this.constructor;
        var message = layerName + ' no longer accepts props.' + oldProp + ' in this version of deck.gl.';
        if (newProp) {
          message += '\nPlease use props.' + newProp + ' instead.';
        }
        _utils.log.once(0, message);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      this.setUniforms({
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      });
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      if (this.state.model) {
        this.state.model.setUniforms(uniformMap);
      }
      // TODO - set needsRedraw on the model?
      this.state.needsRedraw = true;
      (0, _utils.log)(3, 'layer.setUniforms', uniformMap);
    }
  }]);

  return Layer;
}();

exports.default = Layer;


Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;

// HELPERS

// Constructors have their super class constructors as prototypes
function getOwnProperty(object, prop) {
  return object.hasOwnProperty(prop) && object[prop];
}
/*
 * Return merged default props stored on layers constructor, create them if needed
 */
function getDefaultProps(layer) {
  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');
  if (mergedDefaultProps) {
    return mergedDefaultProps;
  }
  return mergeDefaultProps(layer);
}

/*
 * Walk the prototype chain and merge all default props
 */
function mergeDefaultProps(layer) {
  var subClassConstructor = layer.constructor;
  var layerName = getOwnProperty(subClassConstructor, 'layerName');
  if (!layerName) {
    _utils.log.once(0, 'layer ' + layer.constructor.name + ' does not specify a "layerName"');
  }
  var mergedDefaultProps = {
    id: layerName || layer.constructor.name
  };

  while (layer) {
    var layerDefaultProps = getOwnProperty(layer.constructor, 'defaultProps');
    Object.freeze(layerDefaultProps);
    if (layerDefaultProps) {
      mergedDefaultProps = Object.assign({}, layerDefaultProps, mergedDefaultProps);
    }
    layer = Object.getPrototypeOf(layer);
  }
  // Store for quick lookup
  subClassConstructor.mergedDefaultProps = mergedDefaultProps;
  return mergedDefaultProps;
}

var TEST_EXPORTS = exports.TEST_EXPORTS = {
  mergeDefaultProps: mergeDefaultProps
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXIuanMiXSwibmFtZXMiOlsiTE9HX1BSSU9SSVRZX1VQREFURSIsImRlZmF1bHRQcm9wcyIsImRhdGFDb21wYXJhdG9yIiwibnVtSW5zdGFuY2VzIiwidW5kZWZpbmVkIiwidmlzaWJsZSIsInBpY2thYmxlIiwib3BhY2l0eSIsIm9uSG92ZXIiLCJvbkNsaWNrIiwidXBkYXRlVHJpZ2dlcnMiLCJwcm9qZWN0aW9uTW9kZSIsIkxOR0xBVCIsImNvdW50ZXIiLCJMYXllciIsInByb3BzIiwibWVyZ2VkRGVmYXVsdFByb3BzIiwiZ2V0RGVmYXVsdFByb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwiZGF0YSIsImZyZWV6ZSIsImlkIiwib2xkUHJvcHMiLCJzdGF0ZSIsImNvbnRleHQiLCJwYXJlbnRMYXllciIsImNvdW50IiwibGlmZWN5Y2xlIiwic2VhbCIsImNsYXNzTmFtZSIsImNvbnN0cnVjdG9yIiwibGF5ZXJOYW1lIiwibmFtZSIsIkVycm9yIiwib2xkQ29udGV4dCIsImNoYW5nZUZsYWdzIiwic29tZXRoaW5nQ2hhbmdlZCIsImRhdGFDaGFuZ2VkIiwiaW52YWxpZGF0ZUF0dHJpYnV0ZSIsInVuaWZvcm1zIiwibW9kZWwiLCJyZW5kZXIiLCJpbmZvIiwibW9kZSIsImNvbG9yIiwiaW5kZXgiLCJBcnJheSIsImlzQXJyYXkiLCJvYmplY3QiLCJzZWxlY3RlZFBpY2tpbmdDb2xvciIsIkZsb2F0MzJBcnJheSIsInNldFVuaWZvcm1zIiwiYXR0cmlidXRlTWFuYWdlciIsImludmFsaWRhdGVBbGwiLCJpbnZhbGlkYXRlIiwiZ2V0TnVtSW5zdGFuY2VzIiwidXBkYXRlIiwiYnVmZmVycyIsImlnbm9yZVVua25vd25BdHRyaWJ1dGVzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJnZXRDaGFuZ2VkQXR0cmlidXRlcyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwic2V0QXR0cmlidXRlcyIsInVwZGF0ZU9iamVjdCIsIm5lZWRzUmVkcmF3IiwicmVkcmF3IiwibG5nTGF0Iiwidmlld3BvcnQiLCJwcm9qZWN0IiwieHkiLCJ1bnByb2plY3QiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJzY3JlZW5QaXhlbHMiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93IiwiaSIsIk1hdGgiLCJmbG9vciIsIlVpbnQ4QXJyYXkiLCJpMSIsImkyIiwiaTMiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsInNpemUiLCJwaWNraW5nQ29sb3IiLCJlbmNvZGVQaWNraW5nQ29sb3IiLCJ1cGRhdGVQYXJhbXMiLCJnbCIsInNldFN0YXRlIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VQaWNraW5nQ29sb3JzIiwidHlwZSIsIlVOU0lHTkVEX0JZVEUiLCJjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJpbml0aWFsaXplU3RhdGUiLCJ1cGRhdGVTdGF0ZSIsInVwZGF0ZUF0dHJpYnV0ZXMiLCJfdXBkYXRlQmFzZVVuaWZvcm1zIiwic2V0SW5zdGFuY2VDb3VudCIsInByb2dyYW0iLCJnZW9tZXRyeSIsImdldEF0dHJpYnV0ZXMiLCJzaG91bGRVcGRhdGUiLCJvbmNlIiwic3RhdGVOZWVkc1VwZGF0ZSIsInNob3VsZFVwZGF0ZVN0YXRlIiwiZmluYWxpemVTdGF0ZSIsImRyYXciLCJvcHRzIiwiZ2V0UGlja2luZ0luZm8iLCJuZXdQcm9wcyIsInByb3BzQ2hhbmdlZFJlYXNvbiIsImlnbm9yZVByb3BzIiwiZGF0YUNoYW5nZWRSZWFzb24iLCJfZGlmZkRhdGFQcm9wcyIsInByb3BzQ2hhbmdlZCIsIkJvb2xlYW4iLCJ2aWV3cG9ydENoYW5nZWQiLCJfZGlmZlVwZGF0ZVRyaWdnZXJzIiwibG9nIiwicmVhc29uIiwiY2xlYXJSZWRyYXdGbGFncyIsImdldE5lZWRzUmVkcmF3IiwiY2hhbmdlIiwicHJvcE5hbWUiLCJvbGRUcmlnZ2VycyIsIm5ld1RyaWdnZXJzIiwiZGlmZlJlYXNvbiIsInByb3BlcnR5TmFtZSIsImNvbmRpdGlvbiIsIm9sZFByb3AiLCJuZXdQcm9wIiwibWVzc2FnZSIsInBvdyIsIk9ORSIsInVuaWZvcm1NYXAiLCJnZXRPd25Qcm9wZXJ0eSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImxheWVyIiwibWVyZ2VEZWZhdWx0UHJvcHMiLCJzdWJDbGFzc0NvbnN0cnVjdG9yIiwibGF5ZXJEZWZhdWx0UHJvcHMiLCJnZXRQcm90b3R5cGVPZiIsIlRFU1RfRVhQT1JUUyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFNQSxzQkFBc0IsQ0FBNUI7O0FBRUE7Ozs7O0FBS0EsSUFBTUMsZUFBZTtBQUNuQkMsa0JBQWdCLElBREc7QUFFbkJDLGdCQUFjQyxTQUZLO0FBR25CQyxXQUFTLElBSFU7QUFJbkJDLFlBQVUsS0FKUztBQUtuQkMsV0FBUyxHQUxVO0FBTW5CQyxXQUFTLG1CQUFNLENBQUUsQ0FORTtBQU9uQkMsV0FBUyxtQkFBTSxDQUFFLENBUEU7QUFRbkI7QUFDQTtBQUNBQyxrQkFBZ0IsRUFWRztBQVduQkMsa0JBQWdCLDZCQUFrQkM7QUFYZixDQUFyQjs7QUFjQSxJQUFJQyxVQUFVLENBQWQ7O0lBRXFCQyxLO0FBQ25COzs7O0FBSUEsaUJBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFDakI7QUFDQSxRQUFNQyxxQkFBcUJDLGdCQUFnQixJQUFoQixDQUEzQjtBQUNBO0FBQ0FGLFlBQVFHLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCSCxrQkFBbEIsRUFBc0NELEtBQXRDLENBQVI7QUFDQTtBQUNBQSxVQUFNSyxJQUFOLEdBQWFMLE1BQU1LLElBQU4sSUFBYyxFQUEzQjtBQUNBO0FBQ0FGLFdBQU9HLE1BQVAsQ0FBY04sS0FBZDs7QUFFQTtBQUNBLFNBQUtPLEVBQUwsR0FB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aWxlIjoibGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IEF0dHJpYnV0ZU1hbmFnZXIgZnJvbSAnLi9hdHRyaWJ1dGUtbWFuYWdlcic7XG5pbXBvcnQge2xvZywgY29tcGFyZVByb3BzLCBjb3VudH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge0dMfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgTE9HX1BSSU9SSVRZX1VQREFURSA9IDI7XG5cbi8qXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuaWQgLSBsYXllciBuYW1lXG4gKiBAcGFyYW0ge2FycmF5fSAgcHJvcHMuZGF0YSAtIGFycmF5IG9mIGRhdGEgaW5zdGFuY2VzXG4gKiBAcGFyYW0ge2Jvb2x9IHByb3BzLm9wYWNpdHkgLSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICovXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGRhdGFDb21wYXJhdG9yOiBudWxsLFxuICBudW1JbnN0YW5jZXM6IHVuZGVmaW5lZCxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgcGlja2FibGU6IGZhbHNlLFxuICBvcGFjaXR5OiAwLjgsXG4gIG9uSG92ZXI6ICgpID0+IHt9LFxuICBvbkNsaWNrOiAoKSA9PiB7fSxcbiAgLy8gVXBkYXRlIHRyaWdnZXJzOiBhIGtleSBjaGFuZ2UgZGV0ZWN0aW9uIG1lY2hhbmlzbSBpbiBkZWNrLmdsXG4gIC8vIFNlZSBsYXllciBkb2N1bWVudGF0aW9uXG4gIHVwZGF0ZVRyaWdnZXJzOiB7fSxcbiAgcHJvamVjdGlvbk1vZGU6IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVFxufTtcblxubGV0IGNvdW50ZXIgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllciB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gU2VlIGRvY3MgYW5kIGRlZmF1bHRzIGFib3ZlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIC8vIElmIHN1YmxheWVyIGhhcyBzdGF0aWMgZGVmYXVsdFByb3BzIG1lbWJlciwgZ2V0RGVmYXVsdFByb3BzIHdpbGwgcmV0dXJuIGl0XG4gICAgY29uc3QgbWVyZ2VkRGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzKHRoaXMpO1xuICAgIC8vIE1lcmdlIHN1cHBsaWVkIHByb3BzIHdpdGggcHJlLW1lcmdlZCBkZWZhdWx0IHByb3BzXG4gICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtZXJnZWREZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAvLyBBY2NlcHQgbnVsbCBhcyBkYXRhIC0gb3RoZXJ3aXNlIGFwcHMgYW5kIGxheWVycyBuZWVkIHRvIGFkZCB1Z2x5IGNoZWNrc1xuICAgIHByb3BzLmRhdGEgPSBwcm9wcy5kYXRhIHx8IFtdO1xuICAgIC8vIFByb3BzIGFyZSBpbW11dGFibGVcbiAgICBPYmplY3QuZnJlZXplKHByb3BzKTtcblxuICAgIC8vIERlZmluZSBhbGwgbWVtYmVycyBhbmQgZnJlZXplIGxheWVyXG4gICAgdGhpcy5pZCA9IHByb3BzLmlkO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLm9sZFByb3BzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50TGF5ZXIgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSBjb3VudGVyKys7XG4gICAgdGhpcy5saWZlY3ljbGUgPSAnQXdhaXRpbmcgc3RhdGUnO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXllck5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBjbGFzc05hbWUgIT09IHRoaXMucHJvcHMuaWQgPyBgPCR7Y2xhc3NOYW1lfTonJHt0aGlzLnByb3BzLmlkfSc+YCA6IGA8JHtjbGFzc05hbWV9PmA7XG4gIH1cblxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBMSUZFQ1lDTEUgTUVUSE9EUywgb3ZlcnJpZGRlbiBieSB0aGUgbGF5ZXIgc3ViY2xhc3Nlc1xuXG4gIC8vIENhbGxlZCBvbmNlIHRvIHNldCB1cCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAvLyBBcHAgY2FuIGNyZWF0ZSBXZWJHTCByZXNvdXJjZXNcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgJHt0aGlzfSBoYXMgbm90IGRlZmluZWQgaW5pdGlhbGl6ZVN0YXRlYCk7XG4gIH1cblxuICAvLyBMZXQncyBsYXllciBjb250cm9sIGlmIHVwZGF0ZVN0YXRlIHNob3VsZCBiZSBjYWxsZWRcbiAgc2hvdWxkVXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgcmV0dXJuIGNoYW5nZUZsYWdzLnNvbWV0aGluZ0NoYW5nZWQ7XG4gIH1cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLCBhbGwgYXR0cmlidXRlcyB3aWxsIGJlIGludmFsaWRhdGVkIGFuZCB1cGRhdGVkXG4gIC8vIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIG9sZENvbnRleHQsIGNvbnRleHQsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb25jZSB3aGVuIGxheWVyIGlzIG5vIGxvbmdlciBtYXRjaGVkIGFuZCBzdGF0ZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAvLyBBcHAgY2FuIGRlc3Ryb3kgV2ViR0wgcmVzb3VyY2VzIGhlcmVcbiAgZmluYWxpemVTdGF0ZSgpIHtcbiAgfVxuXG4gIC8vIEltcGxlbWVudCB0byBnZW5lcmF0ZSBzdWJsYXllcnNcbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgc3RhdGUgaGFzIGEgbW9kZWwsIGRyYXcgaXQgd2l0aCBzdXBwbGllZCB1bmlmb3Jtc1xuICBkcmF3KHt1bmlmb3JtcyA9IHt9fSkge1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsbGVkIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlclxuICAvLyBAcmV0dXJuIG51bGwgdG8gY2FuY2VsIGV2ZW50XG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvLCBtb2RlfSkge1xuICAgIGNvbnN0IHtjb2xvciwgaW5kZXh9ID0gaW5mbztcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAvLyBJZiBwcm9wcy5kYXRhIGlzIGFuIGluZGV4YWJsZSBhcnJheSwgZ2V0IHRoZSBvYmplY3RcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuZGF0YSkpIHtcbiAgICAgICAgaW5mby5vYmplY3QgPSB0aGlzLnByb3BzLmRhdGFbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gLSBtb3ZlIHRvIHRoZSBKUyBwYXJ0IG9mIGEgc2hhZGVyIHBpY2tpbmcgc2hhZGVyIHBhY2thZ2VcbiAgICBpZiAobW9kZSA9PT0gJ2hvdmVyJykge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRQaWNraW5nQ29sb3IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMF0gPSBjb2xvclswXTtcbiAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzFdID0gY29sb3JbMV07XG4gICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclsyXSA9IGNvbG9yWzJdO1xuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7c2VsZWN0ZWRQaWNraW5nQ29sb3J9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIC8vIEVORCBMSUZFQ1lDTEUgTUVUSE9EU1xuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYXR0cmlidXRlIGludmFsaWRhdGlvbiwgY2FuIGJlIHJlZGVmaW5lXG4gIGludmFsaWRhdGVBdHRyaWJ1dGUobmFtZSA9ICdhbGwnKSB7XG4gICAgaWYgKG5hbWUgPT09ICdhbGwnKSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZShuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxscyBhdHRyaWJ1dGUgbWFuYWdlciB0byB1cGRhdGUgYW55IFdlYkdMIGF0dHJpYnV0ZXMsIGNhbiBiZSByZWRlZmluZWRcbiAgdXBkYXRlQXR0cmlidXRlcyhwcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IHRoaXMuZ2V0TnVtSW5zdGFuY2VzKHByb3BzKTtcbiAgICAvLyBGaWd1cmUgb3V0IGRhdGEgbGVuZ3RoXG4gICAgYXR0cmlidXRlTWFuYWdlci51cGRhdGUoe1xuICAgICAgZGF0YTogcHJvcHMuZGF0YSxcbiAgICAgIG51bUluc3RhbmNlcyxcbiAgICAgIHByb3BzLFxuICAgICAgYnVmZmVyczogcHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgLy8gRG9uJ3Qgd29ycnkgYWJvdXQgbm9uLWF0dHJpYnV0ZSBwcm9wc1xuICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlTWFuYWdlci5nZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3M6IHRydWV9KTtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoY2hhbmdlZEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRTdGF0ZSh1cGRhdGVPYmplY3QpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHVwZGF0ZU9iamVjdCk7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cblxuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSByZWRyYXc7XG4gICAgfVxuICB9XG5cbiAgLy8gUFJPSkVDVElPTiBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGEgcG9pbnQgd2l0aCBjdXJyZW50IG1hcCBzdGF0ZSAobGF0LCBsb24sIHpvb20sIHBpdGNoLCBiZWFyaW5nKVxuICAgKlxuICAgKiBOb3RlOiBQb3NpdGlvbiBjb252ZXJzaW9uIGlzIGRvbmUgaW4gc2hhZGVyLCBzbyBpbiBtYW55IGNhc2VzIHRoZXJlIGlzIG5vIG5lZWRcbiAgICogZm9yIHRoaXMgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBsbmdMYXQgLSBsb25nIGFuZCBsYXQgdmFsdWVzXG4gICAqIEByZXR1cm4ge0FycmF5fFR5cGVkQXJyYXl9IC0geCwgeSBjb29yZGluYXRlc1xuICAgKi9cbiAgcHJvamVjdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3QoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICB9XG5cbiAgcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdEZsYXQobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3RGbGF0KHh5KTtcbiAgfVxuXG4gIHNjcmVlblRvRGV2aWNlUGl4ZWxzKHNjcmVlblBpeGVscykge1xuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgcmV0dXJuIHNjcmVlblBpeGVscyAqIGRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBhIGJsYWNrIGNvbG9yXG4gICAqL1xuICBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge2ludH0gaSAtIGluZGV4IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgY29sb3JcbiAgICovXG4gIGVuY29kZVBpY2tpbmdDb2xvcihpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIChpICsgMSkgJSAyNTYsXG4gICAgICBNYXRoLmZsb29yKChpICsgMSkgLyAyNTYpICUgMjU2LFxuICAgICAgTWF0aC5mbG9vcigoaSArIDEpIC8gMjU2IC8gMjU2KSAlIDI1NlxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbG9yIC0gY29sb3IgYXJyYXkgdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBwaWNraW5nIGNvbG9yXG4gICAqL1xuICBkZWNvZGVQaWNraW5nQ29sb3IoY29sb3IpIHtcbiAgICBhc3NlcnQoY29sb3IgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBjb25zdCBbaTEsIGkyLCBpM10gPSBjb2xvcjtcbiAgICAvLyAxIHdhcyBhZGRlZCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGNvbnN0IGluZGV4ID0gaTEgKyBpMiAqIDI1NiArIGkzICogNjU1MzYgLSAxO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUsIHtudW1JbnN0YW5jZXN9KSB7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICAvLyBhZGQgMSB0byBpbmRleCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5zdGFuY2VzOyBpKyspIHtcbiAgICAgIGNvbnN0IHBpY2tpbmdDb2xvciA9IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKGkpO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHBpY2tpbmdDb2xvclswXTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMV0gPSBwaWNraW5nQ29sb3JbMV07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gcGlja2luZ0NvbG9yWzJdO1xuICAgIH1cbiAgfVxuXG4gIC8vIERBVEEgQUNDRVNTIEFQSVxuICAvLyBEYXRhIGNhbiB1c2UgaXRlcmF0b3JzIGFuZCBtYXkgbm90IGJlIHJhbmRvbSBhY2Nlc3NcblxuICAvLyBVc2UgaXRlcmF0aW9uICh0aGUgb25seSByZXF1aXJlZCBjYXBhYmlsaXR5IG9uIGRhdGEpIHRvIGdldCBmaXJzdCBlbGVtZW50XG4gIGdldEZpcnN0T2JqZWN0KCkge1xuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMucHJvcHM7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gRGVkdWNlcyBudW1lciBvZiBpbnN0YW5jZXMuIEludGVudGlvbiBpcyB0byBzdXBwb3J0OlxuICAvLyAtIEV4cGxpY2l0IHNldHRpbmcgb2YgbnVtSW5zdGFuY2VzXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgc2l6ZSBtZW1iZXJcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgQ2xhc3NpYyBBcnJheXMgdmlhIHRoZSBidWlsdC1pbiBsZW5ndGggYXR0cmlidXRlXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gdmlhIGFycmF5c1xuICBnZXROdW1JbnN0YW5jZXMocHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgbGF5ZXIgaGFzIHNldCBpdHMgb3duIHZhbHVlXG4gICAgaWYgKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFwcCBoYXMgcHJvdmlkZWQgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBpZiAocHJvcHMubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLy8gVXNlIGNvbnRhaW5lciBsaWJyYXJ5IHRvIGdldCBhIGNvdW50IGZvciBhbnkgRVM2IGNvbnRhaW5lciBvciBvYmplY3RcbiAgICBjb25zdCB7ZGF0YX0gPSBwcm9wcztcbiAgICByZXR1cm4gY291bnQoZGF0YSk7XG4gIH1cblxuICAvLyBMQVlFUiBNQU5BR0VSIEFQSVxuICAvLyBTaG91bGQgb25seSBiZSBjYWxsZWQgYnkgdGhlIGRlY2suZ2wgTGF5ZXJNYW5hZ2VyIGNsYXNzXG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBhIG5ldyBsYXllciBpcyBmb3VuZFxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBpbml0aWFsaXplTGF5ZXIodXBkYXRlUGFyYW1zKSB7XG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC5nbCwgJ0xheWVyIGNvbnRleHQgbWlzc2luZyBnbCcpO1xuICAgIGFzc2VydCghdGhpcy5zdGF0ZSwgJ0xheWVyIG1pc3Npbmcgc3RhdGUnKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7fTtcblxuICAgIC8vIEluaXRpYWxpemUgc3RhdGUgb25seSBvbmNlXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyOiBuZXcgQXR0cmlidXRlTWFuYWdlcih7aWQ6IHRoaXMucHJvcHMuaWR9KSxcbiAgICAgIG1vZGVsOiBudWxsLFxuICAgICAgbmVlZHNSZWRyYXc6IHRydWUsXG4gICAgICBkYXRhQ2hhbmdlZDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBBbGwgaW5zdGFuY2VkIGxheWVycyBnZXQgaW5zdGFuY2VQaWNraW5nQ29sb3JzIGF0dHJpYnV0ZSBieSBkZWZhdWx0XG4gICAgLy8gVGhlaXIgc2hhZGVycyBjYW4gdXNlIGl0IHRvIHJlbmRlciBhIHBpY2tpbmcgc2NlbmVcbiAgICAvLyBUT0RPIC0gdGhpcyBzbG93cyBkb3duIG5vbiBpbnN0YW5jZWQgbGF5ZXJzXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcbiAgICB0aGlzLmluaXRpYWxpemVTdGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAvLyBFbmQgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcblxuICAgIC8vIEFkZCBhbnkgc3ViY2xhc3MgYXR0cmlidXRlc1xuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcyh0aGlzLnByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcblxuICAgIGNvbnN0IHttb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgbW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLmdldE51bUluc3RhbmNlcygpKTtcbiAgICAgIG1vZGVsLmlkID0gdGhpcy5wcm9wcy5pZDtcbiAgICAgIG1vZGVsLnByb2dyYW0uaWQgPSBgJHt0aGlzLnByb3BzLmlkfS1wcm9ncmFtYDtcbiAgICAgIG1vZGVsLmdlb21ldHJ5LmlkID0gYCR7dGhpcy5wcm9wcy5pZH0tZ2VvbWV0cnlgO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVNYW5hZ2VyLmdldEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBleGlzdGluZyBsYXllciBpcyBnZXR0aW5nIG5ldyBwcm9wc1xuICB1cGRhdGVMYXllcih1cGRhdGVQYXJhbXMpIHtcbiAgICAvLyBDaGVjayBmb3IgZGVwcmVjYXRlZCBtZXRob2RcbiAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUpIHtcbiAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIHYzICR7dGhpc306IFwic2hvdWxkVXBkYXRlXCIgZGVwcmVjYXRlZCwgcmVuYW1lZCB0byBcInNob3VsZFVwZGF0ZVN0YXRlXCJgKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICBjb25zdCBzdGF0ZU5lZWRzVXBkYXRlID0gdGhpcy5zaG91bGRVcGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICBpZiAoc3RhdGVOZWVkc1VwZGF0ZSkge1xuICAgICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgICAvLyBSdW4gdGhlIGF0dHJpYnV0ZSB1cGRhdGVyc1xuICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVzKHVwZGF0ZVBhcmFtcy5wcm9wcyk7XG4gICAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLy8gQ2FsbGVkIGJ5IG1hbmFnZXIgd2hlbiBsYXllciBpcyBhYm91dCB0byBiZSBkaXNwb3NlZFxuICAvLyBOb3RlOiBub3QgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgb24gYXBwbGljYXRpb24gc2h1dGRvd25cbiAgZmluYWxpemVMYXllcigpIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmZpbmFsaXplU3RhdGUoKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyB1bmlmb3Jtc1xuICBkcmF3TGF5ZXIoe3VuaWZvcm1zID0ge319KSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgdGhpcy5kcmF3KHt1bmlmb3Jtc30pO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyB7dW5pZm9ybXMgPSB7fSwgLi4ub3B0c31cbiAgcGlja0xheWVyKG9wdHMpIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICByZXR1cm4gdGhpcy5nZXRQaWNraW5nSW5mbyhvcHRzKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgZGlmZlByb3BzKG9sZFByb3BzLCBuZXdQcm9wcywgY29udGV4dCkge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGFueSBwcm9wcyBoYXZlIGNoYW5nZWQgKGlnbm9yZSBwcm9wcyB0aGF0IHdpbGwgYmUgZXhhbWluZWQgc2VwYXJhdGVseSlcbiAgICBjb25zdCBwcm9wc0NoYW5nZWRSZWFzb24gPSBjb21wYXJlUHJvcHMoe1xuICAgICAgbmV3UHJvcHMsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIGlnbm9yZVByb3BzOiB7ZGF0YTogbnVsbCwgdXBkYXRlVHJpZ2dlcnM6IG51bGx9XG4gICAgfSk7XG5cbiAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGRhdGEgcmVsYXRlZCBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICBjb25zdCBkYXRhQ2hhbmdlZFJlYXNvbiA9IHRoaXMuX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKTtcblxuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9IEJvb2xlYW4ocHJvcHNDaGFuZ2VkUmVhc29uKTtcbiAgICBjb25zdCBkYXRhQ2hhbmdlZCA9IEJvb2xlYW4oZGF0YUNoYW5nZWRSZWFzb24pO1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IGNvbnRleHQudmlld3BvcnRDaGFuZ2VkO1xuICAgIGNvbnN0IHNvbWV0aGluZ0NoYW5nZWQgPSBwcm9wc0NoYW5nZWQgfHwgZGF0YUNoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkO1xuXG4gICAgLy8gQ2hlY2sgdXBkYXRlIHRyaWdnZXJzIHRvIGRldGVybWluZSBpZiBhbnkgYXR0cmlidXRlcyBuZWVkIHJlZ2VuZXJhdGlvblxuICAgIC8vIE5vdGUgLSBpZiBkYXRhIGhhcyBjaGFuZ2VkLCBhbGwgYXR0cmlidXRlcyB3aWxsIG5lZWQgcmVnZW5lcmF0aW9uLCBzbyBza2lwIHRoaXMgc3RlcFxuICAgIGlmICghZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2RpZmZVcGRhdGVUcmlnZ2VycyhvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cubG9nKDIsIGBkYXRhQ2hhbmdlZDogJHtkYXRhQ2hhbmdlZH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJvcHNDaGFuZ2VkLFxuICAgICAgZGF0YUNoYW5nZWQsXG4gICAgICB2aWV3cG9ydENoYW5nZWQsXG4gICAgICBzb21ldGhpbmdDaGFuZ2VkLFxuICAgICAgcmVhc29uOiBkYXRhQ2hhbmdlZFJlYXNvbiB8fCBwcm9wc0NoYW5nZWRSZWFzb25cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2hlY2tzIHN0YXRlIG9mIGF0dHJpYnV0ZXMgYW5kIG1vZGVsXG4gIC8vIFRPRE8gLSBpcyBhdHRyaWJ1dGUgbWFuYWdlciBuZWVkZWQ/IC0gTW9kZWwgc2hvdWxkIGJlIGVub3VnaC5cbiAgZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIC8vIHRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYnkgdGhlIHJlbmRlciBsb29wIGFzIHNvb24gYSB0aGUgbGF5ZXJcbiAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLCBzbyBndWFyZCBhZ2FpbnN0IHVuaW5pdGlhbGl6ZWQgc3RhdGVcbiAgICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkcmF3ID0gZmFsc2U7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMuc3RhdGUubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlciwgbW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgKGF0dHJpYnV0ZU1hbmFnZXIgJiYgYXR0cmlidXRlTWFuYWdlci5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pKTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgKG1vZGVsICYmIG1vZGVsLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSkpO1xuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIFRoZSBjb21wYXJpc29uIG9mIHRoZSBkYXRhIHByb3AgcmVxdWlyZXMgc3BlY2lhbCBoYW5kbGluZ1xuICAvLyB0aGUgZGF0YUNvbXBhcmF0b3Igc2hvdWxkIGJlIHVzZWQgaWYgc3VwcGxpZWRcbiAgX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgLy8gU3VwcG9ydCBvcHRpb25hbCBhcHAgZGVmaW5lZCBjb21wYXJpc29uIG9mIGRhdGFcbiAgICBjb25zdCB7ZGF0YUNvbXBhcmF0b3J9ID0gbmV3UHJvcHM7XG4gICAgaWYgKGRhdGFDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoIWRhdGFDb21wYXJhdG9yKG5ld1Byb3BzLmRhdGEsIG9sZFByb3BzLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnRGF0YSBjb21wYXJhdG9yIGRldGVjdGVkIGEgY2hhbmdlJztcbiAgICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGRvIGEgc2hhbGxvdyBlcXVhbCBvbiBwcm9wc1xuICAgIH0gZWxzZSBpZiAobmV3UHJvcHMuZGF0YSAhPT0gb2xkUHJvcHMuZGF0YSkge1xuICAgICAgcmV0dXJuICdBIG5ldyBkYXRhIGNvbnRhaW5lciB3YXMgc3VwcGxpZWQnO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGFueSB1cGRhdGUgdHJpZ2dlcnMgaGF2ZSBjaGFuZ2VkLCBhbmQgaW52YWxpZGF0ZVxuICAvLyBhdHRyaWJ1dGVzIGFjY29yZGluZ2x5LlxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIC8vIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgLy8gY29uc3QgdXBkYXRlVHJpZ2dlck1hcCA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0VXBkYXRlVHJpZ2dlck1hcCgpO1xuXG4gICAgbGV0IGNoYW5nZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBuZXdQcm9wcy51cGRhdGVUcmlnZ2Vycykge1xuICAgICAgY29uc3Qgb2xkVHJpZ2dlcnMgPSBvbGRQcm9wcy51cGRhdGVUcmlnZ2Vyc1twcm9wTmFtZV0gfHwge307XG4gICAgICBjb25zdCBuZXdUcmlnZ2VycyA9IG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgIGNvbnN0IGRpZmZSZWFzb24gPSBjb21wYXJlUHJvcHMoe1xuICAgICAgICBvbGRQcm9wczogb2xkVHJpZ2dlcnMsXG4gICAgICAgIG5ld1Byb3BzOiBuZXdUcmlnZ2Vyc1xuICAgICAgfSk7XG4gICAgICBpZiAoZGlmZlJlYXNvbikge1xuICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfVVBEQVRFLFxuICAgICAgICAgICAgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhbGwgYXR0cmlidXRlczogJHtkaWZmUmVhc29ufWApO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZSgnYWxsJyk7XG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUsXG4gICAgICAgICAgICBgdXBkYXRlVHJpZ2dlcnMgaW52YWxpZGF0aW5nIGF0dHJpYnV0ZSAke3Byb3BOYW1lfTogJHtkaWZmUmVhc29ufWApO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZShwcm9wTmFtZSk7XG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIF9jaGVja1JlcXVpcmVkUHJvcChwcm9wZXJ0eU5hbWUsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wc1twcm9wZXJ0eU5hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSB1bmRlZmluZWQgaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uICYmICFjb25kaXRpb24odmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVtaXRzIGEgd2FybmluZyBpZiBhbiBvbGQgcHJvcCBpcyB1c2VkLCBvcHRpb25hbGx5IHN1Z2dlc3RpbmcgYSByZXBsYWNlbWVudFxuICBfY2hlY2tSZW1vdmVkUHJvcChvbGRQcm9wLCBuZXdQcm9wID0gbnVsbCkge1xuICAgIGlmICh0aGlzLnByb3BzW29sZFByb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGxheWVyTmFtZSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICBsZXQgbWVzc2FnZSA9IGAke2xheWVyTmFtZX0gbm8gbG9uZ2VyIGFjY2VwdHMgcHJvcHMuJHtvbGRQcm9wfSBpbiB0aGlzIHZlcnNpb24gb2YgZGVjay5nbC5gO1xuICAgICAgaWYgKG5ld1Byb3ApIHtcbiAgICAgICAgbWVzc2FnZSArPSBgXFxuUGxlYXNlIHVzZSBwcm9wcy4ke25ld1Byb3B9IGluc3RlYWQuYDtcbiAgICAgIH1cbiAgICAgIGxvZy5vbmNlKDAsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVCYXNlVW5pZm9ybXMoKSB7XG4gICAgdGhpcy5zZXRVbmlmb3Jtcyh7XG4gICAgICAvLyBhcHBseSBnYW1tYSB0byBvcGFjaXR5IHRvIG1ha2UgaXQgdmlzdWFsbHkgXCJsaW5lYXJcIlxuICAgICAgb3BhY2l0eTogTWF0aC5wb3codGhpcy5wcm9wcy5vcGFjaXR5LCAxIC8gMi4yKSxcbiAgICAgIE9ORTogMS4wXG4gICAgfSk7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybU1hcCk7XG4gICAgfVxuICAgIC8vIFRPRE8gLSBzZXQgbmVlZHNSZWRyYXcgb24gdGhlIG1vZGVsP1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIGxvZygzLCAnbGF5ZXIuc2V0VW5pZm9ybXMnLCB1bmlmb3JtTWFwKTtcbiAgfVxufVxuXG5MYXllci5sYXllck5hbWUgPSAnTGF5ZXInO1xuTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4vLyBIRUxQRVJTXG5cbi8vIENvbnN0cnVjdG9ycyBoYXZlIHRoZWlyIHN1cGVyIGNsYXNzIGNvbnN0cnVjdG9ycyBhcyBwcm90b3R5cGVzXG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eShvYmplY3QsIHByb3ApIHtcbiAgcmV0dXJuIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBvYmplY3RbcHJvcF07XG59XG4vKlxuICogUmV0dXJuIG1lcmdlZCBkZWZhdWx0IHByb3BzIHN0b3JlZCBvbiBsYXllcnMgY29uc3RydWN0b3IsIGNyZWF0ZSB0aGVtIGlmIG5lZWRlZFxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMobGF5ZXIpIHtcbiAgY29uc3QgbWVyZ2VkRGVmYXVsdFByb3BzID0gZ2V0T3duUHJvcGVydHkobGF5ZXIuY29uc3RydWN0b3IsICdtZXJnZWREZWZhdWx0UHJvcHMnKTtcbiAgaWYgKG1lcmdlZERlZmF1bHRQcm9wcykge1xuICAgIHJldHVybiBtZXJnZWREZWZhdWx0UHJvcHM7XG4gIH1cbiAgcmV0dXJuIG1lcmdlRGVmYXVsdFByb3BzKGxheWVyKTtcbn1cblxuLypcbiAqIFdhbGsgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgbWVyZ2UgYWxsIGRlZmF1bHQgcHJvcHNcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0UHJvcHMobGF5ZXIpIHtcbiAgY29uc3Qgc3ViQ2xhc3NDb25zdHJ1Y3RvciA9IGxheWVyLmNvbnN0cnVjdG9yO1xuICBjb25zdCBsYXllck5hbWUgPSBnZXRPd25Qcm9wZXJ0eShzdWJDbGFzc0NvbnN0cnVjdG9yLCAnbGF5ZXJOYW1lJyk7XG4gIGlmICghbGF5ZXJOYW1lKSB7XG4gICAgbG9nLm9uY2UoMCwgYGxheWVyICR7bGF5ZXIuY29uc3RydWN0b3IubmFtZX0gZG9lcyBub3Qgc3BlY2lmeSBhIFwibGF5ZXJOYW1lXCJgKTtcbiAgfVxuICBsZXQgbWVyZ2VkRGVmYXVsdFByb3BzID0ge1xuICAgIGlkOiBsYXllck5hbWUgfHwgbGF5ZXIuY29uc3RydWN0b3IubmFtZVxuICB9O1xuXG4gIHdoaWxlIChsYXllcikge1xuICAgIGNvbnN0IGxheWVyRGVmYXVsdFByb3BzID0gZ2V0T3duUHJvcGVydHkobGF5ZXIuY29uc3RydWN0b3IsICdkZWZhdWx0UHJvcHMnKTtcbiAgICBPYmplY3QuZnJlZXplKGxheWVyRGVmYXVsdFByb3BzKTtcbiAgICBpZiAobGF5ZXJEZWZhdWx0UHJvcHMpIHtcbiAgICAgIG1lcmdlZERlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGxheWVyRGVmYXVsdFByb3BzLCBtZXJnZWREZWZhdWx0UHJvcHMpO1xuICAgIH1cbiAgICBsYXllciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihsYXllcik7XG4gIH1cbiAgLy8gU3RvcmUgZm9yIHF1aWNrIGxvb2t1cFxuICBzdWJDbGFzc0NvbnN0cnVjdG9yLm1lcmdlZERlZmF1bHRQcm9wcyA9IG1lcmdlZERlZmF1bHRQcm9wcztcbiAgcmV0dXJuIG1lcmdlZERlZmF1bHRQcm9wcztcbn1cblxuZXhwb3J0IGNvbnN0IFRFU1RfRVhQT1JUUyA9IHtcbiAgbWVyZ2VEZWZhdWx0UHJvcHNcbn07XG4iXX0=