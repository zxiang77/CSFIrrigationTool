"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatten = flatten;
exports.countVertices = countVertices;
exports.flattenVertices = flattenVertices;
exports.fillArray = fillArray;
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Flattens a nested array into a single level array
 * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
 * @param {Array} array The array to flatten.
 * @return {Array} Returns the new flattened array.
 */
function flatten(array) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var index = -1;
  while (++index < array.length) {
    var value = array[index];
    if (Array.isArray(value)) {
      flatten(value, result);
    } else {
      result.push(value);
    }
  }
  return result;
}

function countVertices(nestedArray) {
  var count = 0;
  var index = -1;
  while (++index < nestedArray.length) {
    var value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      count += countVertices(value);
    } else {
      count++;
    }
  }
  return count;
}

// Flattens nested array of vertices, padding third coordinate as needed
function flattenVertices(nestedArray) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$result = _ref.result,
      result = _ref$result === undefined ? [] : _ref$result,
      _ref$dimensions = _ref.dimensions,
      dimensions = _ref$dimensions === undefined ? 3 : _ref$dimensions;

  var index = -1;
  var vertexLength = 0;
  while (++index < nestedArray.length) {
    var value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      flattenVertices(value, { result: result, dimensions: dimensions });
    } else {
      if (vertexLength < dimensions) {
        // eslint-disable-line
        result.push(value);
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }
  return result;
}

// Uses copyWithin to significantly speed up typed array value filling
function fillArray(_ref2) {
  var target = _ref2.target,
      source = _ref2.source,
      _ref2$start = _ref2.start,
      start = _ref2$start === undefined ? 0 : _ref2$start,
      _ref2$count = _ref2.count,
      count = _ref2$count === undefined ? 1 : _ref2$count;

  var total = count * source.length;
  var copied = 0;
  for (var i = 0; i < source.length; ++i) {
    target[start + copied++] = source[i];
  }

  while (copied < total) {
    // If we have copied less than half, copy everything we got
    // else copy remaining in one operation
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}

// Flattens nested array of vertices, padding third coordinate as needed
/*
export function flattenTypedVertices(nestedArray, {
  result = [],
  Type = Float32Array,
  start = 0,
  dimensions = 3
} = {}) {
  let index = -1;
  let vertexLength = 0;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      start = flattenTypedVertices(value, {result, start, dimensions});
    } else {
      if (vertexLength < dimensions) { // eslint-disable-line
        result[start++] = value;
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result[start++] = 0;
  }
  return start;
}
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvZmxhdHRlbi5qcyJdLCJuYW1lcyI6WyJmbGF0dGVuIiwiY291bnRWZXJ0aWNlcyIsImZsYXR0ZW5WZXJ0aWNlcyIsImZpbGxBcnJheSIsImFycmF5IiwicmVzdWx0IiwiaW5kZXgiLCJsZW5ndGgiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJuZXN0ZWRBcnJheSIsImNvdW50IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJkaW1lbnNpb25zIiwidmVydGV4TGVuZ3RoIiwidGFyZ2V0Iiwic291cmNlIiwic3RhcnQiLCJ0b3RhbCIsImNvcGllZCIsImkiLCJjb3B5V2l0aGluIl0sIm1hcHBpbmdzIjoiOzs7OztRQTBCZ0JBLE8sR0FBQUEsTztRQWFBQyxhLEdBQUFBLGE7UUFlQUMsZSxHQUFBQSxlO1FBc0JBQyxTLEdBQUFBLFM7QUE1RWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNTyxTQUFTSCxPQUFULENBQWlCSSxLQUFqQixFQUFxQztBQUFBLE1BQWJDLE1BQWEsdUVBQUosRUFBSTs7QUFDMUMsTUFBSUMsUUFBUSxDQUFDLENBQWI7QUFDQSxTQUFPLEVBQUVBLEtBQUYsR0FBVUYsTUFBTUcsTUFBdkIsRUFBK0I7QUFDN0IsUUFBTUMsUUFBUUosTUFBTUUsS0FBTixDQUFkO0FBQ0EsUUFBSUcsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUosRUFBMEI7QUFDeEJSLGNBQVFRLEtBQVIsRUFBZUgsTUFBZjtBQUNELEtBRkQsTUFFTztBQUNMQSxhQUFPTSxJQUFQLENBQVlILEtBQVo7QUFDRDtBQUNGO0FBQ0QsU0FBT0gsTUFBUDtBQUNEOztBQUVNLFNBQVNKLGFBQVQsQ0FBdUJXLFdBQXZCLEVBQW9DO0FBQ3pDLE1BQUlDLFFBQVEsQ0FBWjtBQUNBLE1BQUlQLFFBQVEsQ0FBQyxDQUFiO0FBQ0EsU0FBTyxFQUFFQSxLQUFGLEdBQVVNLFlBQVlMLE1BQTdCLEVBQXFDO0FBQ25DLFFBQU1DLFFBQVFJLFlBQVlOLEtBQVosQ0FBZDtBQUNBLFFBQUlHLE1BQU1DLE9BQU4sQ0FBY0YsS0FBZCxLQUF3Qk0sWUFBWUMsTUFBWixDQUFtQlAsS0FBbkIsQ0FBNUIsRUFBdUQ7QUFDckRLLGVBQVNaLGNBQWNPLEtBQWQsQ0FBVDtBQUNELEtBRkQsTUFFTztBQUNMSztBQUNEO0FBQ0Y7QUFDRCxTQUFPQSxLQUFQO0FBQ0Q7O0FBRUQ7QUFDTyxTQUFTWCxlQUFULENBQXlCVSxXQUF6QixFQUEwRTtBQUFBLGlGQUFKLEVBQUk7QUFBQSx5QkFBbkNQLE1BQW1DO0FBQUEsTUFBbkNBLE1BQW1DLCtCQUExQixFQUEwQjtBQUFBLDZCQUF0QlcsVUFBc0I7QUFBQSxNQUF0QkEsVUFBc0IsbUNBQVQsQ0FBUzs7QUFDL0UsTUFBSVYsUUFBUSxDQUFDLENBQWI7QUFDQSxNQUFJVyxlQUFlLENBQW5CO0FBQ0EsU0FBTyxFQUFFWCxLQUFGLEdBQVVNLFlBQVlMLE1BQTdCLEVBQXFDO0FBQ25DLFFBQU1DLFFBQVFJLFlBQVlOLEtBQVosQ0FBZDtBQUNBLFFBQUlHLE1BQU1DLE9BQU4sQ0FBY0YsS0FBZCxLQUF3Qk0sWUFBWUMsTUFBWixDQUFtQlAsS0FBbkIsQ0FBNUIsRUFBdUQ7QUFDckROLHNCQUFnQk0sS0FBaEIsRUFBdUIsRUFBQ0gsY0FBRCxFQUFTVyxzQkFBVCxFQUF2QjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUlDLGVBQWVELFVBQW5CLEVBQStCO0FBQUU7QUFDL0JYLGVBQU9NLElBQVAsQ0FBWUgsS0FBWjtBQUNBUztBQUNEO0FBQ0Y7QUFDRjtBQUNEO0FBQ0EsTUFBSUEsZUFBZSxDQUFmLElBQW9CQSxlQUFlRCxVQUF2QyxFQUFtRDtBQUNqRFgsV0FBT00sSUFBUCxDQUFZLENBQVo7QUFDRDtBQUNELFNBQU9OLE1BQVA7QUFDRDs7QUFFRDtBQUNPLFNBQVNGLFNBQVQsUUFBMkQ7QUFBQSxNQUF2Q2UsTUFBdUMsU0FBdkNBLE1BQXVDO0FBQUEsTUFBL0JDLE1BQStCLFNBQS9CQSxNQUErQjtBQUFBLDBCQUF2QkMsS0FBdUI7QUFBQSxNQUF2QkEsS0FBdUIsK0JBQWYsQ0FBZTtBQUFBLDBCQUFaUCxLQUFZO0FBQUEsTUFBWkEsS0FBWSwrQkFBSixDQUFJOztBQUNoRSxNQUFNUSxRQUFRUixRQUFRTSxPQUFPWixNQUE3QjtBQUNBLE1BQUllLFNBQVMsQ0FBYjtBQUNBLE9BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSixPQUFPWixNQUEzQixFQUFtQyxFQUFFZ0IsQ0FBckMsRUFBd0M7QUFDdENMLFdBQU9FLFFBQVFFLFFBQWYsSUFBMkJILE9BQU9JLENBQVAsQ0FBM0I7QUFDRDs7QUFFRCxTQUFPRCxTQUFTRCxLQUFoQixFQUF1QjtBQUNyQjtBQUNBO0FBQ0EsUUFBSUMsU0FBU0QsUUFBUUMsTUFBckIsRUFBNkI7QUFDM0JKLGFBQU9NLFVBQVAsQ0FBa0JKLFFBQVFFLE1BQTFCLEVBQWtDRixLQUFsQyxFQUF5Q0EsUUFBUUUsTUFBakQ7QUFDQUEsZ0JBQVUsQ0FBVjtBQUNELEtBSEQsTUFHTztBQUNMSixhQUFPTSxVQUFQLENBQWtCSixRQUFRRSxNQUExQixFQUFrQ0YsS0FBbEMsRUFBeUNBLFFBQVFDLEtBQVIsR0FBZ0JDLE1BQXpEO0FBQ0FBLGVBQVNELEtBQVQ7QUFDRDtBQUNGOztBQUVELFNBQU9ILE1BQVA7QUFDRDs7QUFFRDtBQUNBIiwiZmlsZSI6ImZsYXR0ZW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyoqXG4gKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSBpbnRvIGEgc2luZ2xlIGxldmVsIGFycmF5XG4gKiBAZXhhbXBsZSBmbGF0dGVuKFtbMSwgWzJdXSwgWzNdLCA0XSkgPT4gWzEsIDIsIDMsIDRdXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgcmVzdWx0ID0gW10pIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIHdoaWxlICgrK2luZGV4IDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmbGF0dGVuKHZhbHVlLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudFZlcnRpY2VzKG5lc3RlZEFycmF5KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IG5lc3RlZEFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmVzdGVkQXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICBjb3VudCArPSBjb3VudFZlcnRpY2VzKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBGbGF0dGVucyBuZXN0ZWQgYXJyYXkgb2YgdmVydGljZXMsIHBhZGRpbmcgdGhpcmQgY29vcmRpbmF0ZSBhcyBuZWVkZWRcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuVmVydGljZXMobmVzdGVkQXJyYXksIHtyZXN1bHQgPSBbXSwgZGltZW5zaW9ucyA9IDN9ID0ge30pIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCB2ZXJ0ZXhMZW5ndGggPSAwO1xuICB3aGlsZSAoKytpbmRleCA8IG5lc3RlZEFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmVzdGVkQXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICBmbGF0dGVuVmVydGljZXModmFsdWUsIHtyZXN1bHQsIGRpbWVuc2lvbnN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHZlcnRleExlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBZGQgYSB0aGlyZCBjb29yZGluYXRlIGlmIG5lZWRlZFxuICBpZiAodmVydGV4TGVuZ3RoID4gMCAmJiB2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7XG4gICAgcmVzdWx0LnB1c2goMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gVXNlcyBjb3B5V2l0aGluIHRvIHNpZ25pZmljYW50bHkgc3BlZWQgdXAgdHlwZWQgYXJyYXkgdmFsdWUgZmlsbGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGxBcnJheSh7dGFyZ2V0LCBzb3VyY2UsIHN0YXJ0ID0gMCwgY291bnQgPSAxfSkge1xuICBjb25zdCB0b3RhbCA9IGNvdW50ICogc291cmNlLmxlbmd0aDtcbiAgbGV0IGNvcGllZCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0W3N0YXJ0ICsgY29waWVkKytdID0gc291cmNlW2ldO1xuICB9XG5cbiAgd2hpbGUgKGNvcGllZCA8IHRvdGFsKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBjb3BpZWQgbGVzcyB0aGFuIGhhbGYsIGNvcHkgZXZlcnl0aGluZyB3ZSBnb3RcbiAgICAvLyBlbHNlIGNvcHkgcmVtYWluaW5nIGluIG9uZSBvcGVyYXRpb25cbiAgICBpZiAoY29waWVkIDwgdG90YWwgLSBjb3BpZWQpIHtcbiAgICAgIHRhcmdldC5jb3B5V2l0aGluKHN0YXJ0ICsgY29waWVkLCBzdGFydCwgc3RhcnQgKyBjb3BpZWQpO1xuICAgICAgY29waWVkICo9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5jb3B5V2l0aGluKHN0YXJ0ICsgY29waWVkLCBzdGFydCwgc3RhcnQgKyB0b3RhbCAtIGNvcGllZCk7XG4gICAgICBjb3BpZWQgPSB0b3RhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBGbGF0dGVucyBuZXN0ZWQgYXJyYXkgb2YgdmVydGljZXMsIHBhZGRpbmcgdGhpcmQgY29vcmRpbmF0ZSBhcyBuZWVkZWRcbi8qXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblR5cGVkVmVydGljZXMobmVzdGVkQXJyYXksIHtcbiAgcmVzdWx0ID0gW10sXG4gIFR5cGUgPSBGbG9hdDMyQXJyYXksXG4gIHN0YXJ0ID0gMCxcbiAgZGltZW5zaW9ucyA9IDNcbn0gPSB7fSkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IHZlcnRleExlbmd0aCA9IDA7XG4gIHdoaWxlICgrK2luZGV4IDwgbmVzdGVkQXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXN0ZWRBcnJheVtpbmRleF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgIHN0YXJ0ID0gZmxhdHRlblR5cGVkVmVydGljZXModmFsdWUsIHtyZXN1bHQsIHN0YXJ0LCBkaW1lbnNpb25zfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVzdWx0W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICAgIHZlcnRleExlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBZGQgYSB0aGlyZCBjb29yZGluYXRlIGlmIG5lZWRlZFxuICBpZiAodmVydGV4TGVuZ3RoID4gMCAmJiB2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7XG4gICAgcmVzdWx0W3N0YXJ0KytdID0gMDtcbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG4qL1xuIl19