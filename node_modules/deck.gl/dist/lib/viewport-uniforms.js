'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


exports.getUniformsFromViewport = getUniformsFromViewport;

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - Math.fround(a);
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      viewMatrix = viewport.viewMatrix,
      projectionMatrix = viewport.projectionMatrix;


  var projectionCenter = void 0;
  var modelViewMatrix = void 0;

  switch (projectionMode) {

    case _constants.COORDINATE_SYSTEM.IDENTITY:
    case _constants.COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      modelViewMatrix = new _luma.Matrix4(viewMatrix);
      break;

    // TODO: make lighitng work for meter offset mode
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      var viewProjectionMatrix = new _luma.Matrix4(projectionMatrix).multiplyRight(viewMatrix);
      projectionCenter = viewProjectionMatrix.transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);

      // Always apply uncentered projection matrix if available (shader adds center)
      modelViewMatrix = new _luma.Matrix4(viewMatrixUncentered || viewMatrix)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      .multiplyRight(VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var viewMatrixInv = modelViewMatrix.clone().invert();

  if (modelMatrix) {
    // Apply model matrix if supplied
    modelViewMatrix.multiplyRight(modelMatrix);
  }

  var modelViewProjectionMatrix = new _luma.Matrix4(projectionMatrix).multiplyRight(modelViewMatrix);
  var cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];

  return {
    modelViewMatrix: modelViewMatrix,
    modelViewProjectionMatrix: modelViewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
function getUniformsFromViewport(viewport) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  (0, _assert2.default)(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      modelViewMatrix = _calculateMatrixAndOf.modelViewMatrix,
      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  (0, _assert2.default)(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;
  (0, _assert2.default)(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');

  // calculate WebGL matrices

  // Convert to Float32
  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  var devicePixelRatio = window && window.devicePixelRatio || 1;

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // modelMatrix: modelMatrix || new Matrix4().identity(),
    modelViewMatrix: modelViewMatrix,

    // Screen size
    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],
    devicePixelRatio: devicePixelRatio,

    // Main projection matrices
    projectionMatrix: glProjectionMatrix,
    projectionMatrixUncentered: glProjectionMatrix,
    projectionFP64: glProjectionMatrixFP64,
    projectionPixelsPerUnit: projectionPixelsPerUnit,

    // This is the mercator scale (2 ** zoom)
    projectionScale: viewport.scale,

    // Deprecated?
    projectionScaleFP64: fp64ify(viewport.scale),

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)

  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibmFtZXMiOlsiZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQiLCJmcDY0aWZ5IiwiYSIsImhpUGFydCIsIk1hdGgiLCJmcm91bmQiLCJsb1BhcnQiLCJaRVJPX1ZFQ1RPUiIsIlZFQ1RPUl9UT19QT0lOVF9NQVRSSVgiLCJjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQiLCJwcm9qZWN0aW9uTW9kZSIsInBvc2l0aW9uT3JpZ2luIiwidmlld3BvcnQiLCJtb2RlbE1hdHJpeCIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJwcm9qZWN0aW9uQ2VudGVyIiwibW9kZWxWaWV3TWF0cml4IiwiSURFTlRJVFkiLCJMTkdMQVQiLCJNRVRFUl9PRkZTRVRTIiwicG9zaXRpb25QaXhlbHMiLCJwcm9qZWN0RmxhdCIsInZpZXdQcm9qZWN0aW9uTWF0cml4IiwibXVsdGlwbHlSaWdodCIsInRyYW5zZm9ybVZlY3RvciIsIkVycm9yIiwidmlld01hdHJpeEludiIsImNsb25lIiwiaW52ZXJ0IiwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCIsImNhbWVyYVBvcyIsInNjYWxlIiwicHJvamVjdGlvblBpeGVsc1BlclVuaXQiLCJnZXREaXN0YW5jZVNjYWxlcyIsInBpeGVsc1Blck1ldGVyIiwiZ2xQcm9qZWN0aW9uTWF0cml4IiwiRmxvYXQzMkFycmF5IiwiZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCIsImkiLCJqIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsInZpZXdwb3J0U2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwicHJvamVjdGlvbk1hdHJpeFVuY2VudGVyZWQiLCJwcm9qZWN0aW9uRlA2NCIsInByb2plY3Rpb25TY2FsZSIsInByb2plY3Rpb25TY2FsZUZQNjQiXSwibWFwcGluZ3MiOiI7Ozs7Ozt5cEJBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztRQW1GZ0JBLHVCLEdBQUFBLHVCOztBQWxGaEI7O0FBRUE7Ozs7QUFDQTs7OztBQUVBLFNBQVNDLE9BQVQsQ0FBaUJDLENBQWpCLEVBQW9CO0FBQ2xCLE1BQU1DLFNBQVNDLEtBQUtDLE1BQUwsQ0FBWUgsQ0FBWixDQUFmO0FBQ0EsTUFBTUksU0FBU0osSUFBSUUsS0FBS0MsTUFBTCxDQUFZSCxDQUFaLENBQW5CO0FBQ0EsU0FBTyxDQUFDQyxNQUFELEVBQVNHLE1BQVQsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsSUFBTUMsY0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBcEI7QUFDQTtBQUNBLElBQU1DLHlCQUF5QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLENBQTlDLENBQS9COztBQUVBLFNBQVNDLHdCQUFULE9BS0c7QUFBQSxNQUpEQyxjQUlDLFFBSkRBLGNBSUM7QUFBQSxNQUhEQyxjQUdDLFFBSERBLGNBR0M7QUFBQSxNQUZEQyxRQUVDLFFBRkRBLFFBRUM7QUFBQSxNQUREQyxXQUNDLFFBRERBLFdBQ0M7QUFBQSxNQUNNQyxvQkFETixHQUM0REYsUUFENUQsQ0FDTUUsb0JBRE47QUFBQSxNQUM0QkMsVUFENUIsR0FDNERILFFBRDVELENBQzRCRyxVQUQ1QjtBQUFBLE1BQ3dDQyxnQkFEeEMsR0FDNERKLFFBRDVELENBQ3dDSSxnQkFEeEM7OztBQUdELE1BQUlDLHlCQUFKO0FBQ0EsTUFBSUMsd0JBQUo7O0FBRUEsVUFBUVIsY0FBUjs7QUFFQSxTQUFLLDZCQUFrQlMsUUFBdkI7QUFDQSxTQUFLLDZCQUFrQkMsTUFBdkI7QUFDRUgseUJBQW1CVixXQUFuQjtBQUNBVyx3QkFBa0Isa0JBQVlILFVBQVosQ0FBbEI7QUFDQTs7QUFFRjtBQUNBLFNBQUssNkJBQWtCTSxhQUF2QjtBQUNFO0FBQ0E7QUFDQTtBQUNBLFVBQU1DLGlCQUFpQlYsU0FBU1csV0FBVCxDQUFxQlosY0FBckIsQ0FBdkI7QUFDQSxVQUFNYSx1QkFBdUIsa0JBQVlSLGdCQUFaLEVBQThCUyxhQUE5QixDQUE0Q1YsVUFBNUMsQ0FBN0I7QUFDQUUseUJBQW1CTyxxQkFDaEJFLGVBRGdCLENBQ0EsQ0FBQ0osZUFBZSxDQUFmLENBQUQsRUFBb0JBLGVBQWUsQ0FBZixDQUFwQixFQUF1QyxHQUF2QyxFQUE0QyxHQUE1QyxDQURBLENBQW5COztBQUdBO0FBQ0FKLHdCQUFrQixrQkFBWUosd0JBQXdCQyxVQUFwQztBQUNoQjtBQURnQixPQUVmVSxhQUZlLENBRURqQixzQkFGQyxDQUFsQjtBQUdBOztBQUVGO0FBQ0UsWUFBTSxJQUFJbUIsS0FBSixDQUFVLHlCQUFWLENBQU47QUF6QkY7O0FBNEJBLE1BQU1DLGdCQUFnQlYsZ0JBQWdCVyxLQUFoQixHQUF3QkMsTUFBeEIsRUFBdEI7O0FBRUEsTUFBSWpCLFdBQUosRUFBaUI7QUFDZjtBQUNBSyxvQkFBZ0JPLGFBQWhCLENBQThCWixXQUE5QjtBQUNEOztBQUVELE1BQU1rQiw0QkFBNEIsa0JBQVlmLGdCQUFaLEVBQThCUyxhQUE5QixDQUE0Q1AsZUFBNUMsQ0FBbEM7QUFDQSxNQUFNYyxZQUFZLENBQUNKLGNBQWMsRUFBZCxDQUFELEVBQW9CQSxjQUFjLEVBQWQsQ0FBcEIsRUFBdUNBLGNBQWMsRUFBZCxDQUF2QyxDQUFsQjs7QUFFQSxTQUFPO0FBQ0xWLG9DQURLO0FBRUxhLHdEQUZLO0FBR0xkLHNDQUhLO0FBSUxlO0FBSkssR0FBUDtBQU1EOztBQUVEOzs7Ozs7Ozs7QUFTTyxTQUFTaEMsdUJBQVQsQ0FBaUNZLFFBQWpDLEVBSUM7QUFBQSxrRkFBSixFQUFJO0FBQUEsZ0NBSE5DLFdBR007QUFBQSxNQUhOQSxXQUdNLHFDQUhRLElBR1I7QUFBQSxtQ0FGTkgsY0FFTTtBQUFBLE1BRk5BLGNBRU0sd0NBRlcsNkJBQWtCVSxNQUU3QjtBQUFBLG1DQUROVCxjQUNNO0FBQUEsTUFETkEsY0FDTSx3Q0FEVyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQ1g7O0FBQ04sd0JBQU9DLFNBQVNxQixLQUFoQixFQUF1Qix3QkFBdkI7O0FBRE0sOEJBSUp4Qix5QkFBeUIsRUFBQ0MsOEJBQUQsRUFBaUJDLDhCQUFqQixFQUFpQ0Usd0JBQWpDLEVBQThDRCxrQkFBOUMsRUFBekIsQ0FKSTtBQUFBLE1BR0NLLGdCQUhELHlCQUdDQSxnQkFIRDtBQUFBLE1BR21CQyxlQUhuQix5QkFHbUJBLGVBSG5CO0FBQUEsTUFHb0NhLHlCQUhwQyx5QkFHb0NBLHlCQUhwQztBQUFBLE1BRytEQyxTQUgvRCx5QkFHK0RBLFNBSC9EOztBQU1OLHdCQUFPRCx5QkFBUCxFQUFrQyw0Q0FBbEM7O0FBRUE7QUFDQSxNQUFNRywwQkFBMEJ0QixTQUFTdUIsaUJBQVQsR0FBNkJDLGNBQTdEO0FBQ0Esd0JBQU9GLHVCQUFQLEVBQWdDLGlDQUFoQzs7QUFFQTs7QUFFQTtBQUNBLE1BQU1HLHFCQUFxQixJQUFJQyxZQUFKLENBQWlCUCx5QkFBakIsQ0FBM0I7O0FBRUE7QUFDQTtBQUNBLE1BQU1RLHlCQUF5QixJQUFJRCxZQUFKLENBQWlCLEVBQWpCLENBQS9CO0FBQ0EsT0FBSyxJQUFJRSxJQUFJLENBQWIsRUFBZ0JBLElBQUksQ0FBcEIsRUFBdUIsRUFBRUEsQ0FBekIsRUFBNEI7QUFDMUIsU0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUksQ0FBcEIsRUFBdUIsRUFBRUEsQ0FBekIsRUFBNEI7QUFBQSxxQkFJdEJ4QyxRQUFROEIsMEJBQTBCVSxJQUFJLENBQUosR0FBUUQsQ0FBbEMsQ0FBUixDQUpzQjs7QUFBQTs7QUFFeEJELDZCQUF1QixDQUFDQyxJQUFJLENBQUosR0FBUUMsQ0FBVCxJQUFjLENBQXJDLENBRndCO0FBR3hCRiw2QkFBdUIsQ0FBQ0MsSUFBSSxDQUFKLEdBQVFDLENBQVQsSUFBYyxDQUFkLEdBQWtCLENBQXpDLENBSHdCO0FBSzNCO0FBQ0Y7O0FBRUQsTUFBTUMsbUJBQW9CQyxVQUFVQSxPQUFPRCxnQkFBbEIsSUFBdUMsQ0FBaEU7O0FBRUEsU0FBTztBQUNMO0FBQ0FoQyxrQ0FGSztBQUdMTyxzQ0FISzs7QUFLTDtBQUNBQyxvQ0FOSzs7QUFRTDtBQUNBMEIsa0JBQWMsQ0FBQ2hDLFNBQVNpQyxLQUFULEdBQWlCSCxnQkFBbEIsRUFBb0M5QixTQUFTa0MsTUFBVCxHQUFrQkosZ0JBQXRELENBVFQ7QUFVTEEsc0NBVks7O0FBWUw7QUFDQTFCLHNCQUFrQnFCLGtCQWJiO0FBY0xVLGdDQUE0QlYsa0JBZHZCO0FBZUxXLG9CQUFnQlQsc0JBZlg7QUFnQkxMLG9EQWhCSzs7QUFrQkw7QUFDQWUscUJBQWlCckMsU0FBU3FCLEtBbkJyQjs7QUFxQkw7QUFDQWlCLHlCQUFxQmpELFFBQVFXLFNBQVNxQixLQUFqQixDQXRCaEI7O0FBd0JMO0FBQ0FELGVBQVcsSUFBSU0sWUFBSixDQUFpQk4sU0FBakI7O0FBekJOLEdBQVA7QUE0QkQiLCJmaWxlIjoidmlld3BvcnQtdW5pZm9ybXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtNYXRyaXg0fSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBmcDY0aWZ5KGEpIHtcbiAgY29uc3QgaGlQYXJ0ID0gTWF0aC5mcm91bmQoYSk7XG4gIGNvbnN0IGxvUGFydCA9IGEgLSBNYXRoLmZyb3VuZChhKTtcbiAgcmV0dXJuIFtoaVBhcnQsIGxvUGFydF07XG59XG5cbi8vIFRvIHF1aWNrbHkgc2V0IGEgdmVjdG9yIHRvIHplcm9cbmNvbnN0IFpFUk9fVkVDVE9SID0gWzAsIDAsIDAsIDBdO1xuLy8gNHg0IG1hdHJpeCB0aGF0IGRyb3BzIDR0aCBjb21wb25lbnQgb2YgdmVjdG9yXG5jb25zdCBWRUNUT1JfVE9fUE9JTlRfTUFUUklYID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDBdO1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe1xuICBwcm9qZWN0aW9uTW9kZSxcbiAgcG9zaXRpb25PcmlnaW4sXG4gIHZpZXdwb3J0LFxuICBtb2RlbE1hdHJpeFxufSkge1xuICBjb25zdCB7dmlld01hdHJpeFVuY2VudGVyZWQsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXh9ID0gdmlld3BvcnQ7XG5cbiAgbGV0IHByb2plY3Rpb25DZW50ZXI7XG4gIGxldCBtb2RlbFZpZXdNYXRyaXg7XG5cbiAgc3dpdGNoIChwcm9qZWN0aW9uTW9kZSkge1xuXG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uSURFTlRJVFk6XG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUOlxuICAgIHByb2plY3Rpb25DZW50ZXIgPSBaRVJPX1ZFQ1RPUjtcbiAgICBtb2RlbFZpZXdNYXRyaXggPSBuZXcgTWF0cml4NCh2aWV3TWF0cml4KTtcbiAgICBicmVhaztcblxuICAvLyBUT0RPOiBtYWtlIGxpZ2hpdG5nIHdvcmsgZm9yIG1ldGVyIG9mZnNldCBtb2RlXG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUzpcbiAgICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtZWQgcHJvamVjdGlvbkNlbnRlciAoaW4gNjQgYml0IHByZWNpc2lvbilcbiAgICAvLyBUaGlzIGlzIHRoZSBrZXkgdG8gb2Zmc2V0IG1vZGUgcHJlY2lzaW9uIChhdm9pZHMgZG9pbmcgdGhpc1xuICAgIC8vIGFkZGl0aW9uIGluIDMyIGJpdCBwcmVjaXNpb24pXG4gICAgY29uc3QgcG9zaXRpb25QaXhlbHMgPSB2aWV3cG9ydC5wcm9qZWN0RmxhdChwb3NpdGlvbk9yaWdpbik7XG4gICAgY29uc3Qgdmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NChwcm9qZWN0aW9uTWF0cml4KS5tdWx0aXBseVJpZ2h0KHZpZXdNYXRyaXgpO1xuICAgIHByb2plY3Rpb25DZW50ZXIgPSB2aWV3UHJvamVjdGlvbk1hdHJpeFxuICAgICAgLnRyYW5zZm9ybVZlY3RvcihbcG9zaXRpb25QaXhlbHNbMF0sIHBvc2l0aW9uUGl4ZWxzWzFdLCAwLjAsIDEuMF0pO1xuXG4gICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggaWYgYXZhaWxhYmxlIChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgbW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAgIC8vIFplcm8gb3V0IDR0aCBjb29yZGluYXRlIChcImFmdGVyXCIgbW9kZWwgbWF0cml4KSAtIGF2b2lkcyBmdXJ0aGVyIHRyYW5zbGF0aW9uc1xuICAgICAgLm11bHRpcGx5UmlnaHQoVkVDVE9SX1RPX1BPSU5UX01BVFJJWCk7XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvamVjdGlvbiBtb2RlJyk7XG4gIH1cblxuICBjb25zdCB2aWV3TWF0cml4SW52ID0gbW9kZWxWaWV3TWF0cml4LmNsb25lKCkuaW52ZXJ0KCk7XG5cbiAgaWYgKG1vZGVsTWF0cml4KSB7XG4gICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5UmlnaHQobW9kZWxNYXRyaXgpO1xuICB9XG5cbiAgY29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpLm11bHRpcGx5UmlnaHQobW9kZWxWaWV3TWF0cml4KTtcbiAgY29uc3QgY2FtZXJhUG9zID0gW3ZpZXdNYXRyaXhJbnZbMTJdLCB2aWV3TWF0cml4SW52WzEzXSwgdmlld01hdHJpeEludlsxNF1dO1xuXG4gIHJldHVybiB7XG4gICAgbW9kZWxWaWV3TWF0cml4LFxuICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkNlbnRlcixcbiAgICBjYW1lcmFQb3NcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHVuaWZvcm1zIGZvciBzaGFkZXJzIGJhc2VkIG9uIGN1cnJlbnQgcHJvamVjdGlvblxuICogaW5jbHVkZXM6IHByb2plY3Rpb24gbWF0cml4IHN1aXRhYmxlIGZvciBzaGFkZXJzXG4gKlxuICogVE9ETyAtIEVuc3VyZSB0aGlzIHdvcmtzIHdpdGggYW55IHZpZXdwb3J0LCBub3QganVzdCBXZWJNZXJjYXRvclZpZXdwb3J0c1xuICpcbiAqIEBwYXJhbSB7V2ViTWVyY2F0b3JWaWV3cG9ydH0gdmlld3BvcnQgLVxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAtIDR4NCBwcm9qZWN0aW9uIG1hdHJpeCB0aGF0IGNhbiBiZSB1c2VkIGluIHNoYWRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gIG1vZGVsTWF0cml4ID0gbnVsbCxcbiAgcHJvamVjdGlvbk1vZGUgPSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4gIHBvc2l0aW9uT3JpZ2luID0gWzAsIDBdXG59ID0ge30pIHtcbiAgYXNzZXJ0KHZpZXdwb3J0LnNjYWxlLCAnVmlld3BvcnQgc2NhbGUgbWlzc2luZycpO1xuXG4gIGNvbnN0IHtwcm9qZWN0aW9uQ2VudGVyLCBtb2RlbFZpZXdNYXRyaXgsIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsIGNhbWVyYVBvc30gPVxuICAgIGNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCh7cHJvamVjdGlvbk1vZGUsIHBvc2l0aW9uT3JpZ2luLCBtb2RlbE1hdHJpeCwgdmlld3BvcnR9KTtcblxuICBhc3NlcnQobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCwgJ1ZpZXdwb3J0IG1pc3NpbmcgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCcpO1xuXG4gIC8vIENhbGN1bGF0ZSBwcm9qZWN0aW9uIHBpeGVscyBwZXIgdW5pdFxuICBjb25zdCBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCA9IHZpZXdwb3J0LmdldERpc3RhbmNlU2NhbGVzKCkucGl4ZWxzUGVyTWV0ZXI7XG4gIGFzc2VydChwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCwgJ1ZpZXdwb3J0IG1pc3NpbmcgcGl4ZWxzUGVyTWV0ZXInKTtcblxuICAvLyBjYWxjdWxhdGUgV2ViR0wgbWF0cmljZXNcblxuICAvLyBDb252ZXJ0IHRvIEZsb2F0MzJcbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAvLyBcIkZsb2F0NjRBcnJheVwiXG4gIC8vIFRyYW5zcG9zZSB0aGUgcHJvamVjdGlvbiBtYXRyaXggdG8gY29sdW1uIG1ham9yIGZvciBHTFNMLlxuICBjb25zdCBnbFByb2plY3Rpb25NYXRyaXhGUDY0ID0gbmV3IEZsb2F0MzJBcnJheSgzMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgIFtcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDJdLFxuICAgICAgICBnbFByb2plY3Rpb25NYXRyaXhGUDY0WyhpICogNCArIGopICogMiArIDFdXG4gICAgICBdID0gZnA2NGlmeShtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4W2ogKiA0ICsgaV0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSAod2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xuXG4gIHJldHVybiB7XG4gICAgLy8gUHJvamVjdGlvbiBtb2RlIHZhbHVlc1xuICAgIHByb2plY3Rpb25Nb2RlLFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG5cbiAgICAvLyBtb2RlbE1hdHJpeDogbW9kZWxNYXRyaXggfHwgbmV3IE1hdHJpeDQoKS5pZGVudGl0eSgpLFxuICAgIG1vZGVsVmlld01hdHJpeCxcblxuICAgIC8vIFNjcmVlbiBzaXplXG4gICAgdmlld3BvcnRTaXplOiBbdmlld3BvcnQud2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvLCB2aWV3cG9ydC5oZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvXSxcbiAgICBkZXZpY2VQaXhlbFJhdGlvLFxuXG4gICAgLy8gTWFpbiBwcm9qZWN0aW9uIG1hdHJpY2VzXG4gICAgcHJvamVjdGlvbk1hdHJpeDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkOiBnbFByb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkZQNjQ6IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdGlvblBpeGVsc1BlclVuaXQsXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBtZXJjYXRvciBzY2FsZSAoMiAqKiB6b29tKVxuICAgIHByb2plY3Rpb25TY2FsZTogdmlld3BvcnQuc2NhbGUsXG5cbiAgICAvLyBEZXByZWNhdGVkP1xuICAgIHByb2plY3Rpb25TY2FsZUZQNjQ6IGZwNjRpZnkodmlld3BvcnQuc2NhbGUpLFxuXG4gICAgLy8gVGhpcyBpcyBmb3IgbGlnaHRpbmcgY2FsY3VsYXRpb25zXG4gICAgY2FtZXJhUG9zOiBuZXcgRmxvYXQzMkFycmF5KGNhbWVyYVBvcylcblxuICB9O1xufVxuIl19