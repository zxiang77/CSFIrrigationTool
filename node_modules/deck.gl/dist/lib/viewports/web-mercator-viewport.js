'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getFov = getFov;
exports.getClippingPlanes = getClippingPlanes;
exports.makeProjectionMatrixFromMercatorParams = makeProjectionMatrixFromMercatorParams;

var _viewport = require('./viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _glMatrix = require('gl-matrix');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// View and Projection Matrix calculations for mapbox-js style
// map view properties


// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE;

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity, max-statements */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var distanceScales = calculateDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    // The uncentered matrix allows us two move the center addition to the
    // shader (cheap) which gives a coordinate system that has its center in
    // the layer's center position. This makes rotations and other modelMatrx
    // transforms much more useful.
    var viewMatrixUncentered = makeUncenteredViewMatrixFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales
    });

    // Make a centered version of the matrix for projection modes without an offset
    var center = projectFlat([longitude, latitude], scale);

    var viewMatrix = _glMatrix.mat4.translate((0, _viewport.createMat4)(), viewMatrixUncentered, [-center[0], -center[1], 0]);

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    // Save calculated values
    _this.scale = scale;
    _this.center = center;
    _this.viewMatrixUncentered = viewMatrixUncentered;
    _this._distanceScales = distanceScales;

    // Bind methods
    _this.getDistanceScales = _this.getDistanceScales.bind(_this);
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity, max-statements */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return unprojectFlat(xy, scale);
    }
  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var c = this.project(lngLat, { topLeft: false });
      var coordCenter = this.project([this.longitude, this.latitude], { topLeft: false });
      var coordAtPoint = pos;
      var translate = _glMatrix.vec2.sub([], coordAtPoint, c);
      var newPos = _glMatrix.vec2.sub([], coordCenter, translate);
      var newLngLat = this.unproject(newPos, { topLeft: false });

      return newLngLat;
    }

    /*
    getLngLatAtViewportPosition(lnglat, xy) {
      const c = this.locationCoordinate(lnglat);
      const coordAtPoint = this.pointCoordinate(xy);
      const coordCenter = this.pointCoordinate(this.centerPoint);
      const translate = coordAtPoint._sub(c);
      this.center = this.coordinateLocation(coordCenter._sub(translate));
    }
    */

  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this._distanceScales;
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this._distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      (0, _assert2.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this._distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this._distanceScales;
    }
  }]);

  return WebMercatorViewport;
}(_viewport2.default);

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */


exports.default = WebMercatorViewport;
function projectFlat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      lng = _ref4[0],
      lat = _ref4[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function unprojectFlat(_ref5, scale) {
  var _ref6 = _slicedToArray(_ref5, 2),
      x = _ref6[0],
      y = _ref6[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function calculateDistanceScales(_ref7) {
  var latitude = _ref7.latitude,
      longitude = _ref7.longitude,
      scale = _ref7.scale;

  (0, _assert2.default)(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale), ERR_ARGUMENT);
  // Approximately 111km per degree at equator
  var METERS_PER_DEGREE = 111000;

  var latCosine = Math.cos(latitude * Math.PI / 180);

  var metersPerDegree = METERS_PER_DEGREE * latCosine;

  // Calculate number of pixels occupied by one degree longitude
  // around current lat/lon
  var pixelsPerDegreeX = _glMatrix.vec2.distance(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale));
  // Calculate number of pixels occupied by one degree latitude
  // around current lat/lon
  var pixelsPerDegreeY = _glMatrix.vec2.distance(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));

  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;
  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];

  var worldSize = TILE_SIZE * scale;
  var altPixelsPerMeter = worldSize / (4e7 * latCosine);
  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];

  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];
  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return {
    pixelsPerMeter: pixelsPerMeter,
    metersPerPixel: metersPerPixel,
    pixelsPerDegree: pixelsPerDegree,
    degreesPerPixel: degreesPerPixel
  };
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
function makeProjectionMatrixFromMercatorParams(_ref10) {
  var width = _ref10.width,
      height = _ref10.height,
      pitch = _ref10.pitch,
      altitude = _ref10.altitude,
      _ref10$farZMultiplier = _ref10.farZMultiplier,
      farZMultiplier = _ref10$farZMultiplier === undefined ? 10 : _ref10$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = _glMatrix.mat4.perspective((0, _viewport.createMat4)(), fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

function makeUncenteredViewMatrixFromMercatorParams(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      longitude = _ref11.longitude,
      latitude = _ref11.latitude,
      zoom = _ref11.zoom,
      pitch = _ref11.pitch,
      bearing = _ref11.bearing,
      altitude = _ref11.altitude,
      center = _ref11.center;

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = (0, _viewport.createMat4)();

  // Move camera to altitude
  _glMatrix.mat4.translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  _glMatrix.mat4.scale(vm, vm, [1, -1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  _glMatrix.mat4.rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);
  _glMatrix.mat4.rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);

  return vm;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJnZXRGb3YiLCJnZXRDbGlwcGluZ1BsYW5lcyIsIm1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zIiwiUEkiLCJNYXRoIiwiUElfNCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlJBRElBTlNfVE9fREVHUkVFUyIsIlRJTEVfU0laRSIsIldPUkxEX1NDQUxFIiwiREVGQVVMVF9NQVBfU1RBVEUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJhbHRpdHVkZSIsIkVSUl9BUkdVTUVOVCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJ3aWR0aCIsImhlaWdodCIsImZhclpNdWx0aXBsaWVyIiwidW5kZWZpbmVkIiwic2NhbGUiLCJwb3ciLCJtYXgiLCJkaXN0YW5jZVNjYWxlcyIsImNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzIiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwibWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zIiwiY2VudGVyIiwicHJvamVjdEZsYXQiLCJ2aWV3TWF0cml4IiwidHJhbnNsYXRlIiwiX2Rpc3RhbmNlU2NhbGVzIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJiaW5kIiwibWV0ZXJzVG9MbmdMYXREZWx0YSIsImxuZ0xhdERlbHRhVG9NZXRlcnMiLCJhZGRNZXRlcnNUb0xuZ0xhdCIsIk9iamVjdCIsImZyZWV6ZSIsImxuZ0xhdCIsInh5IiwidW5wcm9qZWN0RmxhdCIsInBvcyIsImMiLCJwcm9qZWN0IiwidG9wTGVmdCIsImNvb3JkQ2VudGVyIiwiY29vcmRBdFBvaW50Iiwic3ViIiwibmV3UG9zIiwibmV3TG5nTGF0IiwidW5wcm9qZWN0IiwieHl6IiwieCIsInkiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwaXhlbHNQZXJNZXRlciIsImRlZ3JlZXNQZXJQaXhlbCIsImRlbHRhTG5nIiwiZGVsdGFMYXQiLCJsZW5ndGgiLCJkZWx0YUxuZ0xhdFoiLCJkZWx0YVoiLCJwaXhlbHNQZXJEZWdyZWUiLCJtZXRlcnNQZXJQaXhlbCIsImRlbHRhWCIsImRlbHRhWSIsImxuZ0xhdFoiLCJsbmciLCJsYXQiLCJaIiwibGFtYmRhMiIsInBoaTIiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwiaXNOYU4iLCJNRVRFUlNfUEVSX0RFR1JFRSIsImxhdENvc2luZSIsImNvcyIsIm1ldGVyc1BlckRlZ3JlZSIsInBpeGVsc1BlckRlZ3JlZVgiLCJkaXN0YW5jZSIsInBpeGVsc1BlckRlZ3JlZVkiLCJwaXhlbHNQZXJNZXRlclgiLCJwaXhlbHNQZXJNZXRlclkiLCJwaXhlbHNQZXJNZXRlcloiLCJ3b3JsZFNpemUiLCJhbHRQaXhlbHNQZXJNZXRlciIsInBpdGNoUmFkaWFucyIsImhhbGZGb3YiLCJ0b3BIYWxmU3VyZmFjZURpc3RhbmNlIiwic2luIiwiZmFyWiIsIm5lYXJaIiwiZm92IiwicGVyc3BlY3RpdmUiLCJ2bSIsInJvdGF0ZVgiLCJyb3RhdGVaIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O1FBc1hnQkEsTSxHQUFBQSxNO1FBSUFDLGlCLEdBQUFBLGlCO1FBZUFDLHNDLEdBQUFBLHNDOztBQW5YaEI7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7OzsrZUF4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBS0E7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0EsSUFBTUMsY0FB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QUFBLE1BTkRELFFBTUMsVUFOREEsUUFNQztBQUFBLE1BTERFLElBS0MsVUFMREEsSUFLQztBQUFBLE1BSkRDLEtBSUMsVUFKREEsS0FJQztBQUFBLE1BSERDLE9BR0MsVUFIREEsT0FHQztBQUFBLE1BRkRDLFFBRUMsVUFGREEsUUFFQztBQUFBLE1BRERlLE1BQ0MsVUFEREEsTUFDQzs7QUFDRDtBQUNBO0FBQ0E7QUFDQSxNQUFNeUUsS0FBSywyQkFBWDs7QUFFQTtBQUNBLGlCQUFLdEUsU0FBTCxDQUFlc0UsRUFBZixFQUFtQkEsRUFBbkIsRUFBdUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQUN4RixRQUFSLENBQXZCOztBQUVBO0FBQ0E7QUFDQSxpQkFBS08sS0FBTCxDQUFXaUYsRUFBWCxFQUFlQSxFQUFmLEVBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLElBQUlwRixNQUFaLENBQW5COztBQUVBO0FBQ0EsaUJBQUtxRixPQUFMLENBQWFELEVBQWIsRUFBaUJBLEVBQWpCLEVBQXFCMUYsUUFBUVIsa0JBQTdCO0FBQ0EsaUJBQUtvRyxPQUFMLENBQWFGLEVBQWIsRUFBaUJBLEVBQWpCLEVBQXFCLENBQUN6RixPQUFELEdBQVdULGtCQUFoQzs7QUFFQSxTQUFPa0csRUFBUDtBQUNEIiwiZmlsZSI6IndlYi1tZXJjYXRvci12aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0LCB7Y3JlYXRlTWF0NH0gZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQge21hdDQsIHZlYzJ9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBXT1JMRF9TQ0FMRSA9IFRJTEVfU0laRTtcblxuY29uc3QgREVGQVVMVF9NQVBfU1RBVEUgPSB7XG4gIGxhdGl0dWRlOiAzNyxcbiAgbG9uZ2l0dWRlOiAtMTIyLFxuICB6b29tOiAxMSxcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFdlYk1lcmNhdG9yVmlld3BvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJNZXJjYXRvclZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBDcmVhdGVzIHZpZXcvcHJvamVjdGlvbiBtYXRyaWNlcyBmcm9tIG1lcmNhdG9yIHBhcmFtc1xuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBtZXJjYXRvcj10cnVlIC0gV2hldGhlciB0byB1c2UgbWVyY2F0b3IgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge0FycmF5fSBvcHQuY2VudGVyPVswLCAwXSAtIENlbnRlciBvZiB2aWV3cG9ydFxuICAgKiAgIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBvciBbeCwgeV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuXG4gICAqIE5vdGVzOlxuICAgKiAgLSBPbmx5IG9uZSBvZiBjZW50ZXIgb3IgW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBiZSBzcGVjaWZpZWRcbiAgICogIC0gW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBvbmx5IGJlIHNwZWNpZmllZCB3aGVuIFwibWVyY2F0b3JcIiBpcyB0cnVlXG4gICAqICAtIEFsdGl0dWRlIGhhcyBhIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXRjaGVzIGFzc3VtcHRpb25zIGluIG1hcGJveC1nbFxuICAgKiAgLSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBmb3JjZWQgdG8gMSBpZiBzdXBwbGllZCBhcyAwLCB0byBhdm9pZFxuICAgKiAgICBkaXZpc2lvbiBieSB6ZXJvLiBUaGlzIGlzIGludGVuZGVkIHRvIHJlZHVjZSB0aGUgYnVyZGVuIG9mIGFwcHMgdG9cbiAgICogICAgdG8gY2hlY2sgdmFsdWVzIGJlZm9yZSBpbnN0YW50aWF0aW5nIGEgVmlld3BvcnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gTWFwIHN0YXRlXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxhdGl0dWRlLFxuICAgIGxvbmdpdHVkZSxcbiAgICB6b29tLFxuICAgIHBpdGNoLFxuICAgIGJlYXJpbmcsXG4gICAgYWx0aXR1ZGUsXG4gICAgZmFyWk11bHRpcGxpZXIgPSAxMFxuICB9ID0ge30pIHtcbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgem9vbSA9IHpvb20gIT09IHVuZGVmaW5lZCA/IHpvb20gOiBERUZBVUxUX01BUF9TVEFURS56b29tO1xuICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgYmVhcmluZyA9IGJlYXJpbmcgIT09IHVuZGVmaW5lZCA/IGJlYXJpbmcgOiBERUZBVUxUX01BUF9TVEFURS5iZWFyaW5nO1xuICAgIHBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDAgdG8gZmFjaWxpdGF0ZSBpc29tb3JwaGljIHJlbmRlciBldGNcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgIC8vIEFsdGl0dWRlIC0gcHJldmVudCBkaXZpc2lvbiBieSAwXG4gICAgLy8gVE9ETyAtIGp1c3QgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZD9cbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcblxuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzID0gY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlfSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIGZhclpNdWx0aXBsaWVyXG4gICAgfSk7XG5cbiAgICAvLyBUaGUgdW5jZW50ZXJlZCBtYXRyaXggYWxsb3dzIHVzIHR3byBtb3ZlIHRoZSBjZW50ZXIgYWRkaXRpb24gdG8gdGhlXG4gICAgLy8gc2hhZGVyIChjaGVhcCkgd2hpY2ggZ2l2ZXMgYSBjb29yZGluYXRlIHN5c3RlbSB0aGF0IGhhcyBpdHMgY2VudGVyIGluXG4gICAgLy8gdGhlIGxheWVyJ3MgY2VudGVyIHBvc2l0aW9uLiBUaGlzIG1ha2VzIHJvdGF0aW9ucyBhbmQgb3RoZXIgbW9kZWxNYXRyeFxuICAgIC8vIHRyYW5zZm9ybXMgbXVjaCBtb3JlIHVzZWZ1bC5cbiAgICBjb25zdCB2aWV3TWF0cml4VW5jZW50ZXJlZCA9IG1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlLFxuICAgICAgZGlzdGFuY2VTY2FsZXNcbiAgICB9KTtcblxuICAgIC8vIE1ha2UgYSBjZW50ZXJlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggZm9yIHByb2plY3Rpb24gbW9kZXMgd2l0aG91dCBhbiBvZmZzZXRcbiAgICBjb25zdCBjZW50ZXIgPSBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKTtcblxuICAgIGNvbnN0IHZpZXdNYXRyaXggPSBtYXQ0LnRyYW5zbGF0ZShcbiAgICAgIGNyZWF0ZU1hdDQoKSwgdmlld01hdHJpeFVuY2VudGVyZWQsIFstY2VudGVyWzBdLCAtY2VudGVyWzFdLCAwXSk7XG5cbiAgICBzdXBlcih7d2lkdGgsIGhlaWdodCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeH0pO1xuXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuXG4gICAgLy8gU2F2ZSBjYWxjdWxhdGVkIHZhbHVlc1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB0aGlzLnZpZXdNYXRyaXhVbmNlbnRlcmVkID0gdmlld01hdHJpeFVuY2VudGVyZWQ7XG4gICAgdGhpcy5fZGlzdGFuY2VTY2FsZXMgPSBkaXN0YW5jZVNjYWxlcztcblxuICAgIC8vIEJpbmQgbWV0aG9kc1xuICAgIHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMgPSB0aGlzLmdldERpc3RhbmNlU2NhbGVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzID0gdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdCA9IHRoaXMuYWRkTWV0ZXJzVG9MbmdMYXQuYmluZCh0aGlzKTtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICAgKiBwZXJzcGVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICovXG4gIF9wcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiBwcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgX3VucHJvamVjdEZsYXQoeHksIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB1bnByb2plY3RGbGF0KHh5LCBzY2FsZSk7XG4gIH1cblxuICBnZXRMb2NhdGlvbkF0UG9pbnQoe2xuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IGMgPSB0aGlzLnByb2plY3QobG5nTGF0LCB7dG9wTGVmdDogZmFsc2V9KTtcbiAgICBjb25zdCBjb29yZENlbnRlciA9IHRoaXMucHJvamVjdChbdGhpcy5sb25naXR1ZGUsIHRoaXMubGF0aXR1ZGVdLCB7dG9wTGVmdDogZmFsc2V9KTtcbiAgICBjb25zdCBjb29yZEF0UG9pbnQgPSBwb3M7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gdmVjMi5zdWIoW10sIGNvb3JkQXRQb2ludCwgYyk7XG4gICAgY29uc3QgbmV3UG9zID0gdmVjMi5zdWIoW10sIGNvb3JkQ2VudGVyLCB0cmFuc2xhdGUpO1xuICAgIGNvbnN0IG5ld0xuZ0xhdCA9IHRoaXMudW5wcm9qZWN0KG5ld1Bvcywge3RvcExlZnQ6IGZhbHNlfSk7XG5cbiAgICByZXR1cm4gbmV3TG5nTGF0O1xuICB9XG5cbiAgLypcbiAgZ2V0TG5nTGF0QXRWaWV3cG9ydFBvc2l0aW9uKGxuZ2xhdCwgeHkpIHtcbiAgICBjb25zdCBjID0gdGhpcy5sb2NhdGlvbkNvb3JkaW5hdGUobG5nbGF0KTtcbiAgICBjb25zdCBjb29yZEF0UG9pbnQgPSB0aGlzLnBvaW50Q29vcmRpbmF0ZSh4eSk7XG4gICAgY29uc3QgY29vcmRDZW50ZXIgPSB0aGlzLnBvaW50Q29vcmRpbmF0ZSh0aGlzLmNlbnRlclBvaW50KTtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBjb29yZEF0UG9pbnQuX3N1YihjKTtcbiAgICB0aGlzLmNlbnRlciA9IHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKGNvb3JkQ2VudGVyLl9zdWIodHJhbnNsYXRlKSk7XG4gIH1cbiAgKi9cblxuICBnZXREaXN0YW5jZVNjYWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VTY2FsZXM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBtZXRlciBvZmZzZXQgdG8gYSBsbmdsYXQgb2Zmc2V0XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgeHl6IC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSAtIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKi9cbiAgbWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopIHtcbiAgICBjb25zdCBbeCwgeSwgeiA9IDBdID0geHl6O1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpICYmIE51bWJlci5pc0Zpbml0ZSh6KSwgRVJSX0FSR1VNRU5UKTtcbiAgICBjb25zdCB7cGl4ZWxzUGVyTWV0ZXIsIGRlZ3JlZXNQZXJQaXhlbH0gPSB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YUxuZyA9IHggKiBwaXhlbHNQZXJNZXRlclswXSAqIGRlZ3JlZXNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YUxhdCA9IHkgKiBwaXhlbHNQZXJNZXRlclsxXSAqIGRlZ3JlZXNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFtkZWx0YUxuZywgZGVsdGFMYXRdIDogW2RlbHRhTG5nLCBkZWx0YUxhdCwgel07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBsbmdsYXQgb2Zmc2V0IHRvIGEgbWV0ZXIgb2Zmc2V0XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgZGVsdGFMbmdMYXRaIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKi9cbiAgbG5nTGF0RGVsdGFUb01ldGVycyhkZWx0YUxuZ0xhdFopIHtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IGRlbHRhTG5nTGF0WjtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGRlbHRhTG5nKSAmJiBOdW1iZXIuaXNGaW5pdGUoZGVsdGFMYXQpICYmIE51bWJlci5pc0Zpbml0ZShkZWx0YVopLFxuICAgICAgRVJSX0FSR1VNRU5UKTtcbiAgICBjb25zdCB7cGl4ZWxzUGVyRGVncmVlLCBtZXRlcnNQZXJQaXhlbH0gPSB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YVggPSBkZWx0YUxuZyAqIHBpeGVsc1BlckRlZ3JlZVswXSAqIG1ldGVyc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGRlbHRhTGF0ICogcGl4ZWxzUGVyRGVncmVlWzFdICogbWV0ZXJzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIGRlbHRhTG5nTGF0Wi5sZW5ndGggPT09IDIgPyBbZGVsdGFYLCBkZWx0YVldIDogW2RlbHRhWCwgZGVsdGFZLCBkZWx0YVpdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1ldGVyIGRlbHRhIHRvIGEgYmFzZSBsbmdsYXQgY29vcmRpbmF0ZSwgcmV0dXJuaW5nIGEgbmV3IGxuZ2xhdCBhcnJheVxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGxuZ0xhdFogLSBiYXNlIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgeHl6IC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIGFkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICAgIGNvbnN0IFtsbmcsIGxhdCwgWiA9IDBdID0gbG5nTGF0WjtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IHRoaXMubWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopO1xuICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0XSA6XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICBfZ2V0UGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAqIHBlcnNwZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAqL1xuZnVuY3Rpb24gcHJvamVjdEZsYXQoW2xuZywgbGF0XSwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICBjb25zdCBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCB4ID0gc2NhbGUgKiAobGFtYmRhMiArIFBJKSAvICgyICogUEkpO1xuICBjb25zdCB5ID0gc2NhbGUgKiAoUEkgLSBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKSAvICgyICogUEkpO1xuICByZXR1cm4gW3gsIHldO1xufVxuXG4vKipcbiAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gKi9cbmZ1bmN0aW9uIHVucHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gIGNvbnN0IGxhbWJkYTIgPSAoeCAvIHNjYWxlKSAqICgyICogUEkpIC0gUEk7XG4gIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChQSSAtICh5IC8gc2NhbGUpICogKDIgKiBQSSkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gKiBkZWdyZWVzIGFuZCBwaXhlbHMuXG4gKiBJbiBtZXJjYXRvciBwcm9qZWN0aW9uIG1vZGUsIHRoZSBkaXN0YW5jZSBzY2FsZXMgdmFyeSBzaWduaWZpY2FudGx5XG4gKiB3aXRoIGxhdGl0dWRlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGV9KSB7XG4gIGFzc2VydCghaXNOYU4obGF0aXR1ZGUpICYmICFpc05hTihsb25naXR1ZGUpICYmICFpc05hTihzY2FsZSksIEVSUl9BUkdVTUVOVCk7XG4gIC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG4gIGNvbnN0IE1FVEVSU19QRVJfREVHUkVFID0gMTExMDAwO1xuXG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgY29uc3QgbWV0ZXJzUGVyRGVncmVlID0gTUVURVJTX1BFUl9ERUdSRUUgKiBsYXRDb3NpbmU7XG5cbiAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsb25naXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWVYID0gdmVjMi5kaXN0YW5jZShcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlICsgMC41LCBsYXRpdHVkZV0sIHNjYWxlKSxcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlIC0gMC41LCBsYXRpdHVkZV0sIHNjYWxlKVxuICApO1xuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxhdGl0dWRlXG4gIC8vIGFyb3VuZCBjdXJyZW50IGxhdC9sb25cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWSA9IHZlYzIuZGlzdGFuY2UoXG4gICAgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgKyAwLjVdLCBzY2FsZSksXG4gICAgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgLSAwLjVdLCBzY2FsZSlcbiAgKTtcblxuICBjb25zdCBwaXhlbHNQZXJNZXRlclggPSBwaXhlbHNQZXJEZWdyZWVYIC8gbWV0ZXJzUGVyRGVncmVlO1xuICBjb25zdCBwaXhlbHNQZXJNZXRlclkgPSBwaXhlbHNQZXJEZWdyZWVZIC8gbWV0ZXJzUGVyRGVncmVlO1xuICBjb25zdCBwaXhlbHNQZXJNZXRlclogPSAocGl4ZWxzUGVyTWV0ZXJYICsgcGl4ZWxzUGVyTWV0ZXJZKSAvIDI7XG4gIC8vIGNvbnN0IHBpeGVsc1Blck1ldGVyID0gW3BpeGVsc1Blck1ldGVyWCwgcGl4ZWxzUGVyTWV0ZXJZLCBwaXhlbHNQZXJNZXRlclpdO1xuXG4gIGNvbnN0IHdvcmxkU2l6ZSA9IFRJTEVfU0laRSAqIHNjYWxlO1xuICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvICg0ZTcgKiBsYXRDb3NpbmUpO1xuICBjb25zdCBwaXhlbHNQZXJNZXRlciA9IFthbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyXTtcbiAgY29uc3QgbWV0ZXJzUGVyUGl4ZWwgPSBbMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBwaXhlbHNQZXJNZXRlclpdO1xuXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZSA9IFtwaXhlbHNQZXJEZWdyZWVYLCBwaXhlbHNQZXJEZWdyZWVZLCBwaXhlbHNQZXJNZXRlclpdO1xuICBjb25zdCBkZWdyZWVzUGVyUGl4ZWwgPSBbMSAvIHBpeGVsc1BlckRlZ3JlZVgsIDEgLyBwaXhlbHNQZXJEZWdyZWVZLCAxIC8gcGl4ZWxzUGVyTWV0ZXJaXTtcblxuICAvLyBNYWluIHJlc3VsdHMsIHVzZWQgZm9yIGNvbnZlcnRpbmcgbWV0ZXJzIHRvIGxhdGxuZyBkZWx0YXMgYW5kIHNjYWxpbmcgb2Zmc2V0c1xuICByZXR1cm4ge1xuICAgIHBpeGVsc1Blck1ldGVyLFxuICAgIG1ldGVyc1BlclBpeGVsLFxuICAgIHBpeGVsc1BlckRlZ3JlZSxcbiAgICBkZWdyZWVzUGVyUGl4ZWxcbiAgfTtcbn1cblxuLy8gQVRUUklCVVRJT046XG4vLyB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpeCBjcmVhdGlvbiBpcyBpbnRlbnRpb25hbGx5IGtlcHQgY29tcGF0aWJsZSB3aXRoXG4vLyBtYXBib3gtZ2wncyBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgdGhhdCBzZWFtbGVzcyBpbnRlcm9wZXJhdGlvblxuLy8gd2l0aCBtYXBib3ggYW5kIHJlYWN0LW1hcC1nbC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qc1xuXG4vLyBWYXJpYWJsZSBmb3YgKGluIHJhZGlhbnMpXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSkge1xuICByZXR1cm4gMiAqIE1hdGguYXRhbigoaGVpZ2h0IC8gMikgLyBhbHRpdHVkZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSkge1xuICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgcG9pbnQgdG8gdGhlIGNlbnRlciB0b3BcbiAgLy8gaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPVxuICAgIE1hdGguc2luKGhhbGZGb3YpICogYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YpO1xuXG4gIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgY29uc3QgZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyBhbHRpdHVkZTtcblxuICByZXR1cm4ge2ZhclosIG5lYXJaOiAwLjF9O1xufVxuXG4vLyBQUk9KRUNUSU9OIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBDQU1FUkEgKFZJRVcpIFNQQUNFIFRPIENMSVBTUEFDRVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgcGl0Y2gsXG4gIGFsdGl0dWRlLFxuICBmYXJaTXVsdGlwbGllciA9IDEwXG59KSB7XG4gIGNvbnN0IHtuZWFyWiwgZmFyWn0gPSBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSk7XG4gIGNvbnN0IGZvdiA9IGdldEZvdih7aGVpZ2h0LCBhbHRpdHVkZX0pO1xuXG4gIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYXQ0LnBlcnNwZWN0aXZlKFxuICAgIGNyZWF0ZU1hdDQoKSxcbiAgICBmb3YsICAgICAgICAgICAgICAvLyBmb3YgaW4gcmFkaWFuc1xuICAgIHdpZHRoIC8gaGVpZ2h0LCAgIC8vIGFzcGVjdCByYXRpb1xuICAgIG5lYXJaLCAgICAgICAgICAgIC8vIG5lYXIgcGxhbmVcbiAgICBmYXJaICogZmFyWk11bHRpcGxpZXIgLy8gZmFyIHBsYW5lXG4gICk7XG5cbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXg7XG59XG5cbmZ1bmN0aW9uIG1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGxvbmdpdHVkZSxcbiAgbGF0aXR1ZGUsXG4gIHpvb20sXG4gIHBpdGNoLFxuICBiZWFyaW5nLFxuICBhbHRpdHVkZSxcbiAgY2VudGVyXG59KSB7XG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBGUk9NIFZJUlRVQUwgUElYRUxTIFRPIENBTUVSQSBTUEFDRVxuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgLy8gTW92ZSBjYW1lcmEgdG8gYWx0aXR1ZGVcbiAgbWF0NC50cmFuc2xhdGUodm0sIHZtLCBbMCwgMCwgLWFsdGl0dWRlXSk7XG5cbiAgLy8gQWZ0ZXIgdGhlIHJvdGF0ZVgsIHogdmFsdWVzIGFyZSBpbiBwaXhlbCB1bml0cy4gQ29udmVydCB0aGVtIHRvXG4gIC8vIGFsdGl0dWRlIHVuaXRzLiAxIGFsdGl0dWRlIHVuaXQgPSB0aGUgc2NyZWVuIGhlaWdodC5cbiAgbWF0NC5zY2FsZSh2bSwgdm0sIFsxLCAtMSwgMSAvIGhlaWdodF0pO1xuXG4gIC8vIFJvdGF0ZSBieSBiZWFyaW5nLCBhbmQgdGhlbiBieSBwaXRjaCAod2hpY2ggdGlsdHMgdGhlIHZpZXcpXG4gIG1hdDQucm90YXRlWCh2bSwgdm0sIHBpdGNoICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgbWF0NC5yb3RhdGVaKHZtLCB2bSwgLWJlYXJpbmcgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuXG4gIHJldHVybiB2bTtcbn1cbiJdfQ==