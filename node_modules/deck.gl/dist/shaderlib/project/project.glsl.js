"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "const float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\n\n// ref: lib/constants.js\nconst float PROJECT_IDENTITY = 0.;\nconst float PROJECT_MERCATOR = 1.;\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\n\nuniform float projectionMode;\nuniform float projectionScale;\nuniform vec4 projectionCenter;\nuniform vec3 projectionPixelsPerUnit;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 projectionMatrixUncentered;\n\n#ifdef INTEL_TAN_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef INTEL_TAN_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n\n//\n// Scaling offsets\n//\n\nfloat project_scale(float meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return meters * projectionPixelsPerUnit.x;\n  }\n}\n\nvec2 project_scale(vec2 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec2(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec3 project_scale(vec3 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec3(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec4 project_scale(vec4 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec4(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x,\n      meters.w\n    );\n  }\n}\n\n//\n// Projecting positions\n//\n\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\nvec2 project_mercator_(vec2 lnglat) {\n  return vec2(\n    radians(lnglat.x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nvec2 project_position(vec2 position) {\n  if (projectionMode == PROJECT_IDENTITY) {\n    return position;\n  }\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return position;\n    return project_scale(position);\n  }\n  // Covers projectionMode == PROJECT_MERCATOR\n  return project_mercator_(position) * WORLD_SCALE * projectionScale;\n}\n\nvec3 project_position(vec3 position) {\n  return vec3(project_position(position.xy), project_scale(position.z));\n}\n\nvec4 project_position(vec4 position) {\n  return vec4(project_position(position.xyz), position.w);\n}\n\n//\n\nvec4 project_to_viewspace(vec4 position) {\n  return modelViewMatrix * position;\n}\n\nvec4 project_to_clipspace(vec4 position) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    position = position * projectionPixelsPerUnit.x;\n  }\n  return projectionMatrix * position + projectionCenter;\n}\n\n// Backwards compatibility\n\nfloat scale(float position) {\n  return project_scale(position);\n}\n\nvec2 scale(vec2 position) {\n  return project_scale(position);\n}\n\nvec3 scale(vec3 position) {\n  return project_scale(position);\n}\n\nvec4 scale(vec4 position) {\n  return project_scale(position);\n}\n\nvec2 preproject(vec2 position) {\n  return project_position(position);\n}\n\nvec3 preproject(vec3 position) {\n  return project_position(position);\n}\n\nvec4 preproject(vec4 position) {\n  return project_position(position);\n}\n\nvec4 project(vec4 position) {\n  return project_to_clipspace(position);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9wcm9qZWN0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwcm9qZWN0Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG5jb25zdCBmbG9hdCBUSUxFX1NJWkUgPSA1MTIuMDtcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM2O1xuY29uc3QgZmxvYXQgV09STERfU0NBTEUgPSBUSUxFX1NJWkUgLyAoUEkgKiAyLjApO1xuXG4vLyByZWY6IGxpYi9jb25zdGFudHMuanNcbmNvbnN0IGZsb2F0IFBST0pFQ1RfSURFTlRJVFkgPSAwLjtcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTUVSQ0FUT1IgPSAxLjtcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUyA9IDIuO1xuXG51bmlmb3JtIGZsb2F0IHByb2plY3Rpb25Nb2RlO1xudW5pZm9ybSBmbG9hdCBwcm9qZWN0aW9uU2NhbGU7XG51bmlmb3JtIHZlYzQgcHJvamVjdGlvbkNlbnRlcjtcbnVuaWZvcm0gdmVjMyBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdDtcblxudW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkO1xuXG4jaWZkZWYgSU5URUxfVEFOX1dPUktBUk9VTkRcblxuLy8gQWxsIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZm9yIHN1YnN0aXR1dGluZyB0YW4oKSBmdW5jdGlvbiBmcm9tIEludGVsIEdQVSBvbmx5XG5jb25zdCBmbG9hdCBUV09fUEkgPSA2LjI4MzE4NTQ4MjAyNTE0NjU7XG5jb25zdCBmbG9hdCBQSV8yID0gMS41NzA3OTYzNzA1MDYyODY2O1xuY29uc3QgZmxvYXQgUElfMTYgPSAwLjE5NjM0OTU0NjMxMzI4NTg7XG5cbmNvbnN0IGZsb2F0IFNJTl9UQUJMRV8wID0gMC4xOTUwOTAzMjM2ODY1OTk3MztcbmNvbnN0IGZsb2F0IFNJTl9UQUJMRV8xID0gMC4zODI2ODM0MjYxNDE3Mzg5O1xuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzIgPSAwLjU1NTU3MDI0NDc4OTEyMzU7XG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMyA9IDAuNzA3MTA2NzY5MDg0OTMwNDtcblxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzAgPSAwLjk4MDc4NTI1MDY2Mzc1NzM7XG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMSA9IDAuOTIzODc5NTA0MjAzNzk2NDtcbmNvbnN0IGZsb2F0IENPU19UQUJMRV8yID0gMC44MzE0Njk1OTU0MzIyODE1O1xuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XG5cbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzMgPSAxLjY2NjY2NjcxNjMzNzIwNGUtMDE7IC8vIDEvMyFcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzUgPSA4LjMzMzMzMzc2Nzk1MDUzNWUtMDM7IC8vIDEvNSFcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzcgPSAxLjk4NDEyNzAxMTM4Mjk1MjNlLTA0OyAvLyAxLzchXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF85ID0gMi43NTU3MzE4ODQ0NjI4NzUzM2UtMDY7IC8vIDEvOSFcblxuZmxvYXQgc2luX3RheWxvcl9mcDMyKGZsb2F0IGEpIHtcbiAgZmxvYXQgciwgcywgdCwgeDtcblxuICBpZiAoYSA9PSAwLjApIHtcbiAgICByZXR1cm4gMC4wO1xuICB9XG5cbiAgeCA9IC1hICogYTtcbiAgcyA9IGE7XG4gIHIgPSBhO1xuXG4gIHIgPSByICogeDtcbiAgdCA9IHIgKiBJTlZFUlNFX0ZBQ1RPUklBTF8zO1xuICBzID0gcyArIHQ7XG5cbiAgciA9IHIgKiB4O1xuICB0ID0gciAqIElOVkVSU0VfRkFDVE9SSUFMXzU7XG4gIHMgPSBzICsgdDtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNztcbiAgcyA9IHMgKyB0O1xuXG4gIHIgPSByICogeDtcbiAgdCA9IHIgKiBJTlZFUlNFX0ZBQ1RPUklBTF85O1xuICBzID0gcyArIHQ7XG5cbiAgcmV0dXJuIHM7XG59XG5cbnZvaWQgc2luY29zX3RheWxvcl9mcDMyKGZsb2F0IGEsIG91dCBmbG9hdCBzaW5fdCwgb3V0IGZsb2F0IGNvc190KSB7XG4gIGlmIChhID09IDAuMCkge1xuICAgIHNpbl90ID0gMC4wO1xuICAgIGNvc190ID0gMS4wO1xuICB9XG4gIHNpbl90ID0gc2luX3RheWxvcl9mcDMyKGEpO1xuICBjb3NfdCA9IHNxcnQoMS4wIC0gc2luX3QgKiBzaW5fdCk7XG59XG5cbmZsb2F0IHRhbl90YXlsb3JfZnAzMihmbG9hdCBhKSB7XG4gICAgZmxvYXQgc2luX2E7XG4gICAgZmxvYXQgY29zX2E7XG5cbiAgICBpZiAoYSA9PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIDAuMDtcbiAgICB9XG5cbiAgICAvLyAycGkgcmFuZ2UgcmVkdWN0aW9uXG4gICAgZmxvYXQgeiA9IGZsb29yKGEgLyBUV09fUEkpO1xuICAgIGZsb2F0IHIgPSBhIC0gVFdPX1BJICogejtcblxuICAgIGZsb2F0IHQ7XG4gICAgZmxvYXQgcSA9IGZsb29yKHIgLyBQSV8yICsgMC41KTtcbiAgICBpbnQgaiA9IGludChxKTtcblxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcbiAgICB9XG5cbiAgICB0ID0gciAtIFBJXzIgKiBxO1xuXG4gICAgcSA9IGZsb29yKHQgLyBQSV8xNiArIDAuNSk7XG4gICAgaW50IGsgPSBpbnQocSk7XG4gICAgaW50IGFic19rID0gaW50KGFicyhmbG9hdChrKSkpO1xuXG4gICAgaWYgKGFic19rID4gNCkge1xuICAgICAgICByZXR1cm4gMC4wIC8gMC4wO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSB0IC0gUElfMTYgKiBxO1xuICAgIH1cblxuICAgIGZsb2F0IHUgPSAwLjA7XG4gICAgZmxvYXQgdiA9IDAuMDtcblxuICAgIGZsb2F0IHNpbl90LCBjb3NfdDtcbiAgICBmbG9hdCBzLCBjO1xuICAgIHNpbmNvc190YXlsb3JfZnAzMih0LCBzaW5fdCwgY29zX3QpO1xuXG4gICAgaWYgKGsgPT0gMCkge1xuICAgICAgICBzID0gc2luX3Q7XG4gICAgICAgIGMgPSBjb3NfdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDEuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMDtcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8xO1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8xO1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzI7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzI7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDQuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMztcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHMgPSB1ICogc2luX3QgKyB2ICogY29zX3Q7XG4gICAgICAgICAgICBjID0gdSAqIGNvc190IC0gdiAqIHNpbl90O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IHUgKiBzaW5fdCAtIHYgKiBjb3NfdDtcbiAgICAgICAgICAgIGMgPSB1ICogY29zX3QgKyB2ICogc2luX3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgIHNpbl9hID0gcztcbiAgICAgICAgY29zX2EgPSBjO1xuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgIHNpbl9hID0gYztcbiAgICAgICAgY29zX2EgPSAtcztcbiAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcbiAgICAgICAgc2luX2EgPSAtYztcbiAgICAgICAgY29zX2EgPSBzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbl9hID0gLXM7XG4gICAgICAgIGNvc19hID0gLWM7XG4gICAgfVxuICAgIHJldHVybiBzaW5fYSAvIGNvc19hO1xufVxuI2VuZGlmXG5cbmZsb2F0IHRhbl9mcDMyKGZsb2F0IGEpIHtcbiNpZmRlZiBJTlRFTF9UQU5fV09SS0FST1VORFxuICByZXR1cm4gdGFuX3RheWxvcl9mcDMyKGEpO1xuI2Vsc2VcbiAgcmV0dXJuIHRhbihhKTtcbiNlbmRpZlxufVxuXG4vL1xuLy8gU2NhbGluZyBvZmZzZXRzXG4vL1xuXG5mbG9hdCBwcm9qZWN0X3NjYWxlKGZsb2F0IG1ldGVycykge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcmV0dXJuIG1ldGVycztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWV0ZXJzICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueDtcbiAgfVxufVxuXG52ZWMyIHByb2plY3Rfc2NhbGUodmVjMiBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZlYzIoXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueSAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LnhcbiAgICApO1xuICB9XG59XG5cbnZlYzMgcHJvamVjdF9zY2FsZSh2ZWMzIG1ldGVycykge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcmV0dXJuIG1ldGVycztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmVjMyhcbiAgICAgIG1ldGVycy54ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy55ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy56ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueFxuICAgICk7XG4gIH1cbn1cblxudmVjNCBwcm9qZWN0X3NjYWxlKHZlYzQgbWV0ZXJzKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICByZXR1cm4gbWV0ZXJzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2ZWM0KFxuICAgICAgbWV0ZXJzLnggKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLnogKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLndcbiAgICApO1xuICB9XG59XG5cbi8vXG4vLyBQcm9qZWN0aW5nIHBvc2l0aW9uc1xuLy9cblxuLy8gbm9uLWxpbmVhciBwcm9qZWN0aW9uOiBsbmdsYXRzID0+IHVuaXQgdGlsZSBbMC0xLCAwLTFdXG52ZWMyIHByb2plY3RfbWVyY2F0b3JfKHZlYzIgbG5nbGF0KSB7XG4gIHJldHVybiB2ZWMyKFxuICAgIHJhZGlhbnMobG5nbGF0LngpICsgUEksXG4gICAgUEkgLSBsb2codGFuX2ZwMzIoUEkgKiAwLjI1ICsgcmFkaWFucyhsbmdsYXQueSkgKiAwLjUpKVxuICApO1xufVxuXG52ZWMyIHByb2plY3RfcG9zaXRpb24odmVjMiBwb3NpdGlvbikge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9JREVOVElUWSkge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbiAgfVxuICAvLyBDb3ZlcnMgcHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUlxuICByZXR1cm4gcHJvamVjdF9tZXJjYXRvcl8ocG9zaXRpb24pICogV09STERfU0NBTEUgKiBwcm9qZWN0aW9uU2NhbGU7XG59XG5cbnZlYzMgcHJvamVjdF9wb3NpdGlvbih2ZWMzIHBvc2l0aW9uKSB7XG4gIHJldHVybiB2ZWMzKHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24ueHkpLCBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uLnopKTtcbn1cblxudmVjNCBwcm9qZWN0X3Bvc2l0aW9uKHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHZlYzQocHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbi54eXopLCBwb3NpdGlvbi53KTtcbn1cblxuLy9cblxudmVjNCBwcm9qZWN0X3RvX3ZpZXdzcGFjZSh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBtb2RlbFZpZXdNYXRyaXggKiBwb3NpdGlvbjtcbn1cblxudmVjNCBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0IHBvc2l0aW9uKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueDtcbiAgfVxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeCAqIHBvc2l0aW9uICsgcHJvamVjdGlvbkNlbnRlcjtcbn1cblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuZmxvYXQgc2NhbGUoZmxvYXQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWMyIHNjYWxlKHZlYzIgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWMzIHNjYWxlKHZlYzMgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWM0IHNjYWxlKHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWMyIHByZXByb2plY3QodmVjMiBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbik7XG59XG5cbnZlYzMgcHJlcHJvamVjdCh2ZWMzIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uKTtcbn1cblxudmVjNCBwcmVwcm9qZWN0KHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xufVxuXG52ZWM0IHByb2plY3QodmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF90b19jbGlwc3BhY2UocG9zaXRpb24pO1xufVxuYDtcbiJdfQ==